mod ctypes {
                    pub type c_void = core::ffi::c_void;
                    pub type c_char = u8;
                    pub type c_int = i32;
                    pub type c_long = i64;
                    pub type c_longlong = i64;
                    pub type c_schar = i8;
                    pub type c_short = i16;
                    pub type c_uchar = u8;
                    pub type c_uint = u32;
                    pub type c_ulong = u64;
                    pub type c_ulonglong = u64;
                    pub type c_ushort = u16;
                    pub type size_t = u64;
                    pub type ssize_t = i64;
                    pub type c_float = f32;
                    pub type c_double = f64;
                }/* automatically generated by rust-bindgen */

pub const __LINUX__ : i32 = 1 ; pub const SIZEOF_VOIDP : i32 = 8 ; pub const HAVE_GCC_ATOMICS : i32 = 1 ; pub const HAVE_LIBC : i32 = 1 ; pub const STDC_HEADERS : i32 = 1 ; pub const HAVE_ALLOCA_H : i32 = 1 ; pub const HAVE_CTYPE_H : i32 = 1 ; pub const HAVE_FLOAT_H : i32 = 1 ; pub const HAVE_ICONV_H : i32 = 1 ; pub const HAVE_INTTYPES_H : i32 = 1 ; pub const HAVE_LIMITS_H : i32 = 1 ; pub const HAVE_MALLOC_H : i32 = 1 ; pub const HAVE_MATH_H : i32 = 1 ; pub const HAVE_MEMORY_H : i32 = 1 ; pub const HAVE_SIGNAL_H : i32 = 1 ; pub const HAVE_STDARG_H : i32 = 1 ; pub const HAVE_STDINT_H : i32 = 1 ; pub const HAVE_STDIO_H : i32 = 1 ; pub const HAVE_STDLIB_H : i32 = 1 ; pub const HAVE_STRINGS_H : i32 = 1 ; pub const HAVE_STRING_H : i32 = 1 ; pub const HAVE_SYS_TYPES_H : i32 = 1 ; pub const HAVE_WCHAR_H : i32 = 1 ; pub const HAVE_MALLOC : i32 = 1 ; pub const HAVE_CALLOC : i32 = 1 ; pub const HAVE_REALLOC : i32 = 1 ; pub const HAVE_FREE : i32 = 1 ; pub const HAVE_ALLOCA : i32 = 1 ; pub const HAVE_GETENV : i32 = 1 ; pub const HAVE_SETENV : i32 = 1 ; pub const HAVE_PUTENV : i32 = 1 ; pub const HAVE_UNSETENV : i32 = 1 ; pub const HAVE_QSORT : i32 = 1 ; pub const HAVE_ABS : i32 = 1 ; pub const HAVE_BCOPY : i32 = 1 ; pub const HAVE_MEMSET : i32 = 1 ; pub const HAVE_MEMCPY : i32 = 1 ; pub const HAVE_MEMMOVE : i32 = 1 ; pub const HAVE_WCSLEN : i32 = 1 ; pub const HAVE_WCSCMP : i32 = 1 ; pub const HAVE_STRLEN : i32 = 1 ; pub const HAVE_STRLCPY : i32 = 1 ; pub const HAVE_STRLCAT : i32 = 1 ; pub const HAVE_STRCHR : i32 = 1 ; pub const HAVE_STRRCHR : i32 = 1 ; pub const HAVE_STRSTR : i32 = 1 ; pub const HAVE_ITOA : i32 = 1 ; pub const HAVE_STRTOL : i32 = 1 ; pub const HAVE_STRTOUL : i32 = 1 ; pub const HAVE_STRTOLL : i32 = 1 ; pub const HAVE_STRTOULL : i32 = 1 ; pub const HAVE_ATOI : i32 = 1 ; pub const HAVE_ATOF : i32 = 1 ; pub const HAVE_STRCMP : i32 = 1 ; pub const HAVE_STRNCMP : i32 = 1 ; pub const HAVE_STRCASECMP : i32 = 1 ; pub const HAVE_STRNCASECMP : i32 = 1 ; pub const HAVE_VSSCANF : i32 = 1 ; pub const HAVE_VSNPRINTF : i32 = 1 ; pub const HAVE_ACOS : i32 = 1 ; pub const HAVE_ACOSF : i32 = 1 ; pub const HAVE_ASIN : i32 = 1 ; pub const HAVE_ASINF : i32 = 1 ; pub const HAVE_ATAN : i32 = 1 ; pub const HAVE_ATANF : i32 = 1 ; pub const HAVE_ATAN2 : i32 = 1 ; pub const HAVE_ATAN2F : i32 = 1 ; pub const HAVE_CEIL : i32 = 1 ; pub const HAVE_CEILF : i32 = 1 ; pub const HAVE_COPYSIGN : i32 = 1 ; pub const HAVE_COPYSIGNF : i32 = 1 ; pub const HAVE_COS : i32 = 1 ; pub const HAVE_COSF : i32 = 1 ; pub const HAVE_FABS : i32 = 1 ; pub const HAVE_FABSF : i32 = 1 ; pub const HAVE_FLOOR : i32 = 1 ; pub const HAVE_FLOORF : i32 = 1 ; pub const HAVE_FMOD : i32 = 1 ; pub const HAVE_FMODF : i32 = 1 ; pub const HAVE_LOG : i32 = 1 ; pub const HAVE_LOGF : i32 = 1 ; pub const HAVE_LOG10 : i32 = 1 ; pub const HAVE_LOG10F : i32 = 1 ; pub const HAVE_POWF : i32 = 1 ; pub const HAVE_SCALBN : i32 = 1 ; pub const HAVE_SCALBNF : i32 = 1 ; pub const HAVE_SIN : i32 = 1 ; pub const HAVE_SINF : i32 = 1 ; pub const HAVE_SQRT : i32 = 1 ; pub const HAVE_SQRTF : i32 = 1 ; pub const HAVE_TAN : i32 = 1 ; pub const HAVE_TANF : i32 = 1 ; pub const HAVE_FSEEKO : i32 = 1 ; pub const HAVE_SETJMP : i32 = 1 ; pub const HAVE_NANOSLEEP : i32 = 1 ; pub const HAVE_SYSCTLBYNAME : i32 = 1 ; pub const HAVE_POLL : i32 = 1 ; pub const SDL_CPUINFO_DISABLED : i32 = 1 ; pub const SDL_HAPTIC_DISABLED : i32 = 1 ; pub const SDL_LOADSO_DISABLED : i32 = 1 ; pub const SDL_POWER_DISABLED : i32 = 1 ; pub const SDL_FILESYSTEM_DISABLED : i32 = 1 ; pub const SDL_AUDIO_DRIVER_SWITCH : i32 = 1 ; pub const SDL_JOYSTICK_SWITCH : i32 = 1 ; pub const SDL_THREAD_SWITCH : i32 = 1 ; pub const SDL_TIMER_SWITCH : i32 = 1 ; pub const SDL_VIDEO_DRIVER_SWITCH : i32 = 1 ; pub const SDL_VIDEO_RENDER_OGL_ES2 : i32 = 1 ; pub const SDL_VIDEO_OPENGL : i32 = 1 ; pub const SDL_VIDEO_OPENGL_ES2 : i32 = 1 ; pub const SDL_VIDEO_OPENGL_EGL : i32 = 1 ; pub const SDL_ASSEMBLY_ROUTINES : i32 = 1 ; pub const __NEWLIB_H__ : i32 = 1 ; pub const _NEWLIB_VERSION_H__ : i32 = 1 ; pub const _NEWLIB_VERSION : & 'static [ u8 ; 6usize ] = b"3.1.0\0" ; pub const __NEWLIB__ : i32 = 3 ; pub const __NEWLIB_MINOR__ : i32 = 1 ; pub const __NEWLIB_PATCHLEVEL__ : i32 = 0 ; pub const _WANT_IO_C99_FORMATS : i32 = 1 ; pub const _WANT_IO_LONG_LONG : i32 = 1 ; pub const _WANT_IO_POS_ARGS : i32 = 1 ; pub const _MB_CAPABLE : i32 = 1 ; pub const _MB_LEN_MAX : i32 = 8 ; pub const HAVE_INITFINI_ARRAY : i32 = 1 ; pub const _ATEXIT_DYNAMIC_ALLOC : i32 = 1 ; pub const _HAVE_LONG_DOUBLE : i32 = 1 ; pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL : i32 = 1 ; pub const _FVWRITE_IN_STREAMIO : i32 = 1 ; pub const _FSEEK_OPTIMIZATION : i32 = 1 ; pub const _UNBUF_STREAM_OPT : i32 = 1 ; pub const __OBSOLETE_MATH_DEFAULT : i32 = 1 ; pub const __OBSOLETE_MATH : i32 = 1 ; pub const _DEFAULT_SOURCE : i32 = 1 ; pub const _POSIX_SOURCE : i32 = 1 ; pub const _POSIX_C_SOURCE : i32 = 200809 ; pub const _ATFILE_SOURCE : i32 = 1 ; pub const __ATFILE_VISIBLE : i32 = 1 ; pub const __BSD_VISIBLE : i32 = 1 ; pub const __GNU_VISIBLE : i32 = 0 ; pub const __ISO_C_VISIBLE : i32 = 2011 ; pub const __LARGEFILE_VISIBLE : i32 = 0 ; pub const __MISC_VISIBLE : i32 = 1 ; pub const __POSIX_VISIBLE : i32 = 200809 ; pub const __SVID_VISIBLE : i32 = 1 ; pub const __XSI_VISIBLE : i32 = 0 ; pub const __SSP_FORTIFY_LEVEL : i32 = 0 ; pub const __RAND_MAX : u32 = 2147483647 ; pub const __have_longlong64 : i32 = 1 ; pub const __have_long64 : i32 = 1 ; pub const ___int8_t_defined : i32 = 1 ; pub const ___int16_t_defined : i32 = 1 ; pub const ___int32_t_defined : i32 = 1 ; pub const ___int64_t_defined : i32 = 1 ; pub const ___int_least8_t_defined : i32 = 1 ; pub const ___int_least16_t_defined : i32 = 1 ; pub const ___int_least32_t_defined : i32 = 1 ; pub const ___int_least64_t_defined : i32 = 1 ; pub const __GNUCLIKE_ASM : i32 = 3 ; pub const __GNUCLIKE___TYPEOF : i32 = 1 ; pub const __GNUCLIKE___OFFSETOF : i32 = 1 ; pub const __GNUCLIKE___SECTION : i32 = 1 ; pub const __GNUCLIKE_CTOR_SECTION_HANDLING : i32 = 1 ; pub const __GNUCLIKE_BUILTIN_CONSTANT_P : i32 = 1 ; pub const __GNUCLIKE_BUILTIN_VARARGS : i32 = 1 ; pub const __GNUCLIKE_BUILTIN_STDARG : i32 = 1 ; pub const __GNUCLIKE_BUILTIN_VAALIST : i32 = 1 ; pub const __GNUC_VA_LIST_COMPATIBILITY : i32 = 1 ; pub const __GNUCLIKE_BUILTIN_NEXT_ARG : i32 = 1 ; pub const __GNUCLIKE_BUILTIN_MEMCPY : i32 = 1 ; pub const __CC_SUPPORTS_INLINE : i32 = 1 ; pub const __CC_SUPPORTS___INLINE : i32 = 1 ; pub const __CC_SUPPORTS___INLINE__ : i32 = 1 ; pub const __CC_SUPPORTS___FUNC__ : i32 = 1 ; pub const __CC_SUPPORTS_WARNING : i32 = 1 ; pub const __CC_SUPPORTS_VARADIC_XXX : i32 = 1 ; pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT : i32 = 1 ; pub const __BIT_TYPES_DEFINED__ : i32 = 1 ; pub const __int20 : i32 = 2 ; pub const __INT8 : & 'static [ u8 ; 3usize ] = b"hh\0" ; pub const __INT16 : & 'static [ u8 ; 2usize ] = b"h\0" ; pub const __INT64 : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const __FAST8 : & 'static [ u8 ; 3usize ] = b"hh\0" ; pub const __FAST16 : & 'static [ u8 ; 2usize ] = b"h\0" ; pub const __FAST64 : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const __LEAST8 : & 'static [ u8 ; 3usize ] = b"hh\0" ; pub const __LEAST16 : & 'static [ u8 ; 2usize ] = b"h\0" ; pub const __LEAST64 : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const __int8_t_defined : i32 = 1 ; pub const __int16_t_defined : i32 = 1 ; pub const __int32_t_defined : i32 = 1 ; pub const __int64_t_defined : i32 = 1 ; pub const __int_least8_t_defined : i32 = 1 ; pub const __int_least16_t_defined : i32 = 1 ; pub const __int_least32_t_defined : i32 = 1 ; pub const __int_least64_t_defined : i32 = 1 ; pub const __int_fast8_t_defined : i32 = 1 ; pub const __int_fast16_t_defined : i32 = 1 ; pub const __int_fast32_t_defined : i32 = 1 ; pub const __int_fast64_t_defined : i32 = 1 ; pub const WINT_MIN : i32 = 0 ; pub const _LITTLE_ENDIAN : i32 = 1234 ; pub const _BIG_ENDIAN : i32 = 4321 ; pub const _PDP_ENDIAN : i32 = 3412 ; pub const _BYTE_ORDER : i32 = 1234 ; pub const _QUAD_HIGHWORD : i32 = 1 ; pub const _QUAD_LOWWORD : i32 = 0 ; pub const LITTLE_ENDIAN : i32 = 1234 ; pub const BIG_ENDIAN : i32 = 4321 ; pub const PDP_ENDIAN : i32 = 3412 ; pub const BYTE_ORDER : i32 = 1234 ; pub const FD_SETSIZE : i32 = 64 ; pub const SCHED_OTHER : i32 = 0 ; pub const SCHED_FIFO : i32 = 1 ; pub const SCHED_RR : i32 = 2 ; pub const PTHREAD_SCOPE_PROCESS : i32 = 0 ; pub const PTHREAD_SCOPE_SYSTEM : i32 = 1 ; pub const PTHREAD_INHERIT_SCHED : i32 = 1 ; pub const PTHREAD_EXPLICIT_SCHED : i32 = 2 ; pub const PTHREAD_CREATE_DETACHED : i32 = 0 ; pub const PTHREAD_CREATE_JOINABLE : i32 = 1 ; pub const _NULL : i32 = 0 ; pub const _ATEXIT_SIZE : i32 = 32 ; pub const _RAND48_SEED_0 : i32 = 13070 ; pub const _RAND48_SEED_1 : i32 = 43981 ; pub const _RAND48_SEED_2 : i32 = 4660 ; pub const _RAND48_MULT_0 : i32 = 58989 ; pub const _RAND48_MULT_1 : i32 = 57068 ; pub const _RAND48_MULT_2 : i32 = 5 ; pub const _RAND48_ADD : i32 = 11 ; pub const _REENT_EMERGENCY_SIZE : i32 = 25 ; pub const _REENT_ASCTIME_SIZE : i32 = 26 ; pub const _REENT_SIGNAL_SIZE : i32 = 24 ; pub const _N_LISTS : i32 = 30 ; pub const __SLBF : i32 = 1 ; pub const __SNBF : i32 = 2 ; pub const __SRD : i32 = 4 ; pub const __SWR : i32 = 8 ; pub const __SRW : i32 = 16 ; pub const __SEOF : i32 = 32 ; pub const __SERR : i32 = 64 ; pub const __SMBF : i32 = 128 ; pub const __SAPP : i32 = 256 ; pub const __SSTR : i32 = 512 ; pub const __SOPT : i32 = 1024 ; pub const __SNPT : i32 = 2048 ; pub const __SOFF : i32 = 4096 ; pub const __SORD : i32 = 8192 ; pub const __SL64 : i32 = 32768 ; pub const __SNLK : i32 = 1 ; pub const __SWID : i32 = 8192 ; pub const _IOFBF : i32 = 0 ; pub const _IOLBF : i32 = 1 ; pub const _IONBF : i32 = 2 ; pub const EOF : i32 = -1 ; pub const BUFSIZ : i32 = 1024 ; pub const FOPEN_MAX : i32 = 20 ; pub const FILENAME_MAX : i32 = 1024 ; pub const L_tmpnam : i32 = 1024 ; pub const P_tmpdir : & 'static [ u8 ; 5usize ] = b"/tmp\0" ; pub const SEEK_SET : i32 = 0 ; pub const SEEK_CUR : i32 = 1 ; pub const SEEK_END : i32 = 2 ; pub const TMP_MAX : i32 = 26 ; pub const L_ctermid : i32 = 16 ; pub const EXIT_FAILURE : i32 = 1 ; pub const EXIT_SUCCESS : i32 = 0 ; pub const RAND_MAX : u32 = 2147483647 ; pub const _U : i32 = 1 ; pub const _L : i32 = 2 ; pub const _N : i32 = 4 ; pub const _S : i32 = 8 ; pub const _P : i32 = 16 ; pub const _C : i32 = 32 ; pub const _X : i32 = 64 ; pub const _B : i32 = 128 ; pub const _M_LN2 : f64 = 0.6931471805599453 ; pub const FP_NAN : i32 = 0 ; pub const FP_INFINITE : i32 = 1 ; pub const FP_ZERO : i32 = 2 ; pub const FP_SUBNORMAL : i32 = 3 ; pub const FP_NORMAL : i32 = 4 ; pub const MATH_ERRNO : i32 = 1 ; pub const MATH_ERREXCEPT : i32 = 2 ; pub const math_errhandling : i32 = 1 ; pub const DOMAIN : i32 = 1 ; pub const SING : i32 = 2 ; pub const OVERFLOW : i32 = 3 ; pub const UNDERFLOW : i32 = 4 ; pub const TLOSS : i32 = 5 ; pub const PLOSS : i32 = 6 ; pub const M_E : f64 = 2.718281828459045 ; pub const M_LOG2E : f64 = 1.4426950408889634 ; pub const M_LOG10E : f64 = 0.4342944819032518 ; pub const M_LN2 : f64 = 0.6931471805599453 ; pub const M_LN10 : f64 = 2.302585092994046 ; pub const M_PI : f64 = 3.141592653589793 ; pub const M_PI_2 : f64 = 1.5707963267948966 ; pub const M_PI_4 : f64 = 0.7853981633974483 ; pub const M_1_PI : f64 = 0.3183098861837907 ; pub const M_2_PI : f64 = 0.6366197723675814 ; pub const M_2_SQRTPI : f64 = 1.1283791670955126 ; pub const M_SQRT2 : f64 = 1.4142135623730951 ; pub const M_SQRT1_2 : f64 = 0.7071067811865476 ; pub const M_TWOPI : f64 = 6.283185307179586 ; pub const M_SQRTPI : f64 = 1.772453850905516 ; pub const M_SQRT3 : f64 = 1.7320508075688772 ; pub const M_IVLN10 : f64 = 0.4342944819032518 ; pub const M_LOG2_E : f64 = 0.6931471805599453 ; pub const FLT_ROUNDS : i32 = 1 ; pub const SDL_PRIs64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SDL_ASSERT_LEVEL : i32 = 2 ; pub const SDL_NULL_WHILE_LOOP_CONDITION : i32 = 0 ; pub const SDL_LIL_ENDIAN : i32 = 1234 ; pub const SDL_BIG_ENDIAN : i32 = 4321 ; pub const SDL_BYTEORDER : i32 = 1234 ; pub const SDL_MUTEX_TIMEDOUT : i32 = 1 ; pub const SDL_RWOPS_UNKNOWN : i32 = 0 ; pub const SDL_RWOPS_WINFILE : i32 = 1 ; pub const SDL_RWOPS_STDFILE : i32 = 2 ; pub const SDL_RWOPS_JNIFILE : i32 = 3 ; pub const SDL_RWOPS_MEMORY : i32 = 4 ; pub const SDL_RWOPS_MEMORY_RO : i32 = 5 ; pub const RW_SEEK_SET : i32 = 0 ; pub const RW_SEEK_CUR : i32 = 1 ; pub const RW_SEEK_END : i32 = 2 ; pub const SDL_AUDIO_MASK_BITSIZE : i32 = 255 ; pub const SDL_AUDIO_MASK_DATATYPE : i32 = 256 ; pub const SDL_AUDIO_MASK_ENDIAN : i32 = 4096 ; pub const SDL_AUDIO_MASK_SIGNED : i32 = 32768 ; pub const AUDIO_U8 : i32 = 8 ; pub const AUDIO_S8 : i32 = 32776 ; pub const AUDIO_U16LSB : i32 = 16 ; pub const AUDIO_S16LSB : i32 = 32784 ; pub const AUDIO_U16MSB : i32 = 4112 ; pub const AUDIO_S16MSB : i32 = 36880 ; pub const AUDIO_U16 : i32 = 16 ; pub const AUDIO_S16 : i32 = 32784 ; pub const AUDIO_S32LSB : i32 = 32800 ; pub const AUDIO_S32MSB : i32 = 36896 ; pub const AUDIO_S32 : i32 = 32800 ; pub const AUDIO_F32LSB : i32 = 33056 ; pub const AUDIO_F32MSB : i32 = 37152 ; pub const AUDIO_F32 : i32 = 33056 ; pub const AUDIO_U16SYS : i32 = 16 ; pub const AUDIO_S16SYS : i32 = 32784 ; pub const AUDIO_S32SYS : i32 = 32800 ; pub const AUDIO_F32SYS : i32 = 33056 ; pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE : i32 = 1 ; pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE : i32 = 2 ; pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE : i32 = 4 ; pub const SDL_AUDIO_ALLOW_ANY_CHANGE : i32 = 7 ; pub const SDL_AUDIOCVT_MAX_FILTERS : i32 = 9 ; pub const SDL_MIX_MAXVOLUME : i32 = 128 ; pub const _MM_HINT_T0 : i32 = 3 ; pub const _MM_HINT_T1 : i32 = 2 ; pub const _MM_HINT_T2 : i32 = 1 ; pub const _MM_HINT_NTA : i32 = 0 ; pub const _MM_EXCEPT_INVALID : i32 = 1 ; pub const _MM_EXCEPT_DENORM : i32 = 2 ; pub const _MM_EXCEPT_DIV_ZERO : i32 = 4 ; pub const _MM_EXCEPT_OVERFLOW : i32 = 8 ; pub const _MM_EXCEPT_UNDERFLOW : i32 = 16 ; pub const _MM_EXCEPT_INEXACT : i32 = 32 ; pub const _MM_EXCEPT_MASK : i32 = 63 ; pub const _MM_MASK_INVALID : i32 = 128 ; pub const _MM_MASK_DENORM : i32 = 256 ; pub const _MM_MASK_DIV_ZERO : i32 = 512 ; pub const _MM_MASK_OVERFLOW : i32 = 1024 ; pub const _MM_MASK_UNDERFLOW : i32 = 2048 ; pub const _MM_MASK_INEXACT : i32 = 4096 ; pub const _MM_MASK_MASK : i32 = 8064 ; pub const _MM_ROUND_NEAREST : i32 = 0 ; pub const _MM_ROUND_DOWN : i32 = 8192 ; pub const _MM_ROUND_UP : i32 = 16384 ; pub const _MM_ROUND_TOWARD_ZERO : i32 = 24576 ; pub const _MM_ROUND_MASK : i32 = 24576 ; pub const _MM_FLUSH_ZERO_MASK : i32 = 32768 ; pub const _MM_FLUSH_ZERO_ON : i32 = 32768 ; pub const _MM_FLUSH_ZERO_OFF : i32 = 0 ; pub const _MM_DENORMALS_ZERO_ON : i32 = 64 ; pub const _MM_DENORMALS_ZERO_OFF : i32 = 0 ; pub const _MM_DENORMALS_ZERO_MASK : i32 = 64 ; pub const SDL_CACHELINE_SIZE : i32 = 128 ; pub const SDL_ALPHA_OPAQUE : i32 = 255 ; pub const SDL_ALPHA_TRANSPARENT : i32 = 0 ; pub const SDL_SWSURFACE : i32 = 0 ; pub const SDL_PREALLOC : i32 = 1 ; pub const SDL_RLEACCEL : i32 = 2 ; pub const SDL_DONTFREE : i32 = 4 ; pub const SDL_WINDOWPOS_UNDEFINED_MASK : i32 = 536805376 ; pub const SDL_WINDOWPOS_CENTERED_MASK : i32 = 805240832 ; pub const SDLK_SCANCODE_MASK : i32 = 1073741824 ; pub const SDL_BUTTON_LEFT : i32 = 1 ; pub const SDL_BUTTON_MIDDLE : i32 = 2 ; pub const SDL_BUTTON_RIGHT : i32 = 3 ; pub const SDL_BUTTON_X1 : i32 = 4 ; pub const SDL_BUTTON_X2 : i32 = 5 ; pub const SDL_JOYSTICK_AXIS_MAX : i32 = 32767 ; pub const SDL_JOYSTICK_AXIS_MIN : i32 = -32768 ; pub const SDL_HAT_CENTERED : i32 = 0 ; pub const SDL_HAT_UP : i32 = 1 ; pub const SDL_HAT_RIGHT : i32 = 2 ; pub const SDL_HAT_DOWN : i32 = 4 ; pub const SDL_HAT_LEFT : i32 = 8 ; pub const SDL_HAT_RIGHTUP : i32 = 3 ; pub const SDL_HAT_RIGHTDOWN : i32 = 6 ; pub const SDL_HAT_LEFTUP : i32 = 9 ; pub const SDL_HAT_LEFTDOWN : i32 = 12 ; pub const SDL_RELEASED : i32 = 0 ; pub const SDL_PRESSED : i32 = 1 ; pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE : i32 = 32 ; pub const SDL_TEXTINPUTEVENT_TEXT_SIZE : i32 = 32 ; pub const SDL_QUERY : i32 = -1 ; pub const SDL_IGNORE : i32 = 0 ; pub const SDL_DISABLE : i32 = 0 ; pub const SDL_ENABLE : i32 = 1 ; pub const SDL_HAPTIC_CONSTANT : i32 = 1 ; pub const SDL_HAPTIC_SINE : i32 = 2 ; pub const SDL_HAPTIC_LEFTRIGHT : i32 = 4 ; pub const SDL_HAPTIC_TRIANGLE : i32 = 8 ; pub const SDL_HAPTIC_SAWTOOTHUP : i32 = 16 ; pub const SDL_HAPTIC_SAWTOOTHDOWN : i32 = 32 ; pub const SDL_HAPTIC_RAMP : i32 = 64 ; pub const SDL_HAPTIC_SPRING : i32 = 128 ; pub const SDL_HAPTIC_DAMPER : i32 = 256 ; pub const SDL_HAPTIC_INERTIA : i32 = 512 ; pub const SDL_HAPTIC_FRICTION : i32 = 1024 ; pub const SDL_HAPTIC_CUSTOM : i32 = 2048 ; pub const SDL_HAPTIC_GAIN : i32 = 4096 ; pub const SDL_HAPTIC_AUTOCENTER : i32 = 8192 ; pub const SDL_HAPTIC_STATUS : i32 = 16384 ; pub const SDL_HAPTIC_PAUSE : i32 = 32768 ; pub const SDL_HAPTIC_POLAR : i32 = 0 ; pub const SDL_HAPTIC_CARTESIAN : i32 = 1 ; pub const SDL_HAPTIC_SPHERICAL : i32 = 2 ; pub const SDL_HAPTIC_INFINITY : u32 = 4294967295 ; pub const SDL_HINT_FRAMEBUFFER_ACCELERATION : & 'static [ u8 ; 29usize ] = b"SDL_FRAMEBUFFER_ACCELERATION\0" ; pub const SDL_HINT_RENDER_DRIVER : & 'static [ u8 ; 18usize ] = b"SDL_RENDER_DRIVER\0" ; pub const SDL_HINT_RENDER_OPENGL_SHADERS : & 'static [ u8 ; 26usize ] = b"SDL_RENDER_OPENGL_SHADERS\0" ; pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE : & 'static [ u8 ; 31usize ] = b"SDL_RENDER_DIRECT3D_THREADSAFE\0" ; pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG : & 'static [ u8 ; 28usize ] = b"SDL_RENDER_DIRECT3D11_DEBUG\0" ; pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE : & 'static [ u8 ; 29usize ] = b"SDL_RENDER_LOGICAL_SIZE_MODE\0" ; pub const SDL_HINT_RENDER_SCALE_QUALITY : & 'static [ u8 ; 25usize ] = b"SDL_RENDER_SCALE_QUALITY\0" ; pub const SDL_HINT_RENDER_VSYNC : & 'static [ u8 ; 17usize ] = b"SDL_RENDER_VSYNC\0" ; pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER : & 'static [ u8 ; 28usize ] = b"SDL_VIDEO_ALLOW_SCREENSAVER\0" ; pub const SDL_HINT_VIDEO_X11_XVIDMODE : & 'static [ u8 ; 23usize ] = b"SDL_VIDEO_X11_XVIDMODE\0" ; pub const SDL_HINT_VIDEO_X11_XINERAMA : & 'static [ u8 ; 23usize ] = b"SDL_VIDEO_X11_XINERAMA\0" ; pub const SDL_HINT_VIDEO_X11_XRANDR : & 'static [ u8 ; 21usize ] = b"SDL_VIDEO_X11_XRANDR\0" ; pub const SDL_HINT_VIDEO_X11_NET_WM_PING : & 'static [ u8 ; 26usize ] = b"SDL_VIDEO_X11_NET_WM_PING\0" ; pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR : & 'static [ u8 ; 39usize ] = b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0" ; pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN : & 'static [ u8 ; 44usize ] = b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0" ; pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON : & 'static [ u8 ; 29usize ] = b"SDL_WINDOWS_INTRESOURCE_ICON\0" ; pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL : & 'static [ u8 ; 35usize ] = b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0" ; pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP : & 'static [ u8 ; 31usize ] = b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0" ; pub const SDL_HINT_GRAB_KEYBOARD : & 'static [ u8 ; 18usize ] = b"SDL_GRAB_KEYBOARD\0" ; pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE : & 'static [ u8 ; 29usize ] = b"SDL_MOUSE_NORMAL_SPEED_SCALE\0" ; pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE : & 'static [ u8 ; 31usize ] = b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0" ; pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP : & 'static [ u8 ; 29usize ] = b"SDL_MOUSE_RELATIVE_MODE_WARP\0" ; pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH : & 'static [ u8 ; 29usize ] = b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0" ; pub const SDL_HINT_TOUCH_MOUSE_EVENTS : & 'static [ u8 ; 23usize ] = b"SDL_TOUCH_MOUSE_EVENTS\0" ; pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS : & 'static [ u8 ; 33usize ] = b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0" ; pub const SDL_HINT_IDLE_TIMER_DISABLED : & 'static [ u8 ; 28usize ] = b"SDL_IOS_IDLE_TIMER_DISABLED\0" ; pub const SDL_HINT_ORIENTATIONS : & 'static [ u8 ; 21usize ] = b"SDL_IOS_ORIENTATIONS\0" ; pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS : & 'static [ u8 ; 34usize ] = b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0" ; pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION : & 'static [ u8 ; 35usize ] = b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0" ; pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR : & 'static [ u8 ; 28usize ] = b"SDL_IOS_HIDE_HOME_INDICATOR\0" ; pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK : & 'static [ u8 ; 30usize ] = b"SDL_ACCELEROMETER_AS_JOYSTICK\0" ; pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK : & 'static [ u8 ; 26usize ] = b"SDL_TV_REMOTE_AS_JOYSTICK\0" ; pub const SDL_HINT_XINPUT_ENABLED : & 'static [ u8 ; 19usize ] = b"SDL_XINPUT_ENABLED\0" ; pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING : & 'static [ u8 ; 36usize ] = b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0" ; pub const SDL_HINT_GAMECONTROLLERCONFIG : & 'static [ u8 ; 25usize ] = b"SDL_GAMECONTROLLERCONFIG\0" ; pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES : & 'static [ u8 ; 34usize ] = b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0" ; pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT : & 'static [ u8 ; 41usize ] = b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0" ; pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS : & 'static [ u8 ; 37usize ] = b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0" ; pub const SDL_HINT_ALLOW_TOPMOST : & 'static [ u8 ; 18usize ] = b"SDL_ALLOW_TOPMOST\0" ; pub const SDL_HINT_TIMER_RESOLUTION : & 'static [ u8 ; 21usize ] = b"SDL_TIMER_RESOLUTION\0" ; pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION : & 'static [ u8 ; 34usize ] = b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0" ; pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS : & 'static [ u8 ; 27usize ] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0" ; pub const SDL_HINT_THREAD_STACK_SIZE : & 'static [ u8 ; 22usize ] = b"SDL_THREAD_STACK_SIZE\0" ; pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED : & 'static [ u8 ; 27usize ] = b"SDL_VIDEO_HIGHDPI_DISABLED\0" ; pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK : & 'static [ u8 ; 39usize ] = b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0" ; pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER : & 'static [ u8 ; 26usize ] = b"SDL_VIDEO_WIN_D3DCOMPILER\0" ; pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT : & 'static [ u8 ; 36usize ] = b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0" ; pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL : & 'static [ u8 ; 29usize ] = b"SDL_WINRT_PRIVACY_POLICY_URL\0" ; pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL : & 'static [ u8 ; 31usize ] = b"SDL_WINRT_PRIVACY_POLICY_LABEL\0" ; pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON : & 'static [ u8 ; 29usize ] = b"SDL_WINRT_HANDLE_BACK_BUTTON\0" ; pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES : & 'static [ u8 ; 32usize ] = b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0" ; pub const SDL_HINT_MAC_BACKGROUND_APP : & 'static [ u8 ; 23usize ] = b"SDL_MAC_BACKGROUND_APP\0" ; pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION : & 'static [ u8 ; 44usize ] = b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0" ; pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION : & 'static [ u8 ; 45usize ] = b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0" ; pub const SDL_HINT_IME_INTERNAL_EDITING : & 'static [ u8 ; 25usize ] = b"SDL_IME_INTERNAL_EDITING\0" ; pub const SDL_HINT_ANDROID_SEPARATE_MOUSE_AND_TOUCH : & 'static [ u8 ; 37usize ] = b"SDL_ANDROID_SEPARATE_MOUSE_AND_TOUCH\0" ; pub const SDL_HINT_RETURN_KEY_HIDES_IME : & 'static [ u8 ; 25usize ] = b"SDL_RETURN_KEY_HIDES_IME\0" ; pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT : & 'static [ u8 ; 32usize ] = b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0" ; pub const SDL_HINT_NO_SIGNAL_HANDLERS : & 'static [ u8 ; 23usize ] = b"SDL_NO_SIGNAL_HANDLERS\0" ; pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4 : & 'static [ u8 ; 31usize ] = b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0" ; pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT : & 'static [ u8 ; 27usize ] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0" ; pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING : & 'static [ u8 ; 34usize ] = b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0" ; pub const SDL_HINT_RPI_VIDEO_LAYER : & 'static [ u8 ; 20usize ] = b"SDL_RPI_VIDEO_LAYER\0" ; pub const SDL_HINT_VIDEO_DOUBLE_BUFFER : & 'static [ u8 ; 24usize ] = b"SDL_VIDEO_DOUBLE_BUFFER\0" ; pub const SDL_HINT_OPENGL_ES_DRIVER : & 'static [ u8 ; 21usize ] = b"SDL_OPENGL_ES_DRIVER\0" ; pub const SDL_HINT_AUDIO_RESAMPLING_MODE : & 'static [ u8 ; 26usize ] = b"SDL_AUDIO_RESAMPLING_MODE\0" ; pub const SDL_HINT_AUDIO_CATEGORY : & 'static [ u8 ; 19usize ] = b"SDL_AUDIO_CATEGORY\0" ; pub const SDL_MAX_LOG_MESSAGE : i32 = 4096 ; pub const SDL_NONSHAPEABLE_WINDOW : i32 = -1 ; pub const SDL_INVALID_SHAPE_ARGUMENT : i32 = -2 ; pub const SDL_WINDOW_LACKS_SHAPE : i32 = -3 ; pub const SDL_MAJOR_VERSION : i32 = 2 ; pub const SDL_MINOR_VERSION : i32 = 0 ; pub const SDL_PATCHLEVEL : i32 = 8 ; pub const SDL_INIT_TIMER : i32 = 1 ; pub const SDL_INIT_AUDIO : i32 = 16 ; pub const SDL_INIT_VIDEO : i32 = 32 ; pub const SDL_INIT_JOYSTICK : i32 = 512 ; pub const SDL_INIT_HAPTIC : i32 = 4096 ; pub const SDL_INIT_GAMECONTROLLER : i32 = 8192 ; pub const SDL_INIT_EVENTS : i32 = 16384 ; pub const SDL_INIT_NOPARACHUTE : i32 = 1048576 ; pub const SDL_INIT_EVERYTHING : i32 = 29233 ; extern "C" { 
 /// \brief Gets the name of the platform. 
 pub fn SDL_GetPlatform ( ) -> * const ctypes :: c_char ; } pub type __int8_t = ctypes :: c_schar ; pub type __uint8_t = ctypes :: c_uchar ; pub type __int16_t = ctypes :: c_short ; pub type __uint16_t = ctypes :: c_ushort ; pub type __int32_t = ctypes :: c_int ; pub type __uint32_t = ctypes :: c_uint ; pub type __int64_t = ctypes :: c_long ; pub type __uint64_t = ctypes :: c_ulong ; pub type __int_least8_t = ctypes :: c_schar ; pub type __uint_least8_t = ctypes :: c_uchar ; pub type __int_least16_t = ctypes :: c_short ; pub type __uint_least16_t = ctypes :: c_ushort ; pub type __int_least32_t = ctypes :: c_int ; pub type __uint_least32_t = ctypes :: c_uint ; pub type __int_least64_t = ctypes :: c_long ; pub type __uint_least64_t = ctypes :: c_ulong ; pub type __intmax_t = ctypes :: c_long ; pub type __uintmax_t = ctypes :: c_ulong ; pub type __intptr_t = ctypes :: c_long ; pub type __uintptr_t = ctypes :: c_ulong ; pub type wchar_t = ctypes :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct max_align_t { pub __max_align_ll : ctypes :: c_longlong , pub __bindgen_padding_0 : u64 , pub __max_align_ld : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < max_align_t > ( ) , 16usize , concat ! ( "Alignment of " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < max_align_t > ( ) ) ) . __max_align_ll as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __max_align_ll ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < max_align_t > ( ) ) ) . __max_align_ld as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __max_align_ld ) ) ) ; } pub type _ssize_t = ctypes :: c_long ; pub type u_int8_t = __uint8_t ; pub type u_int16_t = __uint16_t ; pub type u_int32_t = __uint32_t ; pub type u_int64_t = __uint64_t ; pub type register_t = ctypes :: c_int ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub type int_least8_t = __int_least8_t ; pub type uint_least8_t = __uint_least8_t ; pub type int_least16_t = __int_least16_t ; pub type uint_least16_t = __uint_least16_t ; pub type int_least32_t = __int_least32_t ; pub type uint_least32_t = __uint_least32_t ; pub type int_least64_t = __int_least64_t ; pub type uint_least64_t = __uint_least64_t ; pub type int_fast8_t = ctypes :: c_schar ; pub type uint_fast8_t = ctypes :: c_uchar ; pub type int_fast16_t = ctypes :: c_short ; pub type uint_fast16_t = ctypes :: c_ushort ; pub type int_fast32_t = ctypes :: c_int ; pub type uint_fast32_t = ctypes :: c_uint ; pub type int_fast64_t = ctypes :: c_long ; pub type uint_fast64_t = ctypes :: c_ulong ; pub type _LOCK_T = i32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __lock_t { pub lock : _LOCK_T , pub thread_tag : u32 , pub counter : u32 , } # [ test ] fn bindgen_test_layout___lock_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __lock_t > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( __lock_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __lock_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __lock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __lock_t > ( ) ) ) . lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __lock_t ) , "::" , stringify ! ( lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __lock_t > ( ) ) ) . thread_tag as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __lock_t ) , "::" , stringify ! ( thread_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __lock_t > ( ) ) ) . counter as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __lock_t ) , "::" , stringify ! ( counter ) ) ) ; } pub type _LOCK_RECURSIVE_T = __lock_t ; pub type _COND_T = u32 ; extern "C" { pub fn __libc_lock_init ( lock : * mut _LOCK_T ) ; } extern "C" { pub fn __libc_lock_init_recursive ( lock : * mut _LOCK_RECURSIVE_T ) ; } extern "C" { pub fn __libc_lock_close ( lock : * mut _LOCK_T ) ; } extern "C" { pub fn __libc_lock_close_recursive ( lock : * mut _LOCK_RECURSIVE_T ) ; } extern "C" { pub fn __libc_lock_acquire ( lock : * mut _LOCK_T ) ; } extern "C" { pub fn __libc_lock_acquire_recursive ( lock : * mut _LOCK_RECURSIVE_T ) ; } extern "C" { pub fn __libc_lock_release ( lock : * mut _LOCK_T ) ; } extern "C" { pub fn __libc_lock_release_recursive ( lock : * mut _LOCK_RECURSIVE_T ) ; } extern "C" { pub fn __libc_lock_try_acquire ( lock : * mut _LOCK_T ) -> ctypes :: c_int ; } extern "C" { pub fn __libc_lock_try_acquire_recursive ( lock : * mut _LOCK_RECURSIVE_T ) -> ctypes :: c_int ; } extern "C" { pub fn __libc_cond_init ( cond : * mut _COND_T ) -> ctypes :: c_int ; } extern "C" { pub fn __libc_cond_signal ( cond : * mut _COND_T ) -> ctypes :: c_int ; } extern "C" { pub fn __libc_cond_broadcast ( cond : * mut _COND_T ) -> ctypes :: c_int ; } extern "C" { pub fn __libc_cond_wait ( cond : * mut _COND_T , lock : * mut _LOCK_T , timeout_ns : u64 ) -> ctypes :: c_int ; } extern "C" { pub fn __libc_cond_wait_recursive ( cond : * mut _COND_T , lock : * mut _LOCK_RECURSIVE_T , timeout_ns : u64 ) -> ctypes :: c_int ; } pub type __blkcnt_t = ctypes :: c_long ; pub type __blksize_t = ctypes :: c_long ; pub type __fsblkcnt_t = __uint64_t ; pub type __fsfilcnt_t = __uint32_t ; pub type _off_t = ctypes :: c_long ; pub type __pid_t = ctypes :: c_int ; pub type __dev_t = ctypes :: c_short ; pub type __uid_t = ctypes :: c_ushort ; pub type __gid_t = ctypes :: c_ushort ; pub type __id_t = __uint32_t ; pub type __ino_t = ctypes :: c_ushort ; pub type __mode_t = __uint32_t ; pub type _off64_t = ctypes :: c_longlong ; pub type __off_t = _off_t ; pub type __loff_t = _off64_t ; pub type __key_t = ctypes :: c_long ; pub type _fpos_t = ctypes :: c_long ; pub type __size_t = ctypes :: c_ulong ; pub type __ssize_t = _ssize_t ; pub type wint_t = ctypes :: c_uint ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _mbstate_t { pub __count : ctypes :: c_int , pub __value : _mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union _mbstate_t__bindgen_ty_1 { pub __wch : wint_t , pub __wchb : [ ctypes :: c_uchar ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout__mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( _mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _mbstate_t__bindgen_ty_1 > ( ) ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _mbstate_t__bindgen_ty_1 > ( ) ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } # [ test ] fn bindgen_test_layout__mbstate_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( _mbstate_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _mbstate_t > ( ) ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _mbstate_t > ( ) ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( _mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } pub type _flock_t = _LOCK_RECURSIVE_T ; pub type _iconv_t = * mut ctypes :: c_void ; pub type __clock_t = ctypes :: c_ulong ; pub type __time_t = ctypes :: c_long ; pub type __clockid_t = ctypes :: c_ulong ; pub type __timer_t = ctypes :: c_ulong ; pub type __sa_family_t = __uint8_t ; pub type __socklen_t = __uint32_t ; pub type __nl_item = ctypes :: c_int ; pub type __nlink_t = ctypes :: c_ushort ; pub type __suseconds_t = ctypes :: c_long ; pub type __useconds_t = ctypes :: c_ulong ; pub type __va_list = __builtin_va_list ; pub type __sigset_t = ctypes :: c_ulong ; pub type suseconds_t = __suseconds_t ; pub type time_t = ctypes :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : time_t , pub tv_usec : suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: core :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < timeval > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < timeval > ( ) ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : time_t , pub tv_nsec : ctypes :: c_long , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: core :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < timespec > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < timespec > ( ) ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } extern "C" { pub fn timespec2nsec ( ts : * const timespec ) -> __uint64_t ; } extern "C" { pub fn abstimespec2nsec ( clock_id : __clockid_t , ts : * const timespec ) -> __uint64_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } # [ test ] fn bindgen_test_layout_itimerspec ( ) { assert_eq ! ( :: core :: mem :: size_of :: < itimerspec > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( itimerspec ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < itimerspec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( itimerspec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < itimerspec > ( ) ) ) . it_interval as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( itimerspec ) , "::" , stringify ! ( it_interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < itimerspec > ( ) ) ) . it_value as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( itimerspec ) , "::" , stringify ! ( it_value ) ) ) ; } pub type sigset_t = __sigset_t ; pub type fd_mask = ctypes :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _types_fd_set { pub fds_bits : [ fd_mask ; 1usize ] , } # [ test ] fn bindgen_test_layout__types_fd_set ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _types_fd_set > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( _types_fd_set ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _types_fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _types_fd_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _types_fd_set > ( ) ) ) . fds_bits as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _types_fd_set ) , "::" , stringify ! ( fds_bits ) ) ) ; } extern "C" { pub fn select ( __n : ctypes :: c_int , __readfds : * mut _types_fd_set , __writefds : * mut _types_fd_set , __exceptfds : * mut _types_fd_set , __timeout : * mut timeval ) -> ctypes :: c_int ; } extern "C" { pub fn pselect ( __n : ctypes :: c_int , __readfds : * mut _types_fd_set , __writefds : * mut _types_fd_set , __exceptfds : * mut _types_fd_set , __timeout : * const timespec , __set : * const sigset_t ) -> ctypes :: c_int ; } pub type in_addr_t = __uint32_t ; pub type in_port_t = __uint16_t ; pub type u_char = ctypes :: c_uchar ; pub type u_short = ctypes :: c_ushort ; pub type u_int = ctypes :: c_uint ; pub type u_long = ctypes :: c_ulong ; pub type ushort = ctypes :: c_ushort ; pub type uint = ctypes :: c_uint ; pub type ulong = ctypes :: c_ulong ; pub type blkcnt_t = __blkcnt_t ; pub type blksize_t = __blksize_t ; pub type clock_t = ctypes :: c_ulong ; pub type daddr_t = ctypes :: c_long ; pub type caddr_t = * mut ctypes :: c_char ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; pub type id_t = __id_t ; pub type ino_t = __ino_t ; pub type off_t = __off_t ; pub type dev_t = __dev_t ; pub type uid_t = __uid_t ; pub type gid_t = __gid_t ; pub type pid_t = __pid_t ; pub type key_t = __key_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; pub type useconds_t = __useconds_t ; pub type sbintime_t = __int64_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sched_param { pub sched_priority : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_sched_param ( ) { assert_eq ! ( :: core :: mem :: size_of :: < sched_param > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( sched_param ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < sched_param > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sched_param ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < sched_param > ( ) ) ) . sched_priority as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sched_param ) , "::" , stringify ! ( sched_priority ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_t { _unused : [ u8 ; 0 ] , } pub type pthread_t = * mut __pthread_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_attr_t { pub stackaddr : * mut ctypes :: c_void , pub stacksize : ctypes :: c_int , pub schedparam : sched_param , pub detachstate : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_attr_t > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_attr_t > ( ) ) ) . stackaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( stackaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_attr_t > ( ) ) ) . stacksize as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( stacksize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_attr_t > ( ) ) ) . schedparam as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( schedparam ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_attr_t > ( ) ) ) . detachstate as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( detachstate ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct pthread_mutex_t { pub type_ : ctypes :: c_int , pub __bindgen_anon_1 : pthread_mutex_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t__bindgen_ty_1 { pub normal : _LOCK_T , pub recursive : _LOCK_RECURSIVE_T , _bindgen_union_align : [ u32 ; 3usize ] , } # [ test ] fn bindgen_test_layout_pthread_mutex_t__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_mutex_t__bindgen_ty_1 > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_mutex_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_mutex_t__bindgen_ty_1 > ( ) ) ) . normal as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t__bindgen_ty_1 ) , "::" , stringify ! ( normal ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_mutex_t__bindgen_ty_1 > ( ) ) ) . recursive as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t__bindgen_ty_1 ) , "::" , stringify ! ( recursive ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_mutex_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_mutex_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( type_ ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_mutexattr_t { } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 0usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_cond_t { pub clock_id : clockid_t , pub cond : _COND_T , } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_cond_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_cond_t > ( ) ) ) . clock_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( clock_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_cond_t > ( ) ) ) . cond as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( cond ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_condattr_t { pub clock_id : clockid_t , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_condattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_condattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . clock_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( clock_id ) ) ) ; } pub type pthread_key_t = __uint32_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_once_t { pub status : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_pthread_once_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < pthread_once_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_once_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < pthread_once_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_once_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < pthread_once_t > ( ) ) ) . status as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_once_t ) , "::" , stringify ! ( status ) ) ) ; } pub type __gnuc_va_list = __builtin_va_list ; pub type va_list = __gnuc_va_list ; pub type __ULong = ctypes :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_t { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _Bigint { pub _next : * mut _Bigint , pub _k : ctypes :: c_int , pub _maxwds : ctypes :: c_int , pub _sign : ctypes :: c_int , pub _wds : ctypes :: c_int , pub _x : [ __ULong ; 1usize ] , } # [ test ] fn bindgen_test_layout__Bigint ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _Bigint > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _Bigint ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _Bigint > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _Bigint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _Bigint > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _Bigint ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _Bigint > ( ) ) ) . _k as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _Bigint ) , "::" , stringify ! ( _k ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _Bigint > ( ) ) ) . _maxwds as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( _Bigint ) , "::" , stringify ! ( _maxwds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _Bigint > ( ) ) ) . _sign as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _Bigint ) , "::" , stringify ! ( _sign ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _Bigint > ( ) ) ) . _wds as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( _Bigint ) , "::" , stringify ! ( _wds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _Bigint > ( ) ) ) . _x as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _Bigint ) , "::" , stringify ! ( _x ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __tm { pub __tm_sec : ctypes :: c_int , pub __tm_min : ctypes :: c_int , pub __tm_hour : ctypes :: c_int , pub __tm_mday : ctypes :: c_int , pub __tm_mon : ctypes :: c_int , pub __tm_year : ctypes :: c_int , pub __tm_wday : ctypes :: c_int , pub __tm_yday : ctypes :: c_int , pub __tm_isdst : ctypes :: c_int , } # [ test ] fn bindgen_test_layout___tm ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __tm > ( ) , 36usize , concat ! ( "Size of: " , stringify ! ( __tm ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __tm > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __tm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_min as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_hour as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_hour ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_mday as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_mday ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_mon as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_mon ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_year as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_year ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_wday as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_wday ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_yday as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_yday ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __tm > ( ) ) ) . __tm_isdst as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( __tm ) , "::" , stringify ! ( __tm_isdst ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _on_exit_args { pub _fnargs : [ * mut ctypes :: c_void ; 32usize ] , pub _dso_handle : [ * mut ctypes :: c_void ; 32usize ] , pub _fntypes : __ULong , pub _is_cxa : __ULong , } # [ test ] fn bindgen_test_layout__on_exit_args ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _on_exit_args > ( ) , 520usize , concat ! ( "Size of: " , stringify ! ( _on_exit_args ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _on_exit_args > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _on_exit_args ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _on_exit_args > ( ) ) ) . _fnargs as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _on_exit_args ) , "::" , stringify ! ( _fnargs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _on_exit_args > ( ) ) ) . _dso_handle as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( _on_exit_args ) , "::" , stringify ! ( _dso_handle ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _on_exit_args > ( ) ) ) . _fntypes as * const _ as usize } , 512usize , concat ! ( "Offset of field: " , stringify ! ( _on_exit_args ) , "::" , stringify ! ( _fntypes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _on_exit_args > ( ) ) ) . _is_cxa as * const _ as usize } , 516usize , concat ! ( "Offset of field: " , stringify ! ( _on_exit_args ) , "::" , stringify ! ( _is_cxa ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _atexit { pub _next : * mut _atexit , pub _ind : ctypes :: c_int , pub _fns : [ :: core :: option :: Option < unsafe extern "C" fn ( ) > ; 32usize ] , pub _on_exit_args : _on_exit_args , } # [ test ] fn bindgen_test_layout__atexit ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _atexit > ( ) , 792usize , concat ! ( "Size of: " , stringify ! ( _atexit ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _atexit > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _atexit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _atexit > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _atexit ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _atexit > ( ) ) ) . _ind as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _atexit ) , "::" , stringify ! ( _ind ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _atexit > ( ) ) ) . _fns as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _atexit ) , "::" , stringify ! ( _fns ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _atexit > ( ) ) ) . _on_exit_args as * const _ as usize } , 272usize , concat ! ( "Offset of field: " , stringify ! ( _atexit ) , "::" , stringify ! ( _on_exit_args ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sbuf { pub _base : * mut ctypes :: c_uchar , pub _size : ctypes :: c_int , } # [ test ] fn bindgen_test_layout___sbuf ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __sbuf > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __sbuf ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __sbuf > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sbuf > ( ) ) ) . _base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sbuf ) , "::" , stringify ! ( _base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sbuf > ( ) ) ) . _size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __sbuf ) , "::" , stringify ! ( _size ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __sFILE { pub _p : * mut ctypes :: c_uchar , pub _r : ctypes :: c_int , pub _w : ctypes :: c_int , pub _flags : ctypes :: c_short , pub _file : ctypes :: c_short , pub _bf : __sbuf , pub _lbfsize : ctypes :: c_int , pub _cookie : * mut ctypes :: c_void , pub _read : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , arg3 : * mut ctypes :: c_char , arg4 : ctypes :: c_int ) -> ctypes :: c_int > , pub _write : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , arg3 : * const ctypes :: c_char , arg4 : ctypes :: c_int ) -> ctypes :: c_int > , pub _seek : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , arg3 : _fpos_t , arg4 : ctypes :: c_int ) -> _fpos_t > , pub _close : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void ) -> ctypes :: c_int > , pub _ub : __sbuf , pub _up : * mut ctypes :: c_uchar , pub _ur : ctypes :: c_int , pub _ubuf : [ ctypes :: c_uchar ; 3usize ] , pub _nbuf : [ ctypes :: c_uchar ; 1usize ] , pub _lb : __sbuf , pub _blksize : ctypes :: c_int , pub _offset : _off_t , pub _data : * mut _reent , pub _lock : _flock_t , pub _mbstate : _mbstate_t , pub _flags2 : ctypes :: c_int , } # [ test ] fn bindgen_test_layout___sFILE ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __sFILE > ( ) , 184usize , concat ! ( "Size of: " , stringify ! ( __sFILE ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __sFILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sFILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _p as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _p ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _r as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _r ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _w as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _flags as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _file as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _file ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _bf as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _bf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _lbfsize as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lbfsize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _cookie as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _cookie ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _read as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _read ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _write as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _write ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _seek as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _close as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _close ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _ub as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ub ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _up as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _up ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _ur as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ur ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _ubuf as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ubuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _nbuf as * const _ as usize } , 119usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _nbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _lb as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _blksize as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _blksize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _data as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _lock as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _mbstate as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _mbstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __sFILE > ( ) ) ) . _flags2 as * const _ as usize } , 180usize , concat ! ( "Offset of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _flags2 ) ) ) ; } pub type __FILE = __sFILE ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _glue { pub _next : * mut _glue , pub _niobs : ctypes :: c_int , pub _iobs : * mut __FILE , } # [ test ] fn bindgen_test_layout__glue ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _glue > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _glue ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _glue > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _glue ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _glue > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _glue ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _glue > ( ) ) ) . _niobs as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _glue ) , "::" , stringify ! ( _niobs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _glue > ( ) ) ) . _iobs as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _glue ) , "::" , stringify ! ( _iobs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _rand48 { pub _seed : [ ctypes :: c_ushort ; 3usize ] , pub _mult : [ ctypes :: c_ushort ; 3usize ] , pub _add : ctypes :: c_ushort , } # [ test ] fn bindgen_test_layout__rand48 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _rand48 > ( ) , 14usize , concat ! ( "Size of: " , stringify ! ( _rand48 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _rand48 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _rand48 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _rand48 > ( ) ) ) . _seed as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _rand48 ) , "::" , stringify ! ( _seed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _rand48 > ( ) ) ) . _mult as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( _rand48 ) , "::" , stringify ! ( _mult ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _rand48 > ( ) ) ) . _add as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( _rand48 ) , "::" , stringify ! ( _add ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _reent { pub _errno : ctypes :: c_int , pub _stdin : * mut __FILE , pub _stdout : * mut __FILE , pub _stderr : * mut __FILE , pub _inc : ctypes :: c_int , pub _emergency : [ ctypes :: c_char ; 25usize ] , pub _unspecified_locale_info : ctypes :: c_int , pub _locale : * mut __locale_t , pub __sdidinit : ctypes :: c_int , pub __cleanup : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut _reent ) > , pub _result : * mut _Bigint , pub _result_k : ctypes :: c_int , pub _p5s : * mut _Bigint , pub _freelist : * mut * mut _Bigint , pub _cvtlen : ctypes :: c_int , pub _cvtbuf : * mut ctypes :: c_char , pub _new : _reent__bindgen_ty_1 , pub _atexit : * mut _atexit , pub _atexit0 : _atexit , pub _sig_func : * mut :: core :: option :: Option < unsafe extern "C" fn ( arg1 : ctypes :: c_int ) > , pub __sglue : _glue , pub __sf : [ __FILE ; 3usize ] , pub deviceData : * mut ctypes :: c_void , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union _reent__bindgen_ty_1 { pub _reent : _reent__bindgen_ty_1__bindgen_ty_1 , pub _unused : _reent__bindgen_ty_1__bindgen_ty_2 , _bindgen_union_align : [ u64 ; 45usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _reent__bindgen_ty_1__bindgen_ty_1 { pub _unused_rand : ctypes :: c_uint , pub _strtok_last : * mut ctypes :: c_char , pub _asctime_buf : [ ctypes :: c_char ; 26usize ] , pub _localtime_buf : __tm , pub _gamma_signgam : ctypes :: c_int , pub _rand_next : ctypes :: c_ulonglong , pub _r48 : _rand48 , pub _mblen_state : _mbstate_t , pub _mbtowc_state : _mbstate_t , pub _wctomb_state : _mbstate_t , pub _l64a_buf : [ ctypes :: c_char ; 8usize ] , pub _signal_buf : [ ctypes :: c_char ; 24usize ] , pub _getdate_err : ctypes :: c_int , pub _mbrlen_state : _mbstate_t , pub _mbrtowc_state : _mbstate_t , pub _mbsrtowcs_state : _mbstate_t , pub _wcrtomb_state : _mbstate_t , pub _wcsrtombs_state : _mbstate_t , pub _h_errno : ctypes :: c_int , } # [ test ] fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _unused_rand as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _unused_rand ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _strtok_last as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _strtok_last ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _asctime_buf as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _asctime_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _localtime_buf as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _localtime_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _gamma_signgam as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _gamma_signgam ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _rand_next as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _rand_next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _r48 as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _r48 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _mblen_state as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _mblen_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _mbtowc_state as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _mbtowc_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _wctomb_state as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _wctomb_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _l64a_buf as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _l64a_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _signal_buf as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _signal_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _getdate_err as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _getdate_err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _mbrlen_state as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _mbrlen_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _mbrtowc_state as * const _ as usize } , 180usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _mbrtowc_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _mbsrtowcs_state as * const _ as usize } , 188usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _mbsrtowcs_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _wcrtomb_state as * const _ as usize } , 196usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _wcrtomb_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _wcsrtombs_state as * const _ as usize } , 204usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _wcsrtombs_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . _h_errno as * const _ as usize } , 212usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _h_errno ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _reent__bindgen_ty_1__bindgen_ty_2 { pub _nextf : [ * mut ctypes :: c_uchar ; 30usize ] , pub _nmalloc : [ ctypes :: c_uint ; 30usize ] , } # [ test ] fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _reent__bindgen_ty_1__bindgen_ty_2 > ( ) , 360usize , concat ! ( "Size of: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _reent__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . _nextf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( _nextf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . _nmalloc as * const _ as usize } , 240usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( _nmalloc ) ) ) ; } # [ test ] fn bindgen_test_layout__reent__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _reent__bindgen_ty_1 > ( ) , 360usize , concat ! ( "Size of: " , stringify ! ( _reent__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _reent__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _reent__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1 > ( ) ) ) . _reent as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1 ) , "::" , stringify ! ( _reent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent__bindgen_ty_1 > ( ) ) ) . _unused as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _reent__bindgen_ty_1 ) , "::" , stringify ! ( _unused ) ) ) ; } # [ test ] fn bindgen_test_layout__reent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < _reent > ( ) , 1896usize , concat ! ( "Size of: " , stringify ! ( _reent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < _reent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _reent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _errno as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _errno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _stdin as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _stdin ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _stdout as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _stdout ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _stderr as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _stderr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _inc as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _inc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _emergency as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _emergency ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _unspecified_locale_info as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _unspecified_locale_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _locale as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _locale ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . __sdidinit as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( __sdidinit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . __cleanup as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( __cleanup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _result as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _result ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _result_k as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _result_k ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _p5s as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _p5s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _freelist as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _freelist ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _cvtlen as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _cvtlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _cvtbuf as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _cvtbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _new as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _new ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _atexit as * const _ as usize } , 504usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _atexit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _atexit0 as * const _ as usize } , 512usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _atexit0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . _sig_func as * const _ as usize } , 1304usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( _sig_func ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . __sglue as * const _ as usize } , 1312usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( __sglue ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . __sf as * const _ as usize } , 1336usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( __sf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < _reent > ( ) ) ) . deviceData as * const _ as usize } , 1888usize , concat ! ( "Offset of field: " , stringify ! ( _reent ) , "::" , stringify ! ( deviceData ) ) ) ; } extern "C" { pub static mut _impure_ptr : * mut _reent ; } extern "C" { pub static mut _global_impure_ptr : * mut _reent ; } extern "C" { pub fn _reclaim_reent ( arg1 : * mut _reent ) ; } extern "C" { pub fn __getreent ( ) -> * mut _reent ; } pub type FILE = __FILE ; pub type fpos_t = _fpos_t ; extern "C" { pub fn ctermid ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn tempnam ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn fclose ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fflush ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn freopen ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn setbuf ( arg1 : * mut FILE , arg2 : * mut ctypes :: c_char ) ; } extern "C" { pub fn setvbuf ( arg1 : * mut FILE , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int , arg4 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn fprintf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn fscanf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn printf ( arg1 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn scanf ( arg1 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn sscanf ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn vfprintf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vprintf ( arg1 : * const ctypes :: c_char , arg2 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vsprintf ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn fgetc ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fgets ( arg1 : * mut ctypes :: c_char , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> * mut ctypes :: c_char ; } extern "C" { pub fn fputc ( arg1 : ctypes :: c_int , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fputs ( arg1 : * const ctypes :: c_char , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn getc ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn getchar ( ) -> ctypes :: c_int ; } extern "C" { pub fn gets ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn putc ( arg1 : ctypes :: c_int , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn putchar ( arg1 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn puts ( arg1 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn ungetc ( arg1 : ctypes :: c_int , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fread ( arg1 : * mut ctypes :: c_void , _size : usize , _n : usize , arg2 : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( arg1 : * const ctypes :: c_void , _size : usize , _n : usize , arg2 : * mut FILE ) -> usize ; } extern "C" { pub fn fgetpos ( arg1 : * mut FILE , arg2 : * mut fpos_t ) -> ctypes :: c_int ; } extern "C" { pub fn fseek ( arg1 : * mut FILE , arg2 : ctypes :: c_long , arg3 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn fsetpos ( arg1 : * mut FILE , arg2 : * const fpos_t ) -> ctypes :: c_int ; } extern "C" { pub fn ftell ( arg1 : * mut FILE ) -> ctypes :: c_long ; } extern "C" { pub fn rewind ( arg1 : * mut FILE ) ; } extern "C" { pub fn clearerr ( arg1 : * mut FILE ) ; } extern "C" { pub fn feof ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn ferror ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn perror ( arg1 : * const ctypes :: c_char ) ; } extern "C" { pub fn fopen ( _name : * const ctypes :: c_char , _type : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn sprintf ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn remove ( arg1 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn rename ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn fseeko ( arg1 : * mut FILE , arg2 : off_t , arg3 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn ftello ( arg1 : * mut FILE ) -> off_t ; } extern "C" { pub fn snprintf ( arg1 : * mut ctypes :: c_char , arg2 : usize , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn vsnprintf ( arg1 : * mut ctypes :: c_char , arg2 : usize , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vfscanf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vscanf ( arg1 : * const ctypes :: c_char , arg2 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vsscanf ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn asiprintf ( arg1 : * mut * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn asniprintf ( arg1 : * mut ctypes :: c_char , arg2 : * mut usize , arg3 : * const ctypes :: c_char , ... ) -> * mut ctypes :: c_char ; } extern "C" { pub fn asnprintf ( arg1 : * mut ctypes :: c_char , arg2 : * mut usize , arg3 : * const ctypes :: c_char , ... ) -> * mut ctypes :: c_char ; } extern "C" { pub fn diprintf ( arg1 : ctypes :: c_int , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn fiprintf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn fiscanf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn iprintf ( arg1 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn iscanf ( arg1 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn siprintf ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn siscanf ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn sniprintf ( arg1 : * mut ctypes :: c_char , arg2 : usize , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn vasiprintf ( arg1 : * mut * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vasniprintf ( arg1 : * mut ctypes :: c_char , arg2 : * mut usize , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> * mut ctypes :: c_char ; } extern "C" { pub fn vasnprintf ( arg1 : * mut ctypes :: c_char , arg2 : * mut usize , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> * mut ctypes :: c_char ; } extern "C" { pub fn vdiprintf ( arg1 : ctypes :: c_int , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vfiprintf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vfiscanf ( arg1 : * mut FILE , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn viprintf ( arg1 : * const ctypes :: c_char , arg2 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn viscanf ( arg1 : * const ctypes :: c_char , arg2 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vsiprintf ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vsiscanf ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vsniprintf ( arg1 : * mut ctypes :: c_char , arg2 : usize , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn fdopen ( arg1 : ctypes :: c_int , arg2 : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn fileno ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn pclose ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn popen ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn setbuffer ( arg1 : * mut FILE , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) ; } extern "C" { pub fn setlinebuf ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn getw ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn putw ( arg1 : ctypes :: c_int , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn getc_unlocked ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> ctypes :: c_int ; } extern "C" { pub fn flockfile ( arg1 : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn funlockfile ( arg1 : * mut FILE ) ; } extern "C" { pub fn putc_unlocked ( arg1 : ctypes :: c_int , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn putchar_unlocked ( arg1 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn dprintf ( arg1 : ctypes :: c_int , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn fmemopen ( arg1 : * mut ctypes :: c_void , arg2 : usize , arg3 : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( arg1 : * mut * mut ctypes :: c_char , arg2 : * mut usize ) -> * mut FILE ; } extern "C" { pub fn vdprintf ( arg1 : ctypes :: c_int , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn renameat ( arg1 : ctypes :: c_int , arg2 : * const ctypes :: c_char , arg3 : ctypes :: c_int , arg4 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _asiprintf_r ( arg1 : * mut _reent , arg2 : * mut * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _asniprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * mut usize , arg4 : * const ctypes :: c_char , ... ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _asnprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * mut usize , arg4 : * const ctypes :: c_char , ... ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _asprintf_r ( arg1 : * mut _reent , arg2 : * mut * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _diprintf_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _dprintf_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fclose_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fcloseall_r ( arg1 : * mut _reent ) -> ctypes :: c_int ; } extern "C" { pub fn _fdopen_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn _fflush_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fgetc_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fgetc_unlocked_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fgets_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int , arg4 : * mut FILE ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _fgets_unlocked_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int , arg4 : * mut FILE ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _fgetpos_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * mut fpos_t ) -> ctypes :: c_int ; } extern "C" { pub fn _fsetpos_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const fpos_t ) -> ctypes :: c_int ; } extern "C" { pub fn _fiprintf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fiscanf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fmemopen_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , arg3 : usize , arg4 : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn _fopen_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char ) -> * mut FILE ; } extern "C" { pub fn _freopen_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn _fprintf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fpurge_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fputc_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fputc_unlocked_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fputs_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fputs_unlocked_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fread_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , _size : usize , _n : usize , arg3 : * mut FILE ) -> usize ; } extern "C" { pub fn _fread_unlocked_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , _size : usize , _n : usize , arg3 : * mut FILE ) -> usize ; } extern "C" { pub fn _fscanf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fseek_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : ctypes :: c_long , arg4 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _fseeko_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : _off_t , arg4 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _ftell_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_long ; } extern "C" { pub fn _ftello_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> _off_t ; } extern "C" { pub fn _rewind_r ( arg1 : * mut _reent , arg2 : * mut FILE ) ; } extern "C" { pub fn _fwrite_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_void , _size : usize , _n : usize , arg3 : * mut FILE ) -> usize ; } extern "C" { pub fn _fwrite_unlocked_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_void , _size : usize , _n : usize , arg3 : * mut FILE ) -> usize ; } extern "C" { pub fn _getc_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _getc_unlocked_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _getchar_r ( arg1 : * mut _reent ) -> ctypes :: c_int ; } extern "C" { pub fn _getchar_unlocked_r ( arg1 : * mut _reent ) -> ctypes :: c_int ; } extern "C" { pub fn _gets_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _iprintf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _iscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _open_memstream_r ( arg1 : * mut _reent , arg2 : * mut * mut ctypes :: c_char , arg3 : * mut usize ) -> * mut FILE ; } extern "C" { pub fn _perror_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char ) ; } extern "C" { pub fn _printf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _putc_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _putc_unlocked_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _putchar_unlocked_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _putchar_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _puts_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _remove_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _rename_r ( arg1 : * mut _reent , _old : * const ctypes :: c_char , _new : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _scanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _siprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _siscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _sniprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : usize , arg4 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _snprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : usize , arg4 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _sprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _sscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _tempnam_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _tmpfile_r ( arg1 : * mut _reent ) -> * mut FILE ; } extern "C" { pub fn _tmpnam_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _ungetc_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _vasiprintf_r ( arg1 : * mut _reent , arg2 : * mut * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vasniprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * mut usize , arg4 : * const ctypes :: c_char , arg5 : * mut __va_list_tag ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _vasnprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * mut usize , arg4 : * const ctypes :: c_char , arg5 : * mut __va_list_tag ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _vasprintf_r ( arg1 : * mut _reent , arg2 : * mut * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vdiprintf_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vdprintf_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vfiprintf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vfiscanf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vfprintf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vfscanf_r ( arg1 : * mut _reent , arg2 : * mut FILE , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _viprintf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _viscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vprintf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vsiprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vsiscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vsniprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : usize , arg4 : * const ctypes :: c_char , arg5 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vsnprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : usize , arg4 : * const ctypes :: c_char , arg5 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vsprintf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vsscanf_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn fpurge ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn __getdelim ( arg1 : * mut * mut ctypes :: c_char , arg2 : * mut usize , arg3 : ctypes :: c_int , arg4 : * mut FILE ) -> isize ; } extern "C" { pub fn __getline ( arg1 : * mut * mut ctypes :: c_char , arg2 : * mut usize , arg3 : * mut FILE ) -> isize ; } extern "C" { pub fn clearerr_unlocked ( arg1 : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn ferror_unlocked ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fileno_unlocked ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fflush_unlocked ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fgetc_unlocked ( arg1 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fputc_unlocked ( arg1 : ctypes :: c_int , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fread_unlocked ( arg1 : * mut ctypes :: c_void , _size : usize , _n : usize , arg2 : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( arg1 : * const ctypes :: c_void , _size : usize , _n : usize , arg2 : * mut FILE ) -> usize ; } extern "C" { pub fn __srget_r ( arg1 : * mut _reent , arg2 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn __swbuf_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : * mut FILE ) -> ctypes :: c_int ; } extern "C" { pub fn funopen ( __cookie : * const ctypes :: c_void , __readfn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void , __buf : * mut ctypes :: c_char , __n : ctypes :: c_int ) -> ctypes :: c_int > , __writefn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void , __buf : * const ctypes :: c_char , __n : ctypes :: c_int ) -> ctypes :: c_int > , __seekfn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void , __off : fpos_t , __whence : ctypes :: c_int ) -> fpos_t > , __closefn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void ) -> ctypes :: c_int > ) -> * mut FILE ; } extern "C" { pub fn _funopen_r ( arg1 : * mut _reent , __cookie : * const ctypes :: c_void , __readfn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void , __buf : * mut ctypes :: c_char , __n : ctypes :: c_int ) -> ctypes :: c_int > , __writefn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void , __buf : * const ctypes :: c_char , __n : ctypes :: c_int ) -> ctypes :: c_int > , __seekfn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void , __off : fpos_t , __whence : ctypes :: c_int ) -> fpos_t > , __closefn : :: core :: option :: Option < unsafe extern "C" fn ( __cookie : * mut ctypes :: c_void ) -> ctypes :: c_int > ) -> * mut FILE ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct div_t { pub quot : ctypes :: c_int , pub rem : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < div_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < div_t > ( ) ) ) . rem as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ldiv_t { pub quot : ctypes :: c_long , pub rem : ctypes :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct lldiv_t { pub quot : ctypes :: c_longlong , pub rem : ctypes :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < lldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < lldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } pub type __compar_fn_t = :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * const ctypes :: c_void , arg2 : * const ctypes :: c_void ) -> ctypes :: c_int > ; extern "C" { pub fn __locale_mb_cur_max ( ) -> ctypes :: c_int ; } extern "C" { pub fn abort ( ) ; } extern "C" { pub fn abs ( arg1 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn arc4random ( ) -> __uint32_t ; } extern "C" { pub fn arc4random_uniform ( arg1 : __uint32_t ) -> __uint32_t ; } extern "C" { pub fn arc4random_buf ( arg1 : * mut ctypes :: c_void , arg2 : usize ) ; } extern "C" { pub fn atexit ( __func : :: core :: option :: Option < unsafe extern "C" fn ( ) > ) -> ctypes :: c_int ; } extern "C" { pub fn atof ( __nptr : * const ctypes :: c_char ) -> f64 ; } extern "C" { pub fn atoff ( __nptr : * const ctypes :: c_char ) -> f32 ; } extern "C" { pub fn atoi ( __nptr : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _atoi_r ( arg1 : * mut _reent , __nptr : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn atol ( __nptr : * const ctypes :: c_char ) -> ctypes :: c_long ; } extern "C" { pub fn _atol_r ( arg1 : * mut _reent , __nptr : * const ctypes :: c_char ) -> ctypes :: c_long ; } extern "C" { pub fn bsearch ( __key : * const ctypes :: c_void , __base : * const ctypes :: c_void , __nmemb : usize , __size : usize , _compar : __compar_fn_t ) -> * mut ctypes :: c_void ; } extern "C" { pub fn calloc ( arg1 : usize , arg2 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn div ( __numer : ctypes :: c_int , __denom : ctypes :: c_int ) -> div_t ; } extern "C" { pub fn exit ( __status : ctypes :: c_int ) ; } extern "C" { pub fn free ( arg1 : * mut ctypes :: c_void ) ; } extern "C" { pub fn getenv ( __string : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _getenv_r ( arg1 : * mut _reent , __string : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _findenv ( arg1 : * const ctypes :: c_char , arg2 : * mut ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _findenv_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub static mut suboptarg : * mut ctypes :: c_char ; } extern "C" { pub fn getsubopt ( arg1 : * mut * mut ctypes :: c_char , arg2 : * const * mut ctypes :: c_char , arg3 : * mut * mut ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn labs ( arg1 : ctypes :: c_long ) -> ctypes :: c_long ; } extern "C" { pub fn ldiv ( __numer : ctypes :: c_long , __denom : ctypes :: c_long ) -> ldiv_t ; } extern "C" { pub fn malloc ( arg1 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn mblen ( arg1 : * const ctypes :: c_char , arg2 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn _mblen_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : usize , arg4 : * mut _mbstate_t ) -> ctypes :: c_int ; } extern "C" { pub fn mbtowc ( arg1 : * mut wchar_t , arg2 : * const ctypes :: c_char , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn _mbtowc_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : * const ctypes :: c_char , arg4 : usize , arg5 : * mut _mbstate_t ) -> ctypes :: c_int ; } extern "C" { pub fn wctomb ( arg1 : * mut ctypes :: c_char , arg2 : wchar_t ) -> ctypes :: c_int ; } extern "C" { pub fn _wctomb_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : wchar_t , arg4 : * mut _mbstate_t ) -> ctypes :: c_int ; } extern "C" { pub fn mbstowcs ( arg1 : * mut wchar_t , arg2 : * const ctypes :: c_char , arg3 : usize ) -> usize ; } extern "C" { pub fn _mbstowcs_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : * const ctypes :: c_char , arg4 : usize , arg5 : * mut _mbstate_t ) -> usize ; } extern "C" { pub fn wcstombs ( arg1 : * mut ctypes :: c_char , arg2 : * const wchar_t , arg3 : usize ) -> usize ; } extern "C" { pub fn _wcstombs_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * const wchar_t , arg4 : usize , arg5 : * mut _mbstate_t ) -> usize ; } extern "C" { pub fn mkdtemp ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn mkstemp ( arg1 : * mut ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn mkstemps ( arg1 : * mut ctypes :: c_char , arg2 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn mktemp ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _mkdtemp_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _mkostemp_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _mkostemps_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int , arg4 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _mkstemp_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _mkstemps_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _mktemp_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn qsort ( __base : * mut ctypes :: c_void , __nmemb : usize , __size : usize , _compar : __compar_fn_t ) ; } extern "C" { pub fn rand ( ) -> ctypes :: c_int ; } extern "C" { pub fn realloc ( arg1 : * mut ctypes :: c_void , arg2 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn reallocarray ( arg1 : * mut ctypes :: c_void , arg2 : usize , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn reallocf ( arg1 : * mut ctypes :: c_void , arg2 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn realpath ( path : * const ctypes :: c_char , resolved_path : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn rpmatch ( response : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn srand ( __seed : ctypes :: c_uint ) ; } extern "C" { pub fn strtod ( __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char ) -> f64 ; } extern "C" { pub fn _strtod_r ( arg1 : * mut _reent , __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char ) -> f64 ; } extern "C" { pub fn strtof ( __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char ) -> f32 ; } extern "C" { pub fn strtol ( __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_long ; } extern "C" { pub fn _strtol_r ( arg1 : * mut _reent , __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_long ; } extern "C" { pub fn strtoul ( __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_ulong ; } extern "C" { pub fn _strtoul_r ( arg1 : * mut _reent , __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_ulong ; } extern "C" { pub fn system ( __string : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn a64l ( __input : * const ctypes :: c_char ) -> ctypes :: c_long ; } extern "C" { pub fn l64a ( __input : ctypes :: c_long ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _l64a_r ( arg1 : * mut _reent , __input : ctypes :: c_long ) -> * mut ctypes :: c_char ; } extern "C" { pub fn on_exit ( __func : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : ctypes :: c_int , arg2 : * mut ctypes :: c_void ) > , __arg : * mut ctypes :: c_void ) -> ctypes :: c_int ; } extern "C" { pub fn _Exit ( __status : ctypes :: c_int ) ; } extern "C" { pub fn putenv ( __string : * mut ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _putenv_r ( arg1 : * mut _reent , __string : * mut ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _reallocf_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn setenv ( __string : * const ctypes :: c_char , __value : * const ctypes :: c_char , __overwrite : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _setenv_r ( arg1 : * mut _reent , __string : * const ctypes :: c_char , __value : * const ctypes :: c_char , __overwrite : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn __itoa ( arg1 : ctypes :: c_int , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn __utoa ( arg1 : ctypes :: c_uint , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn itoa ( arg1 : ctypes :: c_int , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn utoa ( arg1 : ctypes :: c_uint , arg2 : * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn rand_r ( __seed : * mut ctypes :: c_uint ) -> ctypes :: c_int ; } extern "C" { pub fn drand48 ( ) -> f64 ; } extern "C" { pub fn _drand48_r ( arg1 : * mut _reent ) -> f64 ; } extern "C" { pub fn erand48 ( arg1 : * mut ctypes :: c_ushort ) -> f64 ; } extern "C" { pub fn _erand48_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_ushort ) -> f64 ; } extern "C" { pub fn jrand48 ( arg1 : * mut ctypes :: c_ushort ) -> ctypes :: c_long ; } extern "C" { pub fn _jrand48_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_ushort ) -> ctypes :: c_long ; } extern "C" { pub fn lcong48 ( arg1 : * mut ctypes :: c_ushort ) ; } extern "C" { pub fn _lcong48_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_ushort ) ; } extern "C" { pub fn lrand48 ( ) -> ctypes :: c_long ; } extern "C" { pub fn _lrand48_r ( arg1 : * mut _reent ) -> ctypes :: c_long ; } extern "C" { pub fn mrand48 ( ) -> ctypes :: c_long ; } extern "C" { pub fn _mrand48_r ( arg1 : * mut _reent ) -> ctypes :: c_long ; } extern "C" { pub fn nrand48 ( arg1 : * mut ctypes :: c_ushort ) -> ctypes :: c_long ; } extern "C" { pub fn _nrand48_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_ushort ) -> ctypes :: c_long ; } extern "C" { pub fn seed48 ( arg1 : * mut ctypes :: c_ushort ) -> * mut ctypes :: c_ushort ; } extern "C" { pub fn _seed48_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_ushort ) -> * mut ctypes :: c_ushort ; } extern "C" { pub fn srand48 ( arg1 : ctypes :: c_long ) ; } extern "C" { pub fn _srand48_r ( arg1 : * mut _reent , arg2 : ctypes :: c_long ) ; } extern "C" { pub fn initstate ( arg1 : ctypes :: c_uint , arg2 : * mut ctypes :: c_char , arg3 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn random ( ) -> ctypes :: c_long ; } extern "C" { pub fn setstate ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn srandom ( arg1 : ctypes :: c_uint ) ; } extern "C" { pub fn atoll ( __nptr : * const ctypes :: c_char ) -> ctypes :: c_longlong ; } extern "C" { pub fn _atoll_r ( arg1 : * mut _reent , __nptr : * const ctypes :: c_char ) -> ctypes :: c_longlong ; } extern "C" { pub fn llabs ( arg1 : ctypes :: c_longlong ) -> ctypes :: c_longlong ; } extern "C" { pub fn lldiv ( __numer : ctypes :: c_longlong , __denom : ctypes :: c_longlong ) -> lldiv_t ; } extern "C" { pub fn strtoll ( __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_longlong ; } extern "C" { pub fn _strtoll_r ( arg1 : * mut _reent , __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_longlong ; } extern "C" { pub fn strtoull ( __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_ulonglong ; } extern "C" { pub fn _strtoull_r ( arg1 : * mut _reent , __n : * const ctypes :: c_char , __end_PTR : * mut * mut ctypes :: c_char , __base : ctypes :: c_int ) -> ctypes :: c_ulonglong ; } extern "C" { pub fn cfree ( arg1 : * mut ctypes :: c_void ) ; } extern "C" { pub fn unsetenv ( __string : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn _unsetenv_r ( arg1 : * mut _reent , __string : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn posix_memalign ( arg1 : * mut * mut ctypes :: c_void , arg2 : usize , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn _dtoa_r ( arg1 : * mut _reent , arg2 : f64 , arg3 : ctypes :: c_int , arg4 : ctypes :: c_int , arg5 : * mut ctypes :: c_int , arg6 : * mut ctypes :: c_int , arg7 : * mut * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _malloc_r ( arg1 : * mut _reent , arg2 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn _calloc_r ( arg1 : * mut _reent , arg2 : usize , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn _free_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void ) ; } extern "C" { pub fn _realloc_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_void , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn _mstats_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char ) ; } extern "C" { pub fn _system_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn __eprintf ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : ctypes :: c_uint , arg4 : * const ctypes :: c_char ) ; } extern "C" { pub fn qsort_r ( __base : * mut ctypes :: c_void , __nmemb : usize , __size : usize , __thunk : * mut ctypes :: c_void , _compar : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : * const ctypes :: c_void ) -> ctypes :: c_int > ) ; } extern "C" { pub fn _strtold_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut * mut ctypes :: c_char ) -> f64 ; } extern "C" { pub fn strtold ( arg1 : * const ctypes :: c_char , arg2 : * mut * mut ctypes :: c_char ) -> f64 ; } extern "C" { pub fn aligned_alloc ( arg1 : usize , arg2 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn at_quick_exit ( arg1 : :: core :: option :: Option < unsafe extern "C" fn ( ) > ) -> ctypes :: c_int ; } extern "C" { pub fn quick_exit ( arg1 : ctypes :: c_int ) ; } pub type locale_t = * mut __locale_t ; extern "C" { pub fn bcmp ( arg1 : * const ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn bcopy ( arg1 : * const ctypes :: c_void , arg2 : * mut ctypes :: c_void , arg3 : usize ) ; } extern "C" { pub fn bzero ( arg1 : * mut ctypes :: c_void , arg2 : usize ) ; } extern "C" { pub fn explicit_bzero ( arg1 : * mut ctypes :: c_void , arg2 : usize ) ; } extern "C" { pub fn ffs ( arg1 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn ffsl ( arg1 : ctypes :: c_long ) -> ctypes :: c_int ; } extern "C" { pub fn ffsll ( arg1 : ctypes :: c_longlong ) -> ctypes :: c_int ; } extern "C" { pub fn fls ( arg1 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn flsl ( arg1 : ctypes :: c_long ) -> ctypes :: c_int ; } extern "C" { pub fn flsll ( arg1 : ctypes :: c_longlong ) -> ctypes :: c_int ; } extern "C" { pub fn index ( arg1 : * const ctypes :: c_char , arg2 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn rindex ( arg1 : * const ctypes :: c_char , arg2 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strcasecmp ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn strncasecmp ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn strcasecmp_l ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn strncasecmp_l ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize , arg4 : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn memchr ( arg1 : * const ctypes :: c_void , arg2 : ctypes :: c_int , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn memcmp ( arg1 : * const ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn memcpy ( arg1 : * mut ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn memmove ( arg1 : * mut ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn memset ( arg1 : * mut ctypes :: c_void , arg2 : ctypes :: c_int , arg3 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn strcat ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strchr ( arg1 : * const ctypes :: c_char , arg2 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strcmp ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn strcoll ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn strcpy ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strcspn ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> ctypes :: c_ulong ; } extern "C" { pub fn strerror ( arg1 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strlen ( arg1 : * const ctypes :: c_char ) -> ctypes :: c_ulong ; } extern "C" { pub fn strncat ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strncmp ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn strncpy ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strpbrk ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strrchr ( arg1 : * const ctypes :: c_char , arg2 : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strspn ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> ctypes :: c_ulong ; } extern "C" { pub fn strstr ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strtok ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strxfrm ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> ctypes :: c_ulong ; } extern "C" { pub fn strcoll_l ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn strerror_l ( arg1 : ctypes :: c_int , arg2 : locale_t ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strxfrm_l ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize , arg4 : locale_t ) -> usize ; } extern "C" { pub fn strtok_r ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : * mut * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn timingsafe_bcmp ( arg1 : * const ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn timingsafe_memcmp ( arg1 : * const ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn memccpy ( arg1 : * mut ctypes :: c_void , arg2 : * const ctypes :: c_void , arg3 : ctypes :: c_int , arg4 : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn stpcpy ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn stpncpy ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strdup ( arg1 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _strdup_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strndup ( arg1 : * const ctypes :: c_char , arg2 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn _strndup_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strerror_r ( arg1 : ctypes :: c_int , arg2 : * mut ctypes :: c_char , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn _strerror_r ( arg1 : * mut _reent , arg2 : ctypes :: c_int , arg3 : ctypes :: c_int , arg4 : * mut ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strlcat ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> usize ; } extern "C" { pub fn strlcpy ( arg1 : * mut ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> usize ; } extern "C" { pub fn strnlen ( arg1 : * const ctypes :: c_char , arg2 : usize ) -> usize ; } extern "C" { pub fn strsep ( arg1 : * mut * mut ctypes :: c_char , arg2 : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strnstr ( arg1 : * const ctypes :: c_char , arg2 : * const ctypes :: c_char , arg3 : usize ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strlwr ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strupr ( arg1 : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn strsignal ( __signo : ctypes :: c_int ) -> * mut ctypes :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tm { _unused : [ u8 ; 0 ] , } pub type mbstate_t = _mbstate_t ; extern "C" { pub fn btowc ( arg1 : ctypes :: c_int ) -> wint_t ; } extern "C" { pub fn wctob ( arg1 : wint_t ) -> ctypes :: c_int ; } extern "C" { pub fn mbrlen ( arg1 : * const ctypes :: c_char , arg2 : usize , arg3 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn mbrtowc ( arg1 : * mut wchar_t , arg2 : * const ctypes :: c_char , arg3 : usize , arg4 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn _mbrtowc_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : * const ctypes :: c_char , arg4 : usize , arg5 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn mbsinit ( arg1 : * const mbstate_t ) -> ctypes :: c_int ; } extern "C" { pub fn mbsnrtowcs ( arg1 : * mut wchar_t , arg2 : * mut * const ctypes :: c_char , arg3 : usize , arg4 : usize , arg5 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn _mbsnrtowcs_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : * mut * const ctypes :: c_char , arg4 : usize , arg5 : usize , arg6 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn mbsrtowcs ( arg1 : * mut wchar_t , arg2 : * mut * const ctypes :: c_char , arg3 : usize , arg4 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn _mbsrtowcs_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : * mut * const ctypes :: c_char , arg4 : usize , arg5 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn wcrtomb ( arg1 : * mut ctypes :: c_char , arg2 : wchar_t , arg3 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn _wcrtomb_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : wchar_t , arg4 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn wcsnrtombs ( arg1 : * mut ctypes :: c_char , arg2 : * mut * const wchar_t , arg3 : usize , arg4 : usize , arg5 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn _wcsnrtombs_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * mut * const wchar_t , arg4 : usize , arg5 : usize , arg6 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn wcsrtombs ( arg1 : * mut ctypes :: c_char , arg2 : * mut * const wchar_t , arg3 : usize , arg4 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn _wcsrtombs_r ( arg1 : * mut _reent , arg2 : * mut ctypes :: c_char , arg3 : * mut * const wchar_t , arg4 : usize , arg5 : * mut mbstate_t ) -> usize ; } extern "C" { pub fn wcscasecmp ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> ctypes :: c_int ; } extern "C" { pub fn wcscat ( arg1 : * mut wchar_t , arg2 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcschr ( arg1 : * const wchar_t , arg2 : wchar_t ) -> * mut ctypes :: c_int ; } extern "C" { pub fn wcscmp ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> ctypes :: c_int ; } extern "C" { pub fn wcscoll ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> ctypes :: c_int ; } extern "C" { pub fn wcscpy ( arg1 : * mut wchar_t , arg2 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcpcpy ( arg1 : * mut wchar_t , arg2 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsdup ( arg1 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn _wcsdup_r ( arg1 : * mut _reent , arg2 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcscspn ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> usize ; } extern "C" { pub fn wcsftime ( arg1 : * mut wchar_t , arg2 : usize , arg3 : * const wchar_t , arg4 : * const tm ) -> usize ; } extern "C" { pub fn wcslcat ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> usize ; } extern "C" { pub fn wcslcpy ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> usize ; } extern "C" { pub fn wcslen ( arg1 : * const wchar_t ) -> ctypes :: c_ulong ; } extern "C" { pub fn wcsncasecmp ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn wcsncat ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcsncmp ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn wcsncpy ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcpncpy ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcsnlen ( arg1 : * const wchar_t , arg2 : usize ) -> usize ; } extern "C" { pub fn wcspbrk ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsrchr ( arg1 : * const wchar_t , arg2 : wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcsspn ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> usize ; } extern "C" { pub fn wcsstr ( arg1 : * const wchar_t , arg2 : * const wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcstok ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t ) -> * mut wchar_t ; } extern "C" { pub fn wcstod ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t ) -> f64 ; } extern "C" { pub fn _wcstod_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t ) -> f64 ; } extern "C" { pub fn wcstof ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t ) -> f32 ; } extern "C" { pub fn _wcstof_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t ) -> f32 ; } extern "C" { pub fn wcsxfrm ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> usize ; } extern "C" { pub fn wcscasecmp_l ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn wcsncasecmp_l ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : usize , arg4 : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn wcscoll_l ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn wcsxfrm_l ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize , arg4 : locale_t ) -> usize ; } extern "C" { pub fn wmemchr ( arg1 : * const wchar_t , arg2 : wchar_t , arg3 : usize ) -> * mut ctypes :: c_int ; } extern "C" { pub fn wmemcmp ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> ctypes :: c_int ; } extern "C" { pub fn wmemcpy ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> * mut wchar_t ; } extern "C" { pub fn wmemmove ( arg1 : * mut wchar_t , arg2 : * const wchar_t , arg3 : usize ) -> * mut wchar_t ; } extern "C" { pub fn wmemset ( arg1 : * mut wchar_t , arg2 : wchar_t , arg3 : usize ) -> * mut wchar_t ; } extern "C" { pub fn wcstol ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t , arg3 : ctypes :: c_int ) -> ctypes :: c_long ; } extern "C" { pub fn wcstoll ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t , arg3 : ctypes :: c_int ) -> ctypes :: c_longlong ; } extern "C" { pub fn wcstoul ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t , arg3 : ctypes :: c_int ) -> ctypes :: c_ulong ; } extern "C" { pub fn wcstoull ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t , arg3 : ctypes :: c_int ) -> ctypes :: c_ulonglong ; } extern "C" { pub fn _wcstol_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t , arg4 : ctypes :: c_int ) -> ctypes :: c_long ; } extern "C" { pub fn _wcstoll_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t , arg4 : ctypes :: c_int ) -> ctypes :: c_longlong ; } extern "C" { pub fn _wcstoul_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t , arg4 : ctypes :: c_int ) -> ctypes :: c_ulong ; } extern "C" { pub fn _wcstoull_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t , arg4 : ctypes :: c_int ) -> ctypes :: c_ulonglong ; } extern "C" { pub fn wcstold ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t ) -> f64 ; } extern "C" { pub fn fgetwc ( arg1 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn fgetws ( arg1 : * mut wchar_t , arg2 : ctypes :: c_int , arg3 : * mut __FILE ) -> * mut wchar_t ; } extern "C" { pub fn fputwc ( arg1 : wchar_t , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn fputws ( arg1 : * const wchar_t , arg2 : * mut __FILE ) -> ctypes :: c_int ; } extern "C" { pub fn fwide ( arg1 : * mut __FILE , arg2 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn getwc ( arg1 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn getwchar ( ) -> wint_t ; } extern "C" { pub fn putwc ( arg1 : wchar_t , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn putwchar ( arg1 : wchar_t ) -> wint_t ; } extern "C" { pub fn ungetwc ( wc : wint_t , arg1 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _fgetwc_r ( arg1 : * mut _reent , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _fgetwc_unlocked_r ( arg1 : * mut _reent , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _fgetws_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : ctypes :: c_int , arg4 : * mut __FILE ) -> * mut wchar_t ; } extern "C" { pub fn _fgetws_unlocked_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : ctypes :: c_int , arg4 : * mut __FILE ) -> * mut wchar_t ; } extern "C" { pub fn _fputwc_r ( arg1 : * mut _reent , arg2 : wchar_t , arg3 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _fputwc_unlocked_r ( arg1 : * mut _reent , arg2 : wchar_t , arg3 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _fputws_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut __FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fputws_unlocked_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut __FILE ) -> ctypes :: c_int ; } extern "C" { pub fn _fwide_r ( arg1 : * mut _reent , arg2 : * mut __FILE , arg3 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn _getwc_r ( arg1 : * mut _reent , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _getwc_unlocked_r ( arg1 : * mut _reent , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _getwchar_r ( ptr : * mut _reent ) -> wint_t ; } extern "C" { pub fn _getwchar_unlocked_r ( ptr : * mut _reent ) -> wint_t ; } extern "C" { pub fn _putwc_r ( arg1 : * mut _reent , arg2 : wchar_t , arg3 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _putwc_unlocked_r ( arg1 : * mut _reent , arg2 : wchar_t , arg3 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn _putwchar_r ( arg1 : * mut _reent , arg2 : wchar_t ) -> wint_t ; } extern "C" { pub fn _putwchar_unlocked_r ( arg1 : * mut _reent , arg2 : wchar_t ) -> wint_t ; } extern "C" { pub fn _ungetwc_r ( arg1 : * mut _reent , wc : wint_t , arg2 : * mut __FILE ) -> wint_t ; } extern "C" { pub fn open_wmemstream ( arg1 : * mut * mut wchar_t , arg2 : * mut usize ) -> * mut __FILE ; } extern "C" { pub fn _open_wmemstream_r ( arg1 : * mut _reent , arg2 : * mut * mut wchar_t , arg3 : * mut usize ) -> * mut __FILE ; } extern "C" { pub fn fwprintf ( arg1 : * mut __FILE , arg2 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn swprintf ( arg1 : * mut wchar_t , arg2 : usize , arg3 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn vfwprintf ( arg1 : * mut __FILE , arg2 : * const wchar_t , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vswprintf ( arg1 : * mut wchar_t , arg2 : usize , arg3 : * const wchar_t , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vwprintf ( arg1 : * const wchar_t , arg2 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn wprintf ( arg1 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fwprintf_r ( arg1 : * mut _reent , arg2 : * mut __FILE , arg3 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _swprintf_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : usize , arg4 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _vfwprintf_r ( arg1 : * mut _reent , arg2 : * mut __FILE , arg3 : * const wchar_t , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vswprintf_r ( arg1 : * mut _reent , arg2 : * mut wchar_t , arg3 : usize , arg4 : * const wchar_t , arg5 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vwprintf_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _wprintf_r ( arg1 : * mut _reent , arg2 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn fwscanf ( arg1 : * mut __FILE , arg2 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn swscanf ( arg1 : * const wchar_t , arg2 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn vfwscanf ( arg1 : * mut __FILE , arg2 : * const wchar_t , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vswscanf ( arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn vwscanf ( arg1 : * const wchar_t , arg2 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn wscanf ( arg1 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _fwscanf_r ( arg1 : * mut _reent , arg2 : * mut __FILE , arg3 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _swscanf_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * const wchar_t , ... ) -> ctypes :: c_int ; } extern "C" { pub fn _vfwscanf_r ( arg1 : * mut _reent , arg2 : * mut __FILE , arg3 : * const wchar_t , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vswscanf_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * const wchar_t , arg4 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _vwscanf_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn _wscanf_r ( arg1 : * mut _reent , arg2 : * const wchar_t , ... ) -> ctypes :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : intmax_t , pub rem : intmax_t , } # [ test ] fn bindgen_test_layout_imaxdiv_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < imaxdiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < imaxdiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < imaxdiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < imaxdiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( rem ) ) ) ; } extern "C" { pub fn imaxabs ( j : intmax_t ) -> intmax_t ; } extern "C" { pub fn imaxdiv ( numer : intmax_t , denomer : intmax_t ) -> imaxdiv_t ; } extern "C" { pub fn strtoimax ( arg1 : * const ctypes :: c_char , arg2 : * mut * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> intmax_t ; } extern "C" { pub fn _strtoimax_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut * mut ctypes :: c_char , arg4 : ctypes :: c_int ) -> intmax_t ; } extern "C" { pub fn strtoumax ( arg1 : * const ctypes :: c_char , arg2 : * mut * mut ctypes :: c_char , arg3 : ctypes :: c_int ) -> uintmax_t ; } extern "C" { pub fn _strtoumax_r ( arg1 : * mut _reent , arg2 : * const ctypes :: c_char , arg3 : * mut * mut ctypes :: c_char , arg4 : ctypes :: c_int ) -> uintmax_t ; } extern "C" { pub fn wcstoimax ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t , arg3 : ctypes :: c_int ) -> intmax_t ; } extern "C" { pub fn _wcstoimax_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t , arg4 : ctypes :: c_int ) -> intmax_t ; } extern "C" { pub fn wcstoumax ( arg1 : * const wchar_t , arg2 : * mut * mut wchar_t , arg3 : ctypes :: c_int ) -> uintmax_t ; } extern "C" { pub fn _wcstoumax_r ( arg1 : * mut _reent , arg2 : * const wchar_t , arg3 : * mut * mut wchar_t , arg4 : ctypes :: c_int ) -> uintmax_t ; } extern "C" { pub fn strtoimax_l ( arg1 : * const ctypes :: c_char , _restrict : * mut * mut ctypes :: c_char , arg2 : ctypes :: c_int , arg3 : locale_t ) -> intmax_t ; } extern "C" { pub fn strtoumax_l ( arg1 : * const ctypes :: c_char , _restrict : * mut * mut ctypes :: c_char , arg2 : ctypes :: c_int , arg3 : locale_t ) -> uintmax_t ; } extern "C" { pub fn wcstoimax_l ( arg1 : * const wchar_t , _restrict : * mut * mut wchar_t , arg2 : ctypes :: c_int , arg3 : locale_t ) -> intmax_t ; } extern "C" { pub fn wcstoumax_l ( arg1 : * const wchar_t , _restrict : * mut * mut wchar_t , arg2 : ctypes :: c_int , arg3 : locale_t ) -> uintmax_t ; } extern "C" { pub fn isalnum ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isalpha ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn iscntrl ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isdigit ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isgraph ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn islower ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isprint ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn ispunct ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isspace ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isupper ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isxdigit ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn tolower ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn toupper ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isblank ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isascii ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn toascii ( __c : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn isalnum_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isalpha_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isblank_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn iscntrl_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isdigit_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isgraph_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn islower_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isprint_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn ispunct_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isspace_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isupper_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isxdigit_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn tolower_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn toupper_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn isascii_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub fn toascii_l ( __c : ctypes :: c_int , __l : locale_t ) -> ctypes :: c_int ; } extern "C" { pub static mut _ctype_ : [ ctypes :: c_char ; 0usize ] ; } extern "C" { pub fn atan ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn cos ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn sin ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn tan ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn tanh ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn frexp ( arg1 : f64 , arg2 : * mut ctypes :: c_int ) -> f64 ; } extern "C" { pub fn modf ( arg1 : f64 , arg2 : * mut f64 ) -> f64 ; } extern "C" { pub fn ceil ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn fabs ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn floor ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn acos ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn asin ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn atan2 ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn cosh ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn sinh ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn exp ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn ldexp ( arg1 : f64 , arg2 : ctypes :: c_int ) -> f64 ; } extern "C" { pub fn log ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn log10 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn pow ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn sqrt ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn fmod ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn finite ( arg1 : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn finitef ( arg1 : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn finitel ( arg1 : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn isinff ( arg1 : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn isnanf ( arg1 : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn isinf ( arg1 : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn isnan ( arg1 : f64 ) -> ctypes :: c_int ; } pub type float_t = f32 ; pub type double_t = f64 ; extern "C" { pub fn __isinff ( x : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn __isinfd ( x : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn __isnanf ( x : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn __isnand ( x : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn __fpclassifyf ( x : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn __fpclassifyd ( x : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn __signbitf ( x : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn __signbitd ( x : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn infinity ( ) -> f64 ; } extern "C" { pub fn nan ( arg1 : * const ctypes :: c_char ) -> f64 ; } extern "C" { pub fn copysign ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn logb ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn ilogb ( arg1 : f64 ) -> ctypes :: c_int ; } extern "C" { pub fn asinh ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn cbrt ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn nextafter ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn rint ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn scalbn ( arg1 : f64 , arg2 : ctypes :: c_int ) -> f64 ; } extern "C" { pub fn exp2 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn scalbln ( arg1 : f64 , arg2 : ctypes :: c_long ) -> f64 ; } extern "C" { pub fn tgamma ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn nearbyint ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn lrint ( arg1 : f64 ) -> ctypes :: c_long ; } extern "C" { pub fn llrint ( arg1 : f64 ) -> ctypes :: c_longlong ; } extern "C" { pub fn round ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn lround ( arg1 : f64 ) -> ctypes :: c_long ; } extern "C" { pub fn llround ( arg1 : f64 ) -> ctypes :: c_longlong ; } extern "C" { pub fn trunc ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn remquo ( arg1 : f64 , arg2 : f64 , arg3 : * mut ctypes :: c_int ) -> f64 ; } extern "C" { pub fn fdim ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn fmax ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn fmin ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn fma ( arg1 : f64 , arg2 : f64 , arg3 : f64 ) -> f64 ; } extern "C" { pub fn log1p ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn expm1 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn acosh ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn atanh ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn remainder ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn gamma ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn lgamma ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn erf ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn erfc ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn log2 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn hypot ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn atanf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn cosf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn sinf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn tanf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn tanhf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn frexpf ( arg1 : f32 , arg2 : * mut ctypes :: c_int ) -> f32 ; } extern "C" { pub fn modff ( arg1 : f32 , arg2 : * mut f32 ) -> f32 ; } extern "C" { pub fn ceilf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn fabsf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn floorf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn acosf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn asinf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn atan2f ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn coshf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn sinhf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn expf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn ldexpf ( arg1 : f32 , arg2 : ctypes :: c_int ) -> f32 ; } extern "C" { pub fn logf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn log10f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn powf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn sqrtf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn fmodf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn exp2f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn scalblnf ( arg1 : f32 , arg2 : ctypes :: c_long ) -> f32 ; } extern "C" { pub fn tgammaf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn nearbyintf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn lrintf ( arg1 : f32 ) -> ctypes :: c_long ; } extern "C" { pub fn llrintf ( arg1 : f32 ) -> ctypes :: c_longlong ; } extern "C" { pub fn roundf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn lroundf ( arg1 : f32 ) -> ctypes :: c_long ; } extern "C" { pub fn llroundf ( arg1 : f32 ) -> ctypes :: c_longlong ; } extern "C" { pub fn truncf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn remquof ( arg1 : f32 , arg2 : f32 , arg3 : * mut ctypes :: c_int ) -> f32 ; } extern "C" { pub fn fdimf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn fmaxf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn fminf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn fmaf ( arg1 : f32 , arg2 : f32 , arg3 : f32 ) -> f32 ; } extern "C" { pub fn infinityf ( ) -> f32 ; } extern "C" { pub fn nanf ( arg1 : * const ctypes :: c_char ) -> f32 ; } extern "C" { pub fn copysignf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn logbf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn ilogbf ( arg1 : f32 ) -> ctypes :: c_int ; } extern "C" { pub fn asinhf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn cbrtf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn nextafterf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn rintf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn scalbnf ( arg1 : f32 , arg2 : ctypes :: c_int ) -> f32 ; } extern "C" { pub fn log1pf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn expm1f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn acoshf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn atanhf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn remainderf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn gammaf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn lgammaf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn erff ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn erfcf ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn log2f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn hypotf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn hypotl ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn sqrtl ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn drem ( arg1 : f64 , arg2 : f64 ) -> f64 ; } extern "C" { pub fn dremf ( arg1 : f32 , arg2 : f32 ) -> f32 ; } extern "C" { pub fn gamma_r ( arg1 : f64 , arg2 : * mut ctypes :: c_int ) -> f64 ; } extern "C" { pub fn lgamma_r ( arg1 : f64 , arg2 : * mut ctypes :: c_int ) -> f64 ; } extern "C" { pub fn gammaf_r ( arg1 : f32 , arg2 : * mut ctypes :: c_int ) -> f32 ; } extern "C" { pub fn lgammaf_r ( arg1 : f32 , arg2 : * mut ctypes :: c_int ) -> f32 ; } extern "C" { pub fn y0 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn y1 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn yn ( arg1 : ctypes :: c_int , arg2 : f64 ) -> f64 ; } extern "C" { pub fn j0 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn j1 ( arg1 : f64 ) -> f64 ; } extern "C" { pub fn jn ( arg1 : ctypes :: c_int , arg2 : f64 ) -> f64 ; } extern "C" { pub fn y0f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn y1f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn ynf ( arg1 : ctypes :: c_int , arg2 : f32 ) -> f32 ; } extern "C" { pub fn j0f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn j1f ( arg1 : f32 ) -> f32 ; } extern "C" { pub fn jnf ( arg1 : ctypes :: c_int , arg2 : f32 ) -> f32 ; } extern "C" { pub fn __signgam ( ) -> * mut ctypes :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct exception { pub type_ : ctypes :: c_int , pub name : * mut ctypes :: c_char , pub arg1 : f64 , pub arg2 : f64 , pub retval : f64 , pub err : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_exception ( ) { assert_eq ! ( :: core :: mem :: size_of :: < exception > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( exception ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < exception > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( exception ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < exception > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( exception ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < exception > ( ) ) ) . name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( exception ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < exception > ( ) ) ) . arg1 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( exception ) , "::" , stringify ! ( arg1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < exception > ( ) ) ) . arg2 as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( exception ) , "::" , stringify ! ( arg2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < exception > ( ) ) ) . retval as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( exception ) , "::" , stringify ! ( retval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < exception > ( ) ) ) . err as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( exception ) , "::" , stringify ! ( err ) ) ) ; } extern "C" { pub fn matherr ( e : * mut exception ) -> ctypes :: c_int ; } pub const __fdlibm_version___fdlibm_ieee : __fdlibm_version = -1 ; pub const __fdlibm_version___fdlibm_svid : __fdlibm_version = 0 ; pub const __fdlibm_version___fdlibm_xopen : __fdlibm_version = 1 ; pub const __fdlibm_version___fdlibm_posix : __fdlibm_version = 2 ; pub type __fdlibm_version = i32 ; extern "C" { pub static mut __fdlib_version : __fdlibm_version ; } pub const SDL_bool_SDL_FALSE : SDL_bool = 0 ; pub const SDL_bool_SDL_TRUE : SDL_bool = 1 ; pub type SDL_bool = u32 ; pub type Sint8 = i8 ; pub type Uint8 = u8 ; pub type Sint16 = i16 ; pub type Uint16 = u16 ; pub type Sint32 = i32 ; pub type Uint32 = u32 ; pub type Sint64 = i64 ; pub type Uint64 = u64 ; pub type SDL_compile_time_assert_uint8 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_sint8 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_uint16 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_sint16 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_uint32 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_sint32 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_uint64 = [ ctypes :: c_int ; 1usize ] ; pub type SDL_compile_time_assert_sint64 = [ ctypes :: c_int ; 1usize ] ; pub const SDL_DUMMY_ENUM_DUMMY_ENUM_VALUE : SDL_DUMMY_ENUM = 0 ; pub type SDL_DUMMY_ENUM = u32 ; pub type SDL_compile_time_assert_enum = [ ctypes :: c_int ; 1usize ] ; extern "C" { pub fn SDL_malloc ( size : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_calloc ( nmemb : usize , size : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_realloc ( mem : * mut ctypes :: c_void , size : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_free ( mem : * mut ctypes :: c_void ) ; } pub type SDL_malloc_func = :: core :: option :: Option < unsafe extern "C" fn ( size : usize ) -> * mut ctypes :: c_void > ; pub type SDL_calloc_func = :: core :: option :: Option < unsafe extern "C" fn ( nmemb : usize , size : usize ) -> * mut ctypes :: c_void > ; pub type SDL_realloc_func = :: core :: option :: Option < unsafe extern "C" fn ( mem : * mut ctypes :: c_void , size : usize ) -> * mut ctypes :: c_void > ; pub type SDL_free_func = :: core :: option :: Option < unsafe extern "C" fn ( mem : * mut ctypes :: c_void ) > ; extern "C" { 
 /// \brief Get the current set of SDL memory functions 
 pub fn SDL_GetMemoryFunctions ( malloc_func : * mut SDL_malloc_func , calloc_func : * mut SDL_calloc_func , realloc_func : * mut SDL_realloc_func , free_func : * mut SDL_free_func ) ; } extern "C" { 
 /// \brief Replace SDL's memory allocation functions with a custom set
///
/// \note If you are replacing SDL's memory functions, you should call
/// SDL_GetNumAllocations() and be very careful if it returns non-zero.
/// That means that your free function will be called with memory
/// allocated by the previous memory allocation functions. 
 pub fn SDL_SetMemoryFunctions ( malloc_func : SDL_malloc_func , calloc_func : SDL_calloc_func , realloc_func : SDL_realloc_func , free_func : SDL_free_func ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the number of outstanding (unfreed) allocations 
 pub fn SDL_GetNumAllocations ( ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_getenv ( name : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_setenv ( name : * const ctypes :: c_char , value : * const ctypes :: c_char , overwrite : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_qsort ( base : * mut ctypes :: c_void , nmemb : usize , size : usize , compare : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * const ctypes :: c_void , arg2 : * const ctypes :: c_void ) -> ctypes :: c_int > ) ; } extern "C" { pub fn SDL_abs ( x : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_isdigit ( x : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_isspace ( x : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_toupper ( x : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_tolower ( x : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_memset ( dst : * mut ctypes :: c_void , c : ctypes :: c_int , len : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_memcpy ( dst : * mut ctypes :: c_void , src : * const ctypes :: c_void , len : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_memmove ( dst : * mut ctypes :: c_void , src : * const ctypes :: c_void , len : usize ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_memcmp ( s1 : * const ctypes :: c_void , s2 : * const ctypes :: c_void , len : usize ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_wcslen ( wstr : * const wchar_t ) -> usize ; } extern "C" { pub fn SDL_wcslcpy ( dst : * mut wchar_t , src : * const wchar_t , maxlen : usize ) -> usize ; } extern "C" { pub fn SDL_wcslcat ( dst : * mut wchar_t , src : * const wchar_t , maxlen : usize ) -> usize ; } extern "C" { pub fn SDL_wcscmp ( str1 : * const wchar_t , str2 : * const wchar_t ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_strlen ( str : * const ctypes :: c_char ) -> usize ; } extern "C" { pub fn SDL_strlcpy ( dst : * mut ctypes :: c_char , src : * const ctypes :: c_char , maxlen : usize ) -> usize ; } extern "C" { pub fn SDL_utf8strlcpy ( dst : * mut ctypes :: c_char , src : * const ctypes :: c_char , dst_bytes : usize ) -> usize ; } extern "C" { pub fn SDL_strlcat ( dst : * mut ctypes :: c_char , src : * const ctypes :: c_char , maxlen : usize ) -> usize ; } extern "C" { pub fn SDL_strdup ( str : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_strrev ( str : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_strupr ( str : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_strlwr ( str : * mut ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_strchr ( str : * const ctypes :: c_char , c : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_strrchr ( str : * const ctypes :: c_char , c : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_strstr ( haystack : * const ctypes :: c_char , needle : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_utf8strlen ( str : * const ctypes :: c_char ) -> usize ; } extern "C" { pub fn SDL_itoa ( value : ctypes :: c_int , str : * mut ctypes :: c_char , radix : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_uitoa ( value : ctypes :: c_uint , str : * mut ctypes :: c_char , radix : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_ltoa ( value : ctypes :: c_long , str : * mut ctypes :: c_char , radix : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_ultoa ( value : ctypes :: c_ulong , str : * mut ctypes :: c_char , radix : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_lltoa ( value : Sint64 , str : * mut ctypes :: c_char , radix : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_ulltoa ( value : Uint64 , str : * mut ctypes :: c_char , radix : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { pub fn SDL_atoi ( str : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_atof ( str : * const ctypes :: c_char ) -> f64 ; } extern "C" { pub fn SDL_strtol ( str : * const ctypes :: c_char , endp : * mut * mut ctypes :: c_char , base : ctypes :: c_int ) -> ctypes :: c_long ; } extern "C" { pub fn SDL_strtoul ( str : * const ctypes :: c_char , endp : * mut * mut ctypes :: c_char , base : ctypes :: c_int ) -> ctypes :: c_ulong ; } extern "C" { pub fn SDL_strtoll ( str : * const ctypes :: c_char , endp : * mut * mut ctypes :: c_char , base : ctypes :: c_int ) -> Sint64 ; } extern "C" { pub fn SDL_strtoull ( str : * const ctypes :: c_char , endp : * mut * mut ctypes :: c_char , base : ctypes :: c_int ) -> Uint64 ; } extern "C" { pub fn SDL_strtod ( str : * const ctypes :: c_char , endp : * mut * mut ctypes :: c_char ) -> f64 ; } extern "C" { pub fn SDL_strcmp ( str1 : * const ctypes :: c_char , str2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_strncmp ( str1 : * const ctypes :: c_char , str2 : * const ctypes :: c_char , maxlen : usize ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_strcasecmp ( str1 : * const ctypes :: c_char , str2 : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_strncasecmp ( str1 : * const ctypes :: c_char , str2 : * const ctypes :: c_char , len : usize ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_sscanf ( text : * const ctypes :: c_char , fmt : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_vsscanf ( text : * const ctypes :: c_char , fmt : * const ctypes :: c_char , ap : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_snprintf ( text : * mut ctypes :: c_char , maxlen : usize , fmt : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_vsnprintf ( text : * mut ctypes :: c_char , maxlen : usize , fmt : * const ctypes :: c_char , ap : * mut __va_list_tag ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_acos ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_acosf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_asin ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_asinf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_atan ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_atanf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_atan2 ( x : f64 , y : f64 ) -> f64 ; } extern "C" { pub fn SDL_atan2f ( x : f32 , y : f32 ) -> f32 ; } extern "C" { pub fn SDL_ceil ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_ceilf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_copysign ( x : f64 , y : f64 ) -> f64 ; } extern "C" { pub fn SDL_copysignf ( x : f32 , y : f32 ) -> f32 ; } extern "C" { pub fn SDL_cos ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_cosf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_fabs ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_fabsf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_floor ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_floorf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_fmod ( x : f64 , y : f64 ) -> f64 ; } extern "C" { pub fn SDL_fmodf ( x : f32 , y : f32 ) -> f32 ; } extern "C" { pub fn SDL_log ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_logf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_log10 ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_log10f ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_pow ( x : f64 , y : f64 ) -> f64 ; } extern "C" { pub fn SDL_powf ( x : f32 , y : f32 ) -> f32 ; } extern "C" { pub fn SDL_scalbn ( x : f64 , n : ctypes :: c_int ) -> f64 ; } extern "C" { pub fn SDL_scalbnf ( x : f32 , n : ctypes :: c_int ) -> f32 ; } extern "C" { pub fn SDL_sin ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_sinf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_sqrt ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_sqrtf ( x : f32 ) -> f32 ; } extern "C" { pub fn SDL_tan ( x : f64 ) -> f64 ; } extern "C" { pub fn SDL_tanf ( x : f32 ) -> f32 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _SDL_iconv_t { _unused : [ u8 ; 0 ] , } pub type SDL_iconv_t = * mut _SDL_iconv_t ; extern "C" { pub fn SDL_iconv_open ( tocode : * const ctypes :: c_char , fromcode : * const ctypes :: c_char ) -> SDL_iconv_t ; } extern "C" { pub fn SDL_iconv_close ( cd : SDL_iconv_t ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_iconv ( cd : SDL_iconv_t , inbuf : * mut * const ctypes :: c_char , inbytesleft : * mut usize , outbuf : * mut * mut ctypes :: c_char , outbytesleft : * mut usize ) -> usize ; } extern "C" { 
 /// This function converts a string between encodings in one pass, returning a
/// string that must be freed with SDL_free() or NULL on error. 
 pub fn SDL_iconv_string ( tocode : * const ctypes :: c_char , fromcode : * const ctypes :: c_char , inbuf : * const ctypes :: c_char , inbytesleft : usize ) -> * mut ctypes :: c_char ; } extern "C" { 
 /// The prototype for the application's main() function 
 pub fn SDL_main ( argc : ctypes :: c_int , argv : * mut * mut ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { 
 /// This is called by the real SDL main function to let the rest of the
/// library know that initialization was done properly.
///
/// Calling this yourself without knowing what you're doing can cause
/// crashes and hard to diagnose problems with your application. 
 pub fn SDL_SetMainReady ( ) ; } 
 /// < Retry the assert immediately. 
 pub const SDL_AssertState_SDL_ASSERTION_RETRY : SDL_AssertState = 0 ; 
 /// < Make the debugger trigger a breakpoint. 
 pub const SDL_AssertState_SDL_ASSERTION_BREAK : SDL_AssertState = 1 ; 
 /// < Terminate the program. 
 pub const SDL_AssertState_SDL_ASSERTION_ABORT : SDL_AssertState = 2 ; 
 /// < Ignore the assert. 
 pub const SDL_AssertState_SDL_ASSERTION_IGNORE : SDL_AssertState = 3 ; 
 /// < Ignore the assert from now on. 
 pub const SDL_AssertState_SDL_ASSERTION_ALWAYS_IGNORE : SDL_AssertState = 4 ; pub type SDL_AssertState = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_AssertData { pub always_ignore : ctypes :: c_int , pub trigger_count : ctypes :: c_uint , pub condition : * const ctypes :: c_char , pub filename : * const ctypes :: c_char , pub linenum : ctypes :: c_int , pub function : * const ctypes :: c_char , pub next : * const SDL_AssertData , } # [ test ] fn bindgen_test_layout_SDL_AssertData ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_AssertData > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SDL_AssertData ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_AssertData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_AssertData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . always_ignore as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( always_ignore ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . trigger_count as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( trigger_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . condition as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( condition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . filename as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . linenum as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( linenum ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . function as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( function ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AssertData > ( ) ) ) . next as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AssertData ) , "::" , stringify ! ( next ) ) ) ; } extern "C" { pub fn SDL_ReportAssertion ( arg1 : * mut SDL_AssertData , arg2 : * const ctypes :: c_char , arg3 : * const ctypes :: c_char , arg4 : ctypes :: c_int ) -> SDL_AssertState ; } pub type SDL_AssertionHandler = :: core :: option :: Option < unsafe extern "C" fn ( data : * const SDL_AssertData , userdata : * mut ctypes :: c_void ) -> SDL_AssertState > ; extern "C" { 
 /// \brief Set an application-defined assertion handler.
///
/// This allows an app to show its own assertion UI and/or force the
/// response to an assertion failure. If the app doesn't provide this, SDL
/// will try to do the right thing, popping up a system-specific GUI dialog,
/// and probably minimizing any fullscreen windows.
///
/// This callback may fire from any thread, but it runs wrapped in a mutex, so
/// it will only fire from one thread at a time.
///
/// Setting the callback to NULL restores SDL's original internal handler.
///
/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
///
/// Return SDL_AssertState value of how to handle the assertion failure.
///
/// \param handler Callback function, called when an assertion fails.
/// \param userdata A pointer passed to the callback as-is. 
 pub fn SDL_SetAssertionHandler ( handler : SDL_AssertionHandler , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// \brief Get the default assertion handler.
///
/// This returns the function pointer that is called by default when an
/// assertion is triggered. This is an internal function provided by SDL,
/// that is used for assertions when SDL_SetAssertionHandler() hasn't been
/// used to provide a different function.
///
/// \return The default SDL_AssertionHandler that is called when an assert triggers. 
 pub fn SDL_GetDefaultAssertionHandler ( ) -> SDL_AssertionHandler ; } extern "C" { 
 /// \brief Get the current assertion handler.
///
/// This returns the function pointer that is called when an assertion is
/// triggered. This is either the value last passed to
/// SDL_SetAssertionHandler(), or if no application-specified function is
/// set, is equivalent to calling SDL_GetDefaultAssertionHandler().
///
/// \param puserdata Pointer to a void*, which will store the "userdata"
/// pointer that was passed to SDL_SetAssertionHandler().
/// This value will always be NULL for the default handler.
/// If you don't care about this data, it is safe to pass
/// a NULL pointer to this function to ignore it.
/// \return The SDL_AssertionHandler that is called when an assert triggers. 
 pub fn SDL_GetAssertionHandler ( puserdata : * mut * mut ctypes :: c_void ) -> SDL_AssertionHandler ; } extern "C" { 
 /// \brief Get a list of all assertion failures.
///
/// Get all assertions triggered since last call to SDL_ResetAssertionReport(),
/// or the start of the program.
///
/// The proper way to examine this data looks something like this:
///
/// <code>
/// const SDL_AssertData *item = SDL_GetAssertionReport();
/// while (item) {
/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
/// item->condition, item->function, item->filename,
/// item->linenum, item->trigger_count,
/// item->always_ignore ? "yes" : "no");
/// item = item->next;
/// }
/// </code>
///
/// \return List of all assertions.
/// \sa SDL_ResetAssertionReport 
 pub fn SDL_GetAssertionReport ( ) -> * const SDL_AssertData ; } extern "C" { 
 /// \brief Reset the list of all assertion failures.
///
/// Reset list of all assertions triggered.
///
/// \sa SDL_GetAssertionReport 
 pub fn SDL_ResetAssertionReport ( ) ; } pub type SDL_SpinLock = ctypes :: c_int ; extern "C" { 
 /// \brief Try to lock a spin lock by setting it to a non-zero value.
///
/// \param lock Points to the lock.
///
/// \return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held. 
 pub fn SDL_AtomicTryLock ( lock : * mut SDL_SpinLock ) -> SDL_bool ; } extern "C" { 
 /// \brief Lock a spin lock by setting it to a non-zero value.
///
/// \param lock Points to the lock. 
 pub fn SDL_AtomicLock ( lock : * mut SDL_SpinLock ) ; } extern "C" { 
 /// \brief Unlock a spin lock by setting it to 0. Always returns immediately
///
/// \param lock Points to the lock. 
 pub fn SDL_AtomicUnlock ( lock : * mut SDL_SpinLock ) ; } extern "C" { 
 /// Memory barriers are designed to prevent reads and writes from being
/// reordered by the compiler and being seen out of order on multi-core CPUs.
///
/// A typical pattern would be for thread A to write some data and a flag,
/// and for thread B to read the flag and get the data. In this case you
/// would insert a release barrier between writing the data and the flag,
/// guaranteeing that the data write completes no later than the flag is
/// written, and you would insert an acquire barrier between reading the
/// flag and reading the data, to ensure that all the reads associated
/// with the flag have completed.
///
/// In this pattern you should always see a release barrier paired with
/// an acquire barrier and you should gate the data reads/writes with a
/// single flag variable.
///
/// For more information on these semantics, take a look at the blog post:
/// http://preshing.com/20120913/acquire-and-release-semantics 
 pub fn SDL_MemoryBarrierReleaseFunction ( ) ; } extern "C" { pub fn SDL_MemoryBarrierAcquireFunction ( ) ; } 
 /// \brief A type representing an atomic integer value.  It is a struct
/// so people don't accidentally use numeric operations on it. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_atomic_t { pub value : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_atomic_t ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_atomic_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( SDL_atomic_t ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_atomic_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_atomic_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_atomic_t > ( ) ) ) . value as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_atomic_t ) , "::" , stringify ! ( value ) ) ) ; } extern "C" { 
 /// \brief Set an atomic variable to a new value if it is currently an old value.
///
/// \return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
///
/// \note If you don't know what this function is for, you shouldn't use it! 
 pub fn SDL_AtomicCAS ( a : * mut SDL_atomic_t , oldval : ctypes :: c_int , newval : ctypes :: c_int ) -> SDL_bool ; } extern "C" { 
 /// \brief Set an atomic variable to a value.
///
/// \return The previous value of the atomic variable. 
 pub fn SDL_AtomicSet ( a : * mut SDL_atomic_t , v : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the value of an atomic variable 
 pub fn SDL_AtomicGet ( a : * mut SDL_atomic_t ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Add to an atomic variable.
///
/// \return The previous value of the atomic variable.
///
/// \note This same style can be used for any number operation 
 pub fn SDL_AtomicAdd ( a : * mut SDL_atomic_t , v : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set a pointer to a new value if it is currently an old value.
///
/// \return SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
///
/// \note If you don't know what this function is for, you shouldn't use it! 
 pub fn SDL_AtomicCASPtr ( a : * mut * mut ctypes :: c_void , oldval : * mut ctypes :: c_void , newval : * mut ctypes :: c_void ) -> SDL_bool ; } extern "C" { 
 /// \brief Set a pointer to a value atomically.
///
/// \return The previous value of the pointer. 
 pub fn SDL_AtomicSetPtr ( a : * mut * mut ctypes :: c_void , v : * mut ctypes :: c_void ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Get the value of a pointer atomically. 
 pub fn SDL_AtomicGetPtr ( a : * mut * mut ctypes :: c_void ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_SetError ( fmt : * const ctypes :: c_char , ... ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_GetError ( ) -> * const ctypes :: c_char ; } extern "C" { pub fn SDL_ClearError ( ) ; } pub const SDL_errorcode_SDL_ENOMEM : SDL_errorcode = 0 ; pub const SDL_errorcode_SDL_EFREAD : SDL_errorcode = 1 ; pub const SDL_errorcode_SDL_EFWRITE : SDL_errorcode = 2 ; pub const SDL_errorcode_SDL_EFSEEK : SDL_errorcode = 3 ; pub const SDL_errorcode_SDL_UNSUPPORTED : SDL_errorcode = 4 ; pub const SDL_errorcode_SDL_LASTERROR : SDL_errorcode = 5 ; pub type SDL_errorcode = u32 ; extern "C" { pub fn SDL_Error ( code : SDL_errorcode ) -> ctypes :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_mutex { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Create a mutex, initialized unlocked. 
 pub fn SDL_CreateMutex ( ) -> * mut SDL_mutex ; } extern "C" { pub fn SDL_LockMutex ( mutex : * mut SDL_mutex ) -> ctypes :: c_int ; } extern "C" { 
 /// Try to lock the mutex
///
/// \return 0, SDL_MUTEX_TIMEDOUT, or -1 on error 
 pub fn SDL_TryLockMutex ( mutex : * mut SDL_mutex ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_UnlockMutex ( mutex : * mut SDL_mutex ) -> ctypes :: c_int ; } extern "C" { 
 /// Destroy a mutex. 
 pub fn SDL_DestroyMutex ( mutex : * mut SDL_mutex ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_semaphore { _unused : [ u8 ; 0 ] , } pub type SDL_sem = SDL_semaphore ; extern "C" { 
 /// Create a semaphore, initialized with value, returns NULL on failure. 
 pub fn SDL_CreateSemaphore ( initial_value : Uint32 ) -> * mut SDL_sem ; } extern "C" { 
 /// Destroy a semaphore. 
 pub fn SDL_DestroySemaphore ( sem : * mut SDL_sem ) ; } extern "C" { 
 /// This function suspends the calling thread until the semaphore pointed
/// to by \c sem has a positive count. It then atomically decreases the
/// semaphore count. 
 pub fn SDL_SemWait ( sem : * mut SDL_sem ) -> ctypes :: c_int ; } extern "C" { 
 /// Non-blocking variant of SDL_SemWait().
///
/// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would
/// block, and -1 on error. 
 pub fn SDL_SemTryWait ( sem : * mut SDL_sem ) -> ctypes :: c_int ; } extern "C" { 
 /// Variant of SDL_SemWait() with a timeout in milliseconds.
///
/// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not
/// succeed in the allotted time, and -1 on error.
///
/// \warning On some platforms this function is implemented by looping with a
/// delay of 1 ms, and so should be avoided if possible. 
 pub fn SDL_SemWaitTimeout ( sem : * mut SDL_sem , ms : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// Atomically increases the semaphore's count (not blocking).
///
/// \return 0, or -1 on error. 
 pub fn SDL_SemPost ( sem : * mut SDL_sem ) -> ctypes :: c_int ; } extern "C" { 
 /// Returns the current count of the semaphore. 
 pub fn SDL_SemValue ( sem : * mut SDL_sem ) -> Uint32 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_cond { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Create a condition variable.
///
/// Typical use of condition variables:
///
/// Thread A:
/// SDL_LockMutex(lock);
/// while ( ! condition ) {
/// SDL_CondWait(cond, lock);
/// }
/// SDL_UnlockMutex(lock);
///
/// Thread B:
/// SDL_LockMutex(lock);
/// ...
/// condition = true;
/// ...
/// SDL_CondSignal(cond);
/// SDL_UnlockMutex(lock);
///
/// There is some discussion whether to signal the condition variable
/// with the mutex locked or not.  There is some potential performance
/// benefit to unlocking first on some platforms, but there are some
/// potential race conditions depending on how your code is structured.
///
/// In general it's safer to signal the condition variable while the
/// mutex is locked. 
 pub fn SDL_CreateCond ( ) -> * mut SDL_cond ; } extern "C" { 
 /// Destroy a condition variable. 
 pub fn SDL_DestroyCond ( cond : * mut SDL_cond ) ; } extern "C" { 
 /// Restart one of the threads that are waiting on the condition variable.
///
/// \return 0 or -1 on error. 
 pub fn SDL_CondSignal ( cond : * mut SDL_cond ) -> ctypes :: c_int ; } extern "C" { 
 /// Restart all threads that are waiting on the condition variable.
///
/// \return 0 or -1 on error. 
 pub fn SDL_CondBroadcast ( cond : * mut SDL_cond ) -> ctypes :: c_int ; } extern "C" { 
 /// Wait on the condition variable, unlocking the provided mutex.
///
/// \warning The mutex must be locked before entering this function!
///
/// The mutex is re-locked once the condition variable is signaled.
///
/// \return 0 when it is signaled, or -1 on error. 
 pub fn SDL_CondWait ( cond : * mut SDL_cond , mutex : * mut SDL_mutex ) -> ctypes :: c_int ; } extern "C" { 
 /// Waits for at most \c ms milliseconds, and returns 0 if the condition
/// variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not
/// signaled in the allotted time, and -1 on error.
///
/// \warning On some platforms this function is implemented by looping with a
/// delay of 1 ms, and so should be avoided if possible. 
 pub fn SDL_CondWaitTimeout ( cond : * mut SDL_cond , mutex : * mut SDL_mutex , ms : Uint32 ) -> ctypes :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Thread { _unused : [ u8 ; 0 ] , } pub type SDL_threadID = ctypes :: c_ulong ; pub type SDL_TLSID = ctypes :: c_uint ; pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_LOW : SDL_ThreadPriority = 0 ; pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_NORMAL : SDL_ThreadPriority = 1 ; pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_HIGH : SDL_ThreadPriority = 2 ; 
 /// The SDL thread priority.
///
/// \note On many systems you require special privileges to set high priority. 
 pub type SDL_ThreadPriority = u32 ; 
 /// The function passed to SDL_CreateThread().
/// It is passed a void* user context parameter and returns an int. 
 pub type SDL_ThreadFunction = :: core :: option :: Option < unsafe extern "C" fn ( data : * mut ctypes :: c_void ) -> ctypes :: c_int > ; extern "C" { 
 /// Create a thread.
///
/// Thread naming is a little complicated: Most systems have very small
/// limits for the string length (Haiku has 32 bytes, Linux currently has 16,
/// Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll
/// have to see what happens with your system's debugger. The name should be
/// UTF-8 (but using the naming limits of C identifiers is a better bet).
/// There are no requirements for thread naming conventions, so long as the
/// string is null-terminated UTF-8, but these guidelines are helpful in
/// choosing a name:
///
/// http://stackoverflow.com/questions/149932/naming-conventions-for-threads
///
/// If a system imposes requirements, SDL will try to munge the string for
/// it (truncate, etc), but the original string contents will be available
/// from SDL_GetThreadName(). 
 pub fn SDL_CreateThread ( fn_ : SDL_ThreadFunction , name : * const ctypes :: c_char , data : * mut ctypes :: c_void ) -> * mut SDL_Thread ; } extern "C" { 
 /// Get the thread name, as it was specified in SDL_CreateThread().
/// This function returns a pointer to a UTF-8 string that names the
/// specified thread, or NULL if it doesn't have a name. This is internal
/// memory, not to be free()'d by the caller, and remains valid until the
/// specified thread is cleaned up by SDL_WaitThread(). 
 pub fn SDL_GetThreadName ( thread : * mut SDL_Thread ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Get the thread identifier for the current thread. 
 pub fn SDL_ThreadID ( ) -> SDL_threadID ; } extern "C" { 
 /// Get the thread identifier for the specified thread.
///
/// Equivalent to SDL_ThreadID() if the specified thread is NULL. 
 pub fn SDL_GetThreadID ( thread : * mut SDL_Thread ) -> SDL_threadID ; } extern "C" { 
 /// Set the priority for the current thread 
 pub fn SDL_SetThreadPriority ( priority : SDL_ThreadPriority ) -> ctypes :: c_int ; } extern "C" { 
 /// Wait for a thread to finish. Threads that haven't been detached will
/// remain (as a "zombie") until this function cleans them up. Not doing so
/// is a resource leak.
///
/// Once a thread has been cleaned up through this function, the SDL_Thread
/// that references it becomes invalid and should not be referenced again.
/// As such, only one thread may call SDL_WaitThread() on another.
///
/// The return code for the thread function is placed in the area
/// pointed to by \c status, if \c status is not NULL.
///
/// You may not wait on a thread that has been used in a call to
/// SDL_DetachThread(). Use either that function or this one, but not
/// both, or behavior is undefined.
///
/// It is safe to pass NULL to this function; it is a no-op. 
 pub fn SDL_WaitThread ( thread : * mut SDL_Thread , status : * mut ctypes :: c_int ) ; } extern "C" { 
 /// A thread may be "detached" to signify that it should not remain until
/// another thread has called SDL_WaitThread() on it. Detaching a thread
/// is useful for long-running threads that nothing needs to synchronize
/// with or further manage. When a detached thread is done, it simply
/// goes away.
///
/// There is no way to recover the return code of a detached thread. If you
/// need this, don't detach the thread and instead use SDL_WaitThread().
///
/// Once a thread is detached, you should usually assume the SDL_Thread isn't
/// safe to reference again, as it will become invalid immediately upon
/// the detached thread's exit, instead of remaining until someone has called
/// SDL_WaitThread() to finally clean it up. As such, don't detach the same
/// thread more than once.
///
/// If a thread has already exited when passed to SDL_DetachThread(), it will
/// stop waiting for a call to SDL_WaitThread() and clean up immediately.
/// It is not safe to detach a thread that might be used with SDL_WaitThread().
///
/// You may not call SDL_WaitThread() on a thread that has been detached.
/// Use either that function or this one, but not both, or behavior is
/// undefined.
///
/// It is safe to pass NULL to this function; it is a no-op. 
 pub fn SDL_DetachThread ( thread : * mut SDL_Thread ) ; } extern "C" { 
 /// \brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific.
///
/// \return The newly created thread local storage identifier, or 0 on error
///
/// \code
/// static SDL_SpinLock tls_lock;
/// static SDL_TLSID thread_local_storage;
///
/// void SetMyThreadData(void *value)
/// {
/// if (!thread_local_storage) {
/// SDL_AtomicLock(&tls_lock);
/// if (!thread_local_storage) {
/// thread_local_storage = SDL_TLSCreate();
/// }
/// SDL_AtomicUnlock(&tls_lock);
/// }
/// SDL_TLSSet(thread_local_storage, value, 0);
/// }
///
/// void *GetMyThreadData(void)
/// {
/// return SDL_TLSGet(thread_local_storage);
/// }
/// \endcode
///
/// \sa SDL_TLSGet()
/// \sa SDL_TLSSet() 
 pub fn SDL_TLSCreate ( ) -> SDL_TLSID ; } extern "C" { 
 /// \brief Get the value associated with a thread local storage ID for the current thread.
///
/// \param id The thread local storage ID
///
/// \return The value associated with the ID for the current thread, or NULL if no value has been set.
///
/// \sa SDL_TLSCreate()
/// \sa SDL_TLSSet() 
 pub fn SDL_TLSGet ( id : SDL_TLSID ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Set the value associated with a thread local storage ID for the current thread.
///
/// \param id The thread local storage ID
/// \param value The value to associate with the ID for the current thread
/// \param destructor A function called when the thread exits, to free the value.
///
/// \return 0 on success, -1 on error
///
/// \sa SDL_TLSCreate()
/// \sa SDL_TLSGet() 
 pub fn SDL_TLSSet ( id : SDL_TLSID , value : * const ctypes :: c_void , destructor : :: core :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ctypes :: c_void ) > ) -> ctypes :: c_int ; } 
 /// This is the read/write operation structure -- very basic. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct SDL_RWops { 
 /// Return the size of the file in this rwops, or -1 if unknown 
 pub size : :: core :: option :: Option < unsafe extern "C" fn ( context : * mut SDL_RWops ) -> Sint64 > , 
 /// Seek to \c offset relative to \c whence, one of stdio's whence values:
    /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
    ///
    /// \return the final offset in the data stream, or -1 on error. 
 pub seek : :: core :: option :: Option < unsafe extern "C" fn ( context : * mut SDL_RWops , offset : Sint64 , whence : ctypes :: c_int ) -> Sint64 > , 
 /// Read up to \c maxnum objects each of size \c size from the data
    /// stream to the area pointed at by \c ptr.
    ///
    /// \return the number of objects read, or 0 at error or end of file. 
 pub read : :: core :: option :: Option < unsafe extern "C" fn ( context : * mut SDL_RWops , ptr : * mut ctypes :: c_void , size : usize , maxnum : usize ) -> usize > , 
 /// Write exactly \c num objects each of size \c size from the area
    /// pointed at by \c ptr to data stream.
    ///
    /// \return the number of objects written, or 0 at error or end of file. 
 pub write : :: core :: option :: Option < unsafe extern "C" fn ( context : * mut SDL_RWops , ptr : * const ctypes :: c_void , size : usize , num : usize ) -> usize > , 
 /// Close and free an allocated SDL_RWops structure.
    ///
    /// \return 0 if successful or -1 on write error when flushing data. 
 pub close : :: core :: option :: Option < unsafe extern "C" fn ( context : * mut SDL_RWops ) -> ctypes :: c_int > , pub type_ : Uint32 , pub hidden : SDL_RWops__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union SDL_RWops__bindgen_ty_1 { pub stdio : SDL_RWops__bindgen_ty_1__bindgen_ty_1 , pub mem : SDL_RWops__bindgen_ty_1__bindgen_ty_2 , pub unknown : SDL_RWops__bindgen_ty_1__bindgen_ty_3 , _bindgen_union_align : [ u64 ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 { pub autoclose : SDL_bool , pub fp : * mut FILE , } # [ test ] fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_RWops__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_RWops__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . autoclose as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( autoclose ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . fp as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( fp ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 { pub base : * mut Uint8 , pub here : * mut Uint8 , pub stop : * mut Uint8 , } # [ test ] fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_RWops__bindgen_ty_1__bindgen_ty_2 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_RWops__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . here as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( here ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_2 > ( ) ) ) . stop as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( stop ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 { pub data1 : * mut ctypes :: c_void , pub data2 : * mut ctypes :: c_void , } # [ test ] fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_RWops__bindgen_ty_1__bindgen_ty_3 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_RWops__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_3 > ( ) ) ) . data1 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( data1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1__bindgen_ty_3 > ( ) ) ) . data2 as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( data2 ) ) ) ; } # [ test ] fn bindgen_test_layout_SDL_RWops__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_RWops__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_RWops__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_RWops__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_RWops__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1 > ( ) ) ) . stdio as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1 ) , "::" , stringify ! ( stdio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1 > ( ) ) ) . mem as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1 ) , "::" , stringify ! ( mem ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops__bindgen_ty_1 > ( ) ) ) . unknown as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops__bindgen_ty_1 ) , "::" , stringify ! ( unknown ) ) ) ; } # [ test ] fn bindgen_test_layout_SDL_RWops ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_RWops > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( SDL_RWops ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_RWops > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_RWops ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . seek as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . read as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( read ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . write as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( write ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . close as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( close ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . type_ as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RWops > ( ) ) ) . hidden as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RWops ) , "::" , stringify ! ( hidden ) ) ) ; } extern "C" { pub fn SDL_RWFromFile ( file : * const ctypes :: c_char , mode : * const ctypes :: c_char ) -> * mut SDL_RWops ; } extern "C" { pub fn SDL_RWFromFP ( fp : * mut FILE , autoclose : SDL_bool ) -> * mut SDL_RWops ; } extern "C" { pub fn SDL_RWFromMem ( mem : * mut ctypes :: c_void , size : ctypes :: c_int ) -> * mut SDL_RWops ; } extern "C" { pub fn SDL_RWFromConstMem ( mem : * const ctypes :: c_void , size : ctypes :: c_int ) -> * mut SDL_RWops ; } extern "C" { pub fn SDL_AllocRW ( ) -> * mut SDL_RWops ; } extern "C" { pub fn SDL_FreeRW ( area : * mut SDL_RWops ) ; } extern "C" { 
 /// Load all the data from an SDL data stream.
///
/// The data is allocated with a zero byte at the end (null terminated)
///
/// If \c datasize is not NULL, it is filled with the size of the data read.
///
/// If \c freesrc is non-zero, the stream will be closed after being read.
///
/// The data should be freed with SDL_free().
///
/// \return the data, or NULL if there was an error. 
 pub fn SDL_LoadFile_RW ( src : * mut SDL_RWops , datasize : * mut usize , freesrc : ctypes :: c_int ) -> * mut ctypes :: c_void ; } extern "C" { pub fn SDL_ReadU8 ( src : * mut SDL_RWops ) -> Uint8 ; } extern "C" { pub fn SDL_ReadLE16 ( src : * mut SDL_RWops ) -> Uint16 ; } extern "C" { pub fn SDL_ReadBE16 ( src : * mut SDL_RWops ) -> Uint16 ; } extern "C" { pub fn SDL_ReadLE32 ( src : * mut SDL_RWops ) -> Uint32 ; } extern "C" { pub fn SDL_ReadBE32 ( src : * mut SDL_RWops ) -> Uint32 ; } extern "C" { pub fn SDL_ReadLE64 ( src : * mut SDL_RWops ) -> Uint64 ; } extern "C" { pub fn SDL_ReadBE64 ( src : * mut SDL_RWops ) -> Uint64 ; } extern "C" { pub fn SDL_WriteU8 ( dst : * mut SDL_RWops , value : Uint8 ) -> usize ; } extern "C" { pub fn SDL_WriteLE16 ( dst : * mut SDL_RWops , value : Uint16 ) -> usize ; } extern "C" { pub fn SDL_WriteBE16 ( dst : * mut SDL_RWops , value : Uint16 ) -> usize ; } extern "C" { pub fn SDL_WriteLE32 ( dst : * mut SDL_RWops , value : Uint32 ) -> usize ; } extern "C" { pub fn SDL_WriteBE32 ( dst : * mut SDL_RWops , value : Uint32 ) -> usize ; } extern "C" { pub fn SDL_WriteLE64 ( dst : * mut SDL_RWops , value : Uint64 ) -> usize ; } extern "C" { pub fn SDL_WriteBE64 ( dst : * mut SDL_RWops , value : Uint64 ) -> usize ; } 
 /// \brief Audio format flags.
///
/// These are what the 16 bits in SDL_AudioFormat currently mean...
/// (Unspecified bits are always zero).
///
/// \verbatim
/// ++-----------------------sample is signed if set
/// ||
/// ||       ++-----------sample is bigendian if set
/// ||       ||
/// ||       ||          ++---sample is float if set
/// ||       ||          ||
/// ||       ||          || +---sample bit size---+
/// ||       ||          || |                     |
/// 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
/// \endverbatim
///
/// There are macros in SDL 2.0 and later to query these bits. 
 pub type SDL_AudioFormat = Uint16 ; 
 /// This function is called when the audio device needs more data.
///
/// \param userdata An application-specific parameter saved in
/// the SDL_AudioSpec structure
/// \param stream A pointer to the audio data buffer.
/// \param len    The length of that buffer in bytes.
///
/// Once the callback returns, the buffer will no longer be valid.
/// Stereo samples are stored in a LRLRLR ordering.
///
/// You can choose to avoid callbacks and use SDL_QueueAudio() instead, if
/// you like. Just open your audio device with a NULL callback. 
 pub type SDL_AudioCallback = :: core :: option :: Option < unsafe extern "C" fn ( userdata : * mut ctypes :: c_void , stream : * mut Uint8 , len : ctypes :: c_int ) > ; 
 /// The calculated values in this structure are calculated by SDL_OpenAudio().
///
/// For multi-channel audio, the default SDL channel mapping is:
/// 2:  FL FR                       (stereo)
/// 3:  FL FR LFE                   (2.1 surround)
/// 4:  FL FR BL BR                 (quad)
/// 5:  FL FR FC BL BR              (quad + center)
/// 6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)
/// 7:  FL FR FC LFE BC SL SR       (6.1 surround)
/// 8:  FL FR FC LFE BL BR SL SR    (7.1 surround) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_AudioSpec { 
 /// < DSP frequency -- samples per second 
 pub freq : ctypes :: c_int , 
 /// < Audio data format 
 pub format : SDL_AudioFormat , 
 /// < Number of channels: 1 mono, 2 stereo 
 pub channels : Uint8 , 
 /// < Audio buffer silence value (calculated) 
 pub silence : Uint8 , 
 /// < Audio buffer size in sample FRAMES (total samples divided by channel count) 
 pub samples : Uint16 , 
 /// < Necessary for some compile environments 
 pub padding : Uint16 , 
 /// < Audio buffer size in bytes (calculated) 
 pub size : Uint32 , 
 /// < Callback that feeds the audio device (NULL to use SDL_QueueAudio()). 
 pub callback : SDL_AudioCallback , 
 /// < Userdata passed to callback (ignored for NULL callbacks). 
 pub userdata : * mut ctypes :: c_void , } # [ test ] fn bindgen_test_layout_SDL_AudioSpec ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_AudioSpec > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SDL_AudioSpec ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_AudioSpec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_AudioSpec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . freq as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( freq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . format as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . channels as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . silence as * const _ as usize } , 7usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( silence ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . samples as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( samples ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . padding as * const _ as usize } , 10usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . callback as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( callback ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioSpec > ( ) ) ) . userdata as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioSpec ) , "::" , stringify ! ( userdata ) ) ) ; } pub type SDL_AudioFilter = :: core :: option :: Option < unsafe extern "C" fn ( cvt : * mut SDL_AudioCVT , format : SDL_AudioFormat ) > ; # [ repr ( C , packed ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_AudioCVT { 
 /// < Set to 1 if conversion possible 
 pub needed : ctypes :: c_int , 
 /// < Source audio format 
 pub src_format : SDL_AudioFormat , 
 /// < Target audio format 
 pub dst_format : SDL_AudioFormat , 
 /// < Rate conversion increment 
 pub rate_incr : f64 , 
 /// < Buffer to hold entire audio data 
 pub buf : * mut Uint8 , 
 /// < Length of original audio buffer 
 pub len : ctypes :: c_int , 
 /// < Length of converted audio buffer 
 pub len_cvt : ctypes :: c_int , 
 /// < buffer must be len*len_mult big 
 pub len_mult : ctypes :: c_int , 
 /// < Given len, final size is len*len_ratio 
 pub len_ratio : f64 , 
 /// < NULL-terminated list of filter functions 
 pub filters : [ SDL_AudioFilter ; 10usize ] , 
 /// < Current audio conversion function 
 pub filter_index : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_AudioCVT ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_AudioCVT > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( SDL_AudioCVT ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_AudioCVT > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_AudioCVT ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . needed as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( needed ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . src_format as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( src_format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . dst_format as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( dst_format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . rate_incr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( rate_incr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . buf as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . len as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . len_cvt as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( len_cvt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . len_mult as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( len_mult ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . len_ratio as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( len_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . filters as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( filters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioCVT > ( ) ) ) . filter_index as * const _ as usize } , 124usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioCVT ) , "::" , stringify ! ( filter_index ) ) ) ; } extern "C" { pub fn SDL_GetNumAudioDrivers ( ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_GetAudioDriver ( index : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { pub fn SDL_AudioInit ( driver_name : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_AudioQuit ( ) ; } extern "C" { 
 /// This function returns the name of the current audio driver, or NULL
/// if no driver has been initialized. 
 pub fn SDL_GetCurrentAudioDriver ( ) -> * const ctypes :: c_char ; } extern "C" { 
 /// This function opens the audio device with the desired parameters, and
/// returns 0 if successful, placing the actual hardware parameters in the
/// structure pointed to by \c obtained.  If \c obtained is NULL, the audio
/// data passed to the callback function will be guaranteed to be in the
/// requested format, and will be automatically converted to the hardware
/// audio format if necessary.  This function returns -1 if it failed
/// to open the audio device, or couldn't set up the audio thread.
///
/// When filling in the desired audio spec structure,
/// - \c desired->freq should be the desired audio frequency in samples-per-
/// second.
/// - \c desired->format should be the desired audio format.
/// - \c desired->samples is the desired size of the audio buffer, in
/// samples.  This number should be a power of two, and may be adjusted by
/// the audio driver to a value more suitable for the hardware.  Good values
/// seem to range between 512 and 8096 inclusive, depending on the
/// application and CPU speed.  Smaller values yield faster response time,
/// but can lead to underflow if the application is doing heavy processing
/// and cannot fill the audio buffer in time.  A stereo sample consists of
/// both right and left channels in LR ordering.
/// Note that the number of samples is directly related to time by the
/// following formula:  \code ms = (samples*1000)/freq \endcode
/// - \c desired->size is the size in bytes of the audio buffer, and is
/// calculated by SDL_OpenAudio().
/// - \c desired->silence is the value used to set the buffer to silence,
/// and is calculated by SDL_OpenAudio().
/// - \c desired->callback should be set to a function that will be called
/// when the audio device is ready for more data.  It is passed a pointer
/// to the audio buffer, and the length in bytes of the audio buffer.
/// This function usually runs in a separate thread, and so you should
/// protect data structures that it accesses by calling SDL_LockAudio()
/// and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL
/// pointer here, and call SDL_QueueAudio() with some frequency, to queue
/// more audio samples to be played (or for capture devices, call
/// SDL_DequeueAudio() with some frequency, to obtain audio samples).
/// - \c desired->userdata is passed as the first parameter to your callback
/// function. If you passed a NULL callback, this value is ignored.
///
/// The audio device starts out playing silence when it's opened, and should
/// be enabled for playing by calling \c SDL_PauseAudio(0) when you are ready
/// for your audio callback function to be called.  Since the audio driver
/// may modify the requested size of the audio buffer, you should allocate
/// any local mixing buffers after you open the audio device. 
 pub fn SDL_OpenAudio ( desired : * mut SDL_AudioSpec , obtained : * mut SDL_AudioSpec ) -> ctypes :: c_int ; } 
 /// SDL Audio Device IDs.
///
/// A successful call to SDL_OpenAudio() is always device id 1, and legacy
/// SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
/// always returns devices >= 2 on success. The legacy calls are good both
/// for backwards compatibility and when you don't care about multiple,
/// specific, or capture devices. 
 pub type SDL_AudioDeviceID = Uint32 ; extern "C" { 
 /// Get the number of available devices exposed by the current driver.
/// Only valid after a successfully initializing the audio subsystem.
/// Returns -1 if an explicit list of devices can't be determined; this is
/// not an error. For example, if SDL is set up to talk to a remote audio
/// server, it can't list every one available on the Internet, but it will
/// still allow a specific host to be specified to SDL_OpenAudioDevice().
///
/// In many common cases, when this function returns a value <= 0, it can still
/// successfully open the default device (NULL for first argument of
/// SDL_OpenAudioDevice()). 
 pub fn SDL_GetNumAudioDevices ( iscapture : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the human-readable name of a specific audio device.
/// Must be a value between 0 and (number of audio devices-1).
/// Only valid after a successfully initializing the audio subsystem.
/// The values returned by this function reflect the latest call to
/// SDL_GetNumAudioDevices(); recall that function to redetect available
/// hardware.
///
/// The string returned by this function is UTF-8 encoded, read-only, and
/// managed internally. You are not to free it. If you need to keep the
/// string for any length of time, you should make your own copy of it, as it
/// will be invalid next time any of several other SDL functions is called. 
 pub fn SDL_GetAudioDeviceName ( index : ctypes :: c_int , iscapture : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Open a specific audio device. Passing in a device name of NULL requests
/// the most reasonable default (and is equivalent to calling SDL_OpenAudio()).
///
/// The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
/// some drivers allow arbitrary and driver-specific strings, such as a
/// hostname/IP address for a remote audio server, or a filename in the
/// diskaudio driver.
///
/// \return 0 on error, a valid device ID that is >= 2 on success.
///
/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. 
 pub fn SDL_OpenAudioDevice ( device : * const ctypes :: c_char , iscapture : ctypes :: c_int , desired : * const SDL_AudioSpec , obtained : * mut SDL_AudioSpec , allowed_changes : ctypes :: c_int ) -> SDL_AudioDeviceID ; } pub const SDL_AudioStatus_SDL_AUDIO_STOPPED : SDL_AudioStatus = 0 ; pub const SDL_AudioStatus_SDL_AUDIO_PLAYING : SDL_AudioStatus = 1 ; pub const SDL_AudioStatus_SDL_AUDIO_PAUSED : SDL_AudioStatus = 2 ; pub type SDL_AudioStatus = u32 ; extern "C" { pub fn SDL_GetAudioStatus ( ) -> SDL_AudioStatus ; } extern "C" { pub fn SDL_GetAudioDeviceStatus ( dev : SDL_AudioDeviceID ) -> SDL_AudioStatus ; } extern "C" { pub fn SDL_PauseAudio ( pause_on : ctypes :: c_int ) ; } extern "C" { pub fn SDL_PauseAudioDevice ( dev : SDL_AudioDeviceID , pause_on : ctypes :: c_int ) ; } extern "C" { 
 /// This function loads a WAVE from the data source, automatically freeing
/// that source if \c freesrc is non-zero.  For example, to load a WAVE file,
/// you could do:
/// \code
/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
/// \endcode
///
/// If this function succeeds, it returns the given SDL_AudioSpec,
/// filled with the audio data format of the wave data, and sets
/// \c *audio_buf to a malloc()'d buffer containing the audio data,
/// and sets \c *audio_len to the length of that audio buffer, in bytes.
/// You need to free the audio buffer with SDL_FreeWAV() when you are
/// done with it.
///
/// This function returns NULL and sets the SDL error message if the
/// wave file cannot be opened, uses an unknown data format, or is
/// corrupt.  Currently raw and MS-ADPCM WAVE files are supported. 
 pub fn SDL_LoadWAV_RW ( src : * mut SDL_RWops , freesrc : ctypes :: c_int , spec : * mut SDL_AudioSpec , audio_buf : * mut * mut Uint8 , audio_len : * mut Uint32 ) -> * mut SDL_AudioSpec ; } extern "C" { 
 /// This function frees data previously allocated with SDL_LoadWAV_RW() 
 pub fn SDL_FreeWAV ( audio_buf : * mut Uint8 ) ; } extern "C" { 
 /// This function takes a source format and rate and a destination format
/// and rate, and initializes the \c cvt structure with information needed
/// by SDL_ConvertAudio() to convert a buffer of audio data from one format
/// to the other. An unsupported format causes an error and -1 will be returned.
///
/// \return 0 if no conversion is needed, 1 if the audio filter is set up,
/// or -1 on error. 
 pub fn SDL_BuildAudioCVT ( cvt : * mut SDL_AudioCVT , src_format : SDL_AudioFormat , src_channels : Uint8 , src_rate : ctypes :: c_int , dst_format : SDL_AudioFormat , dst_channels : Uint8 , dst_rate : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Once you have initialized the \c cvt structure using SDL_BuildAudioCVT(),
/// created an audio buffer \c cvt->buf, and filled it with \c cvt->len bytes of
/// audio data in the source format, this function will convert it in-place
/// to the desired format.
///
/// The data conversion may expand the size of the audio data, so the buffer
/// \c cvt->buf should be allocated after the \c cvt structure is initialized by
/// SDL_BuildAudioCVT(), and should be \c cvt->len*cvt->len_mult bytes long.
///
/// \return 0 on success or -1 if \c cvt->buf is NULL. 
 pub fn SDL_ConvertAudio ( cvt : * mut SDL_AudioCVT ) -> ctypes :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _SDL_AudioStream { _unused : [ u8 ; 0 ] , } pub type SDL_AudioStream = _SDL_AudioStream ; extern "C" { 
 /// Create a new audio stream
///
/// \param src_format The format of the source audio
/// \param src_channels The number of channels of the source audio
/// \param src_rate The sampling rate of the source audio
/// \param dst_format The format of the desired audio output
/// \param dst_channels The number of channels of the desired audio output
/// \param dst_rate The sampling rate of the desired audio output
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_AudioStreamPut
/// \sa SDL_AudioStreamGet
/// \sa SDL_AudioStreamAvailable
/// \sa SDL_AudioStreamFlush
/// \sa SDL_AudioStreamClear
/// \sa SDL_FreeAudioStream 
 pub fn SDL_NewAudioStream ( src_format : SDL_AudioFormat , src_channels : Uint8 , src_rate : ctypes :: c_int , dst_format : SDL_AudioFormat , dst_channels : Uint8 , dst_rate : ctypes :: c_int ) -> * mut SDL_AudioStream ; } extern "C" { 
 /// Add data to be converted/resampled to the stream
///
/// \param stream The stream the audio data is being added to
/// \param buf A pointer to the audio data to add
/// \param len The number of bytes to write to the stream
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_NewAudioStream
/// \sa SDL_AudioStreamGet
/// \sa SDL_AudioStreamAvailable
/// \sa SDL_AudioStreamFlush
/// \sa SDL_AudioStreamClear
/// \sa SDL_FreeAudioStream 
 pub fn SDL_AudioStreamPut ( stream : * mut SDL_AudioStream , buf : * const ctypes :: c_void , len : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Get converted/resampled data from the stream
///
/// \param stream The stream the audio is being requested from
/// \param buf A buffer to fill with audio data
/// \param len The maximum number of bytes to fill
/// \return The number of bytes read from the stream, or -1 on error
///
/// \sa SDL_NewAudioStream
/// \sa SDL_AudioStreamPut
/// \sa SDL_AudioStreamAvailable
/// \sa SDL_AudioStreamFlush
/// \sa SDL_AudioStreamClear
/// \sa SDL_FreeAudioStream 
 pub fn SDL_AudioStreamGet ( stream : * mut SDL_AudioStream , buf : * mut ctypes :: c_void , len : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the number of converted/resampled bytes available. The stream may be
/// buffering data behind the scenes until it has enough to resample
/// correctly, so this number might be lower than what you expect, or even
/// be zero. Add more data or flush the stream if you need the data now.
///
/// \sa SDL_NewAudioStream
/// \sa SDL_AudioStreamPut
/// \sa SDL_AudioStreamGet
/// \sa SDL_AudioStreamFlush
/// \sa SDL_AudioStreamClear
/// \sa SDL_FreeAudioStream 
 pub fn SDL_AudioStreamAvailable ( stream : * mut SDL_AudioStream ) -> ctypes :: c_int ; } extern "C" { 
 /// Tell the stream that you're done sending data, and anything being buffered
/// should be converted/resampled and made available immediately.
///
/// It is legal to add more data to a stream after flushing, but there will
/// be audio gaps in the output. Generally this is intended to signal the
/// end of input, so the complete output becomes available.
///
/// \sa SDL_NewAudioStream
/// \sa SDL_AudioStreamPut
/// \sa SDL_AudioStreamGet
/// \sa SDL_AudioStreamAvailable
/// \sa SDL_AudioStreamClear
/// \sa SDL_FreeAudioStream 
 pub fn SDL_AudioStreamFlush ( stream : * mut SDL_AudioStream ) -> ctypes :: c_int ; } extern "C" { 
 /// Clear any pending data in the stream without converting it
///
/// \sa SDL_NewAudioStream
/// \sa SDL_AudioStreamPut
/// \sa SDL_AudioStreamGet
/// \sa SDL_AudioStreamAvailable
/// \sa SDL_AudioStreamFlush
/// \sa SDL_FreeAudioStream 
 pub fn SDL_AudioStreamClear ( stream : * mut SDL_AudioStream ) ; } extern "C" { 
 /// Free an audio stream
///
/// \sa SDL_NewAudioStream
/// \sa SDL_AudioStreamPut
/// \sa SDL_AudioStreamGet
/// \sa SDL_AudioStreamAvailable
/// \sa SDL_AudioStreamFlush
/// \sa SDL_AudioStreamClear 
 pub fn SDL_FreeAudioStream ( stream : * mut SDL_AudioStream ) ; } extern "C" { 
 /// This takes two audio buffers of the playing audio format and mixes
/// them, performing addition, volume adjustment, and overflow clipping.
/// The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME
/// for full audio volume.  Note this does not change hardware volume.
/// This is provided for convenience -- you can mix your own audio data. 
 pub fn SDL_MixAudio ( dst : * mut Uint8 , src : * const Uint8 , len : Uint32 , volume : ctypes :: c_int ) ; } extern "C" { 
 /// This works like SDL_MixAudio(), but you specify the audio format instead of
/// using the format of audio device 1. Thus it can be used when no audio
/// device is open at all. 
 pub fn SDL_MixAudioFormat ( dst : * mut Uint8 , src : * const Uint8 , format : SDL_AudioFormat , len : Uint32 , volume : ctypes :: c_int ) ; } extern "C" { 
 /// Queue more audio on non-callback devices.
///
/// (If you are looking to retrieve queued audio from a non-callback capture
/// device, you want SDL_DequeueAudio() instead. This will return -1 to
/// signify an error if you use it with capture devices.)
///
/// SDL offers two ways to feed audio to the device: you can either supply a
/// callback that SDL triggers with some frequency to obtain more audio
/// (pull method), or you can supply no callback, and then SDL will expect
/// you to supply data at regular intervals (push method) with this function.
///
/// There are no limits on the amount of data you can queue, short of
/// exhaustion of address space. Queued data will drain to the device as
/// necessary without further intervention from you. If the device needs
/// audio but there is not enough queued, it will play silence to make up
/// the difference. This means you will have skips in your audio playback
/// if you aren't routinely queueing sufficient data.
///
/// This function copies the supplied data, so you are safe to free it when
/// the function returns. This function is thread-safe, but queueing to the
/// same device from two threads at once does not promise which buffer will
/// be queued first.
///
/// You may not queue audio on a device that is using an application-supplied
/// callback; doing so returns an error. You have to use the audio callback
/// or queue audio with this function, but not both.
///
/// You should not call SDL_LockAudio() on the device before queueing; SDL
/// handles locking internally for this function.
///
/// \param dev The device ID to which we will queue audio.
/// \param data The data to queue to the device for later playback.
/// \param len The number of bytes (not samples!) to which (data) points.
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_GetQueuedAudioSize
/// \sa SDL_ClearQueuedAudio 
 pub fn SDL_QueueAudio ( dev : SDL_AudioDeviceID , data : * const ctypes :: c_void , len : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// Dequeue more audio on non-callback devices.
///
/// (If you are looking to queue audio for output on a non-callback playback
/// device, you want SDL_QueueAudio() instead. This will always return 0
/// if you use it with playback devices.)
///
/// SDL offers two ways to retrieve audio from a capture device: you can
/// either supply a callback that SDL triggers with some frequency as the
/// device records more audio data, (push method), or you can supply no
/// callback, and then SDL will expect you to retrieve data at regular
/// intervals (pull method) with this function.
///
/// There are no limits on the amount of data you can queue, short of
/// exhaustion of address space. Data from the device will keep queuing as
/// necessary without further intervention from you. This means you will
/// eventually run out of memory if you aren't routinely dequeueing data.
///
/// Capture devices will not queue data when paused; if you are expecting
/// to not need captured audio for some length of time, use
/// SDL_PauseAudioDevice() to stop the capture device from queueing more
/// data. This can be useful during, say, level loading times. When
/// unpaused, capture devices will start queueing data from that point,
/// having flushed any capturable data available while paused.
///
/// This function is thread-safe, but dequeueing from the same device from
/// two threads at once does not promise which thread will dequeued data
/// first.
///
/// You may not dequeue audio from a device that is using an
/// application-supplied callback; doing so returns an error. You have to use
/// the audio callback, or dequeue audio with this function, but not both.
///
/// You should not call SDL_LockAudio() on the device before queueing; SDL
/// handles locking internally for this function.
///
/// \param dev The device ID from which we will dequeue audio.
/// \param data A pointer into where audio data should be copied.
/// \param len The number of bytes (not samples!) to which (data) points.
/// \return number of bytes dequeued, which could be less than requested.
///
/// \sa SDL_GetQueuedAudioSize
/// \sa SDL_ClearQueuedAudio 
 pub fn SDL_DequeueAudio ( dev : SDL_AudioDeviceID , data : * mut ctypes :: c_void , len : Uint32 ) -> Uint32 ; } extern "C" { 
 /// Get the number of bytes of still-queued audio.
///
/// For playback device:
///
/// This is the number of bytes that have been queued for playback with
/// SDL_QueueAudio(), but have not yet been sent to the hardware. This
/// number may shrink at any time, so this only informs of pending data.
///
/// Once we've sent it to the hardware, this function can not decide the
/// exact byte boundary of what has been played. It's possible that we just
/// gave the hardware several kilobytes right before you called this
/// function, but it hasn't played any of it yet, or maybe half of it, etc.
///
/// For capture devices:
///
/// This is the number of bytes that have been captured by the device and
/// are waiting for you to dequeue. This number may grow at any time, so
/// this only informs of the lower-bound of available data.
///
/// You may not queue audio on a device that is using an application-supplied
/// callback; calling this function on such a device always returns 0.
/// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
/// the audio callback, but not both.
///
/// You should not call SDL_LockAudio() on the device before querying; SDL
/// handles locking internally for this function.
///
/// \param dev The device ID of which we will query queued audio size.
/// \return Number of bytes (not samples!) of queued audio.
///
/// \sa SDL_QueueAudio
/// \sa SDL_ClearQueuedAudio 
 pub fn SDL_GetQueuedAudioSize ( dev : SDL_AudioDeviceID ) -> Uint32 ; } extern "C" { 
 /// Drop any queued audio data. For playback devices, this is any queued data
/// still waiting to be submitted to the hardware. For capture devices, this
/// is any data that was queued by the device that hasn't yet been dequeued by
/// the application.
///
/// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
/// playback devices, the hardware will start playing silence if more audio
/// isn't queued. Unpaused capture devices will start filling the queue again
/// as soon as they have more data available (which, depending on the state
/// of the hardware and the thread, could be before this function call
/// returns!).
///
/// This will not prevent playback of queued audio that's already been sent
/// to the hardware, as we can not undo that, so expect there to be some
/// fraction of a second of audio that might still be heard. This can be
/// useful if you want to, say, drop any pending music during a level change
/// in your game.
///
/// You may not queue audio on a device that is using an application-supplied
/// callback; calling this function on such a device is always a no-op.
/// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
/// the audio callback, but not both.
///
/// You should not call SDL_LockAudio() on the device before clearing the
/// queue; SDL handles locking internally for this function.
///
/// This function always succeeds and thus returns void.
///
/// \param dev The device ID of which to clear the audio queue.
///
/// \sa SDL_QueueAudio
/// \sa SDL_GetQueuedAudioSize 
 pub fn SDL_ClearQueuedAudio ( dev : SDL_AudioDeviceID ) ; } extern "C" { pub fn SDL_LockAudio ( ) ; } extern "C" { pub fn SDL_LockAudioDevice ( dev : SDL_AudioDeviceID ) ; } extern "C" { pub fn SDL_UnlockAudio ( ) ; } extern "C" { pub fn SDL_UnlockAudioDevice ( dev : SDL_AudioDeviceID ) ; } extern "C" { 
 /// This function shuts down audio processing and closes the audio device. 
 pub fn SDL_CloseAudio ( ) ; } extern "C" { pub fn SDL_CloseAudioDevice ( dev : SDL_AudioDeviceID ) ; } extern "C" { 
 /// \brief Put UTF-8 text into the clipboard
///
/// \sa SDL_GetClipboardText() 
 pub fn SDL_SetClipboardText ( text : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()
///
/// \sa SDL_SetClipboardText() 
 pub fn SDL_GetClipboardText ( ) -> * mut ctypes :: c_char ; } extern "C" { 
 /// \brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty
///
/// \sa SDL_GetClipboardText() 
 pub fn SDL_HasClipboardText ( ) -> SDL_bool ; } pub type __m64 = [ ctypes :: c_longlong ; 1usize ] ; pub type __v1di = [ ctypes :: c_longlong ; 1usize ] ; pub type __v2si = [ ctypes :: c_int ; 2usize ] ; pub type __v4hi = [ ctypes :: c_short ; 4usize ] ; pub type __v8qi = [ ctypes :: c_char ; 8usize ] ; pub type __v4si = [ ctypes :: c_int ; 4usize ] ; pub type __v4sf = [ f32 ; 4usize ] ; pub type __m128 = [ f32 ; 4usize ] ; pub type __v4su = [ ctypes :: c_uint ; 4usize ] ; extern "C" { pub fn _mm_sfence ( ) ; } extern "C" { pub fn _mm_getcsr ( ) -> ctypes :: c_uint ; } extern "C" { pub fn _mm_setcsr ( __i : ctypes :: c_uint ) ; } pub type __m128d = [ f64 ; 2usize ] ; pub type __m128i = [ ctypes :: c_longlong ; 2usize ] ; pub type __v2df = [ f64 ; 2usize ] ; pub type __v2di = [ ctypes :: c_longlong ; 2usize ] ; pub type __v8hi = [ ctypes :: c_short ; 8usize ] ; pub type __v16qi = [ ctypes :: c_char ; 16usize ] ; pub type __v2du = [ ctypes :: c_ulonglong ; 2usize ] ; pub type __v8hu = [ ctypes :: c_ushort ; 8usize ] ; pub type __v16qu = [ ctypes :: c_uchar ; 16usize ] ; pub type __v16qs = [ ctypes :: c_schar ; 16usize ] ; extern "C" { pub fn _mm_clflush ( __p : * const ctypes :: c_void ) ; } extern "C" { pub fn _mm_lfence ( ) ; } extern "C" { pub fn _mm_mfence ( ) ; } extern "C" { pub fn _mm_pause ( ) ; } extern "C" { 
 /// This function returns the number of CPU cores available. 
 pub fn SDL_GetCPUCount ( ) -> ctypes :: c_int ; } extern "C" { 
 /// This function returns the L1 cache line size of the CPU
///
/// This is useful for determining multi-threaded structure padding
/// or SIMD prefetch sizes. 
 pub fn SDL_GetCPUCacheLineSize ( ) -> ctypes :: c_int ; } extern "C" { 
 /// This function returns true if the CPU has the RDTSC instruction. 
 pub fn SDL_HasRDTSC ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has AltiVec features. 
 pub fn SDL_HasAltiVec ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has MMX features. 
 pub fn SDL_HasMMX ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has 3DNow! features. 
 pub fn SDL_Has3DNow ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has SSE features. 
 pub fn SDL_HasSSE ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has SSE2 features. 
 pub fn SDL_HasSSE2 ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has SSE3 features. 
 pub fn SDL_HasSSE3 ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has SSE4.1 features. 
 pub fn SDL_HasSSE41 ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has SSE4.2 features. 
 pub fn SDL_HasSSE42 ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has AVX features. 
 pub fn SDL_HasAVX ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has AVX2 features. 
 pub fn SDL_HasAVX2 ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns true if the CPU has NEON (ARM SIMD) features. 
 pub fn SDL_HasNEON ( ) -> SDL_bool ; } extern "C" { 
 /// This function returns the amount of RAM configured in the system, in MB. 
 pub fn SDL_GetSystemRAM ( ) -> ctypes :: c_int ; } pub const SDL_PIXELTYPE_UNKNOWN : _bindgen_ty_1 = 0 ; pub const SDL_PIXELTYPE_INDEX1 : _bindgen_ty_1 = 1 ; pub const SDL_PIXELTYPE_INDEX4 : _bindgen_ty_1 = 2 ; pub const SDL_PIXELTYPE_INDEX8 : _bindgen_ty_1 = 3 ; pub const SDL_PIXELTYPE_PACKED8 : _bindgen_ty_1 = 4 ; pub const SDL_PIXELTYPE_PACKED16 : _bindgen_ty_1 = 5 ; pub const SDL_PIXELTYPE_PACKED32 : _bindgen_ty_1 = 6 ; pub const SDL_PIXELTYPE_ARRAYU8 : _bindgen_ty_1 = 7 ; pub const SDL_PIXELTYPE_ARRAYU16 : _bindgen_ty_1 = 8 ; pub const SDL_PIXELTYPE_ARRAYU32 : _bindgen_ty_1 = 9 ; pub const SDL_PIXELTYPE_ARRAYF16 : _bindgen_ty_1 = 10 ; pub const SDL_PIXELTYPE_ARRAYF32 : _bindgen_ty_1 = 11 ; 
 /// Pixel type. 
 pub type _bindgen_ty_1 = u32 ; pub const SDL_BITMAPORDER_NONE : _bindgen_ty_2 = 0 ; pub const SDL_BITMAPORDER_4321 : _bindgen_ty_2 = 1 ; pub const SDL_BITMAPORDER_1234 : _bindgen_ty_2 = 2 ; 
 /// Bitmap pixel order, high bit -> low bit. 
 pub type _bindgen_ty_2 = u32 ; pub const SDL_PACKEDORDER_NONE : _bindgen_ty_3 = 0 ; pub const SDL_PACKEDORDER_XRGB : _bindgen_ty_3 = 1 ; pub const SDL_PACKEDORDER_RGBX : _bindgen_ty_3 = 2 ; pub const SDL_PACKEDORDER_ARGB : _bindgen_ty_3 = 3 ; pub const SDL_PACKEDORDER_RGBA : _bindgen_ty_3 = 4 ; pub const SDL_PACKEDORDER_XBGR : _bindgen_ty_3 = 5 ; pub const SDL_PACKEDORDER_BGRX : _bindgen_ty_3 = 6 ; pub const SDL_PACKEDORDER_ABGR : _bindgen_ty_3 = 7 ; pub const SDL_PACKEDORDER_BGRA : _bindgen_ty_3 = 8 ; 
 /// Packed component order, high bit -> low bit. 
 pub type _bindgen_ty_3 = u32 ; pub const SDL_ARRAYORDER_NONE : _bindgen_ty_4 = 0 ; pub const SDL_ARRAYORDER_RGB : _bindgen_ty_4 = 1 ; pub const SDL_ARRAYORDER_RGBA : _bindgen_ty_4 = 2 ; pub const SDL_ARRAYORDER_ARGB : _bindgen_ty_4 = 3 ; pub const SDL_ARRAYORDER_BGR : _bindgen_ty_4 = 4 ; pub const SDL_ARRAYORDER_BGRA : _bindgen_ty_4 = 5 ; pub const SDL_ARRAYORDER_ABGR : _bindgen_ty_4 = 6 ; 
 /// Array component order, low byte -> high byte. 
 pub type _bindgen_ty_4 = u32 ; pub const SDL_PACKEDLAYOUT_NONE : _bindgen_ty_5 = 0 ; pub const SDL_PACKEDLAYOUT_332 : _bindgen_ty_5 = 1 ; pub const SDL_PACKEDLAYOUT_4444 : _bindgen_ty_5 = 2 ; pub const SDL_PACKEDLAYOUT_1555 : _bindgen_ty_5 = 3 ; pub const SDL_PACKEDLAYOUT_5551 : _bindgen_ty_5 = 4 ; pub const SDL_PACKEDLAYOUT_565 : _bindgen_ty_5 = 5 ; pub const SDL_PACKEDLAYOUT_8888 : _bindgen_ty_5 = 6 ; pub const SDL_PACKEDLAYOUT_2101010 : _bindgen_ty_5 = 7 ; pub const SDL_PACKEDLAYOUT_1010102 : _bindgen_ty_5 = 8 ; 
 /// Packed component layout. 
 pub type _bindgen_ty_5 = u32 ; pub const SDL_PIXELFORMAT_UNKNOWN : _bindgen_ty_6 = 0 ; pub const SDL_PIXELFORMAT_INDEX1LSB : _bindgen_ty_6 = 286261504 ; pub const SDL_PIXELFORMAT_INDEX1MSB : _bindgen_ty_6 = 287310080 ; pub const SDL_PIXELFORMAT_INDEX4LSB : _bindgen_ty_6 = 303039488 ; pub const SDL_PIXELFORMAT_INDEX4MSB : _bindgen_ty_6 = 304088064 ; pub const SDL_PIXELFORMAT_INDEX8 : _bindgen_ty_6 = 318769153 ; pub const SDL_PIXELFORMAT_RGB332 : _bindgen_ty_6 = 336660481 ; pub const SDL_PIXELFORMAT_RGB444 : _bindgen_ty_6 = 353504258 ; pub const SDL_PIXELFORMAT_RGB555 : _bindgen_ty_6 = 353570562 ; pub const SDL_PIXELFORMAT_BGR555 : _bindgen_ty_6 = 357764866 ; pub const SDL_PIXELFORMAT_ARGB4444 : _bindgen_ty_6 = 355602434 ; pub const SDL_PIXELFORMAT_RGBA4444 : _bindgen_ty_6 = 356651010 ; pub const SDL_PIXELFORMAT_ABGR4444 : _bindgen_ty_6 = 359796738 ; pub const SDL_PIXELFORMAT_BGRA4444 : _bindgen_ty_6 = 360845314 ; pub const SDL_PIXELFORMAT_ARGB1555 : _bindgen_ty_6 = 355667970 ; pub const SDL_PIXELFORMAT_RGBA5551 : _bindgen_ty_6 = 356782082 ; pub const SDL_PIXELFORMAT_ABGR1555 : _bindgen_ty_6 = 359862274 ; pub const SDL_PIXELFORMAT_BGRA5551 : _bindgen_ty_6 = 360976386 ; pub const SDL_PIXELFORMAT_RGB565 : _bindgen_ty_6 = 353701890 ; pub const SDL_PIXELFORMAT_BGR565 : _bindgen_ty_6 = 357896194 ; pub const SDL_PIXELFORMAT_RGB24 : _bindgen_ty_6 = 386930691 ; pub const SDL_PIXELFORMAT_BGR24 : _bindgen_ty_6 = 390076419 ; pub const SDL_PIXELFORMAT_RGB888 : _bindgen_ty_6 = 370546692 ; pub const SDL_PIXELFORMAT_RGBX8888 : _bindgen_ty_6 = 371595268 ; pub const SDL_PIXELFORMAT_BGR888 : _bindgen_ty_6 = 374740996 ; pub const SDL_PIXELFORMAT_BGRX8888 : _bindgen_ty_6 = 375789572 ; pub const SDL_PIXELFORMAT_ARGB8888 : _bindgen_ty_6 = 372645892 ; pub const SDL_PIXELFORMAT_RGBA8888 : _bindgen_ty_6 = 373694468 ; pub const SDL_PIXELFORMAT_ABGR8888 : _bindgen_ty_6 = 376840196 ; pub const SDL_PIXELFORMAT_BGRA8888 : _bindgen_ty_6 = 377888772 ; pub const SDL_PIXELFORMAT_ARGB2101010 : _bindgen_ty_6 = 372711428 ; pub const SDL_PIXELFORMAT_RGBA32 : _bindgen_ty_6 = 376840196 ; pub const SDL_PIXELFORMAT_ARGB32 : _bindgen_ty_6 = 377888772 ; pub const SDL_PIXELFORMAT_BGRA32 : _bindgen_ty_6 = 372645892 ; pub const SDL_PIXELFORMAT_ABGR32 : _bindgen_ty_6 = 373694468 ; 
 /// < Planar mode: Y + V + U  (3 planes) 
 pub const SDL_PIXELFORMAT_YV12 : _bindgen_ty_6 = 842094169 ; 
 /// < Planar mode: Y + U + V  (3 planes) 
 pub const SDL_PIXELFORMAT_IYUV : _bindgen_ty_6 = 1448433993 ; 
 /// < Packed mode: Y0+U0+Y1+V0 (1 plane) 
 pub const SDL_PIXELFORMAT_YUY2 : _bindgen_ty_6 = 844715353 ; 
 /// < Packed mode: U0+Y0+V0+Y1 (1 plane) 
 pub const SDL_PIXELFORMAT_UYVY : _bindgen_ty_6 = 1498831189 ; 
 /// < Packed mode: Y0+V0+Y1+U0 (1 plane) 
 pub const SDL_PIXELFORMAT_YVYU : _bindgen_ty_6 = 1431918169 ; 
 /// < Planar mode: Y + U/V interleaved  (2 planes) 
 pub const SDL_PIXELFORMAT_NV12 : _bindgen_ty_6 = 842094158 ; 
 /// < Planar mode: Y + V/U interleaved  (2 planes) 
 pub const SDL_PIXELFORMAT_NV21 : _bindgen_ty_6 = 825382478 ; 
 /// < Android video texture format 
 pub const SDL_PIXELFORMAT_EXTERNAL_OES : _bindgen_ty_6 = 542328143 ; pub type _bindgen_ty_6 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Color { pub r : Uint8 , pub g : Uint8 , pub b : Uint8 , pub a : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_Color ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Color > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( SDL_Color ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Color > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_Color ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Color > ( ) ) ) . r as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Color ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Color > ( ) ) ) . g as * const _ as usize } , 1usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Color ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Color > ( ) ) ) . b as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Color ) , "::" , stringify ! ( b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Color > ( ) ) ) . a as * const _ as usize } , 3usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Color ) , "::" , stringify ! ( a ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Palette { pub ncolors : ctypes :: c_int , pub colors : * mut SDL_Color , pub version : Uint32 , pub refcount : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_Palette ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Palette > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_Palette ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Palette > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_Palette ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Palette > ( ) ) ) . ncolors as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Palette ) , "::" , stringify ! ( ncolors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Palette > ( ) ) ) . colors as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Palette ) , "::" , stringify ! ( colors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Palette > ( ) ) ) . version as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Palette ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Palette > ( ) ) ) . refcount as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Palette ) , "::" , stringify ! ( refcount ) ) ) ; } 
 /// \note Everything in the pixel format structure is read-only. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_PixelFormat { pub format : Uint32 , pub palette : * mut SDL_Palette , pub BitsPerPixel : Uint8 , pub BytesPerPixel : Uint8 , pub padding : [ Uint8 ; 2usize ] , pub Rmask : Uint32 , pub Gmask : Uint32 , pub Bmask : Uint32 , pub Amask : Uint32 , pub Rloss : Uint8 , pub Gloss : Uint8 , pub Bloss : Uint8 , pub Aloss : Uint8 , pub Rshift : Uint8 , pub Gshift : Uint8 , pub Bshift : Uint8 , pub Ashift : Uint8 , pub refcount : ctypes :: c_int , pub next : * mut SDL_PixelFormat , } # [ test ] fn bindgen_test_layout_SDL_PixelFormat ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_PixelFormat > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SDL_PixelFormat ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_PixelFormat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_PixelFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . format as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . palette as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( palette ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . BitsPerPixel as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( BitsPerPixel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . BytesPerPixel as * const _ as usize } , 17usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( BytesPerPixel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . padding as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Rmask as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Rmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Gmask as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Gmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Bmask as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Bmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Amask as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Amask ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Rloss as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Rloss ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Gloss as * const _ as usize } , 37usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Gloss ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Bloss as * const _ as usize } , 38usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Bloss ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Aloss as * const _ as usize } , 39usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Aloss ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Rshift as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Rshift ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Gshift as * const _ as usize } , 41usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Gshift ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Bshift as * const _ as usize } , 42usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Bshift ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . Ashift as * const _ as usize } , 43usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( Ashift ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . refcount as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( refcount ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_PixelFormat > ( ) ) ) . next as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_PixelFormat ) , "::" , stringify ! ( next ) ) ) ; } extern "C" { 
 /// \brief Get the human readable name of a pixel format 
 pub fn SDL_GetPixelFormatName ( format : Uint32 ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Convert one of the enumerated pixel formats to a bpp and RGBA masks.
///
/// \return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.
///
/// \sa SDL_MasksToPixelFormatEnum() 
 pub fn SDL_PixelFormatEnumToMasks ( format : Uint32 , bpp : * mut ctypes :: c_int , Rmask : * mut Uint32 , Gmask : * mut Uint32 , Bmask : * mut Uint32 , Amask : * mut Uint32 ) -> SDL_bool ; } extern "C" { 
 /// \brief Convert a bpp and RGBA masks to an enumerated pixel format.
///
/// \return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion
/// wasn't possible.
///
/// \sa SDL_PixelFormatEnumToMasks() 
 pub fn SDL_MasksToPixelFormatEnum ( bpp : ctypes :: c_int , Rmask : Uint32 , Gmask : Uint32 , Bmask : Uint32 , Amask : Uint32 ) -> Uint32 ; } extern "C" { 
 /// \brief Create an SDL_PixelFormat structure from a pixel format enum. 
 pub fn SDL_AllocFormat ( pixel_format : Uint32 ) -> * mut SDL_PixelFormat ; } extern "C" { 
 /// \brief Free an SDL_PixelFormat structure. 
 pub fn SDL_FreeFormat ( format : * mut SDL_PixelFormat ) ; } extern "C" { 
 /// \brief Create a palette structure with the specified number of color
/// entries.
///
/// \return A new palette, or NULL if there wasn't enough memory.
///
/// \note The palette entries are initialized to white.
///
/// \sa SDL_FreePalette() 
 pub fn SDL_AllocPalette ( ncolors : ctypes :: c_int ) -> * mut SDL_Palette ; } extern "C" { 
 /// \brief Set the palette for a pixel format structure. 
 pub fn SDL_SetPixelFormatPalette ( format : * mut SDL_PixelFormat , palette : * mut SDL_Palette ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set a range of colors in a palette.
///
/// \param palette    The palette to modify.
/// \param colors     An array of colors to copy into the palette.
/// \param firstcolor The index of the first palette entry to modify.
/// \param ncolors    The number of entries to modify.
///
/// \return 0 on success, or -1 if not all of the colors could be set. 
 pub fn SDL_SetPaletteColors ( palette : * mut SDL_Palette , colors : * const SDL_Color , firstcolor : ctypes :: c_int , ncolors : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Free a palette created with SDL_AllocPalette().
///
/// \sa SDL_AllocPalette() 
 pub fn SDL_FreePalette ( palette : * mut SDL_Palette ) ; } extern "C" { 
 /// \brief Maps an RGB triple to an opaque pixel value for a given pixel format.
///
/// \sa SDL_MapRGBA 
 pub fn SDL_MapRGB ( format : * const SDL_PixelFormat , r : Uint8 , g : Uint8 , b : Uint8 ) -> Uint32 ; } extern "C" { 
 /// \brief Maps an RGBA quadruple to a pixel value for a given pixel format.
///
/// \sa SDL_MapRGB 
 pub fn SDL_MapRGBA ( format : * const SDL_PixelFormat , r : Uint8 , g : Uint8 , b : Uint8 , a : Uint8 ) -> Uint32 ; } extern "C" { 
 /// \brief Get the RGB components from a pixel of the specified format.
///
/// \sa SDL_GetRGBA 
 pub fn SDL_GetRGB ( pixel : Uint32 , format : * const SDL_PixelFormat , r : * mut Uint8 , g : * mut Uint8 , b : * mut Uint8 ) ; } extern "C" { 
 /// \brief Get the RGBA components from a pixel of the specified format.
///
/// \sa SDL_GetRGB 
 pub fn SDL_GetRGBA ( pixel : Uint32 , format : * const SDL_PixelFormat , r : * mut Uint8 , g : * mut Uint8 , b : * mut Uint8 , a : * mut Uint8 ) ; } extern "C" { 
 /// \brief Calculate a 256 entry gamma ramp for a gamma value. 
 pub fn SDL_CalculateGammaRamp ( gamma : f32 , ramp : * mut Uint16 ) ; } 
 /// \brief  The structure that defines a point
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Point { pub x : ctypes :: c_int , pub y : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_Point ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Point > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_Point ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Point > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_Point ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Point > ( ) ) ) . x as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Point ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Point > ( ) ) ) . y as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Point ) , "::" , stringify ! ( y ) ) ) ; } 
 /// \brief A rectangle, with the origin at the upper left.
///
/// \sa SDL_RectEmpty
/// \sa SDL_RectEquals
/// \sa SDL_HasIntersection
/// \sa SDL_IntersectRect
/// \sa SDL_UnionRect
/// \sa SDL_EnclosePoints 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Rect { pub x : ctypes :: c_int , pub y : ctypes :: c_int , pub w : ctypes :: c_int , pub h : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_Rect ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Rect > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_Rect ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Rect > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_Rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Rect > ( ) ) ) . x as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Rect ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Rect > ( ) ) ) . y as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Rect ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Rect > ( ) ) ) . w as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Rect ) , "::" , stringify ! ( w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Rect > ( ) ) ) . h as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Rect ) , "::" , stringify ! ( h ) ) ) ; } extern "C" { 
 /// \brief Determine whether two rectangles intersect.
///
/// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise. 
 pub fn SDL_HasIntersection ( A : * const SDL_Rect , B : * const SDL_Rect ) -> SDL_bool ; } extern "C" { 
 /// \brief Calculate the intersection of two rectangles.
///
/// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise. 
 pub fn SDL_IntersectRect ( A : * const SDL_Rect , B : * const SDL_Rect , result : * mut SDL_Rect ) -> SDL_bool ; } extern "C" { 
 /// \brief Calculate the union of two rectangles. 
 pub fn SDL_UnionRect ( A : * const SDL_Rect , B : * const SDL_Rect , result : * mut SDL_Rect ) ; } extern "C" { 
 /// \brief Calculate a minimal rectangle enclosing a set of points
///
/// \return SDL_TRUE if any points were within the clipping rect 
 pub fn SDL_EnclosePoints ( points : * const SDL_Point , count : ctypes :: c_int , clip : * const SDL_Rect , result : * mut SDL_Rect ) -> SDL_bool ; } extern "C" { 
 /// \brief Calculate the intersection of a rectangle and line segment.
///
/// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise. 
 pub fn SDL_IntersectRectAndLine ( rect : * const SDL_Rect , X1 : * mut ctypes :: c_int , Y1 : * mut ctypes :: c_int , X2 : * mut ctypes :: c_int , Y2 : * mut ctypes :: c_int ) -> SDL_bool ; } 
 /// < no blending
/// dstRGBA = srcRGBA 
 pub const SDL_BlendMode_SDL_BLENDMODE_NONE : SDL_BlendMode = 0 ; 
 /// < alpha blending
/// dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
/// dstA = srcA + (dstA * (1-srcA)) 
 pub const SDL_BlendMode_SDL_BLENDMODE_BLEND : SDL_BlendMode = 1 ; 
 /// < additive blending
/// dstRGB = (srcRGB * srcA) + dstRGB
/// dstA = dstA 
 pub const SDL_BlendMode_SDL_BLENDMODE_ADD : SDL_BlendMode = 2 ; 
 /// < color modulate
/// dstRGB = srcRGB * dstRGB
/// dstA = dstA 
 pub const SDL_BlendMode_SDL_BLENDMODE_MOD : SDL_BlendMode = 4 ; pub const SDL_BlendMode_SDL_BLENDMODE_INVALID : SDL_BlendMode = 2147483647 ; 
 /// \brief The blend mode used in SDL_RenderCopy() and drawing operations. 
 pub type SDL_BlendMode = u32 ; 
 /// < dst + src: supported by all renderers 
 pub const SDL_BlendOperation_SDL_BLENDOPERATION_ADD : SDL_BlendOperation = 1 ; 
 /// < dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES 
 pub const SDL_BlendOperation_SDL_BLENDOPERATION_SUBTRACT : SDL_BlendOperation = 2 ; 
 /// < src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES 
 pub const SDL_BlendOperation_SDL_BLENDOPERATION_REV_SUBTRACT : SDL_BlendOperation = 3 ; 
 /// < min(dst, src) : supported by D3D11 
 pub const SDL_BlendOperation_SDL_BLENDOPERATION_MINIMUM : SDL_BlendOperation = 4 ; 
 /// < max(dst, src) : supported by D3D11 
 pub const SDL_BlendOperation_SDL_BLENDOPERATION_MAXIMUM : SDL_BlendOperation = 5 ; 
 /// \brief The blend operation used when combining source and destination pixel components 
 pub type SDL_BlendOperation = u32 ; 
 /// < 0, 0, 0, 0 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_ZERO : SDL_BlendFactor = 1 ; 
 /// < 1, 1, 1, 1 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE : SDL_BlendFactor = 2 ; 
 /// < srcR, srcG, srcB, srcA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_COLOR : SDL_BlendFactor = 3 ; 
 /// < 1-srcR, 1-srcG, 1-srcB, 1-srcA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR : SDL_BlendFactor = 4 ; 
 /// < srcA, srcA, srcA, srcA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_ALPHA : SDL_BlendFactor = 5 ; 
 /// < 1-srcA, 1-srcA, 1-srcA, 1-srcA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA : SDL_BlendFactor = 6 ; 
 /// < dstR, dstG, dstB, dstA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_COLOR : SDL_BlendFactor = 7 ; 
 /// < 1-dstR, 1-dstG, 1-dstB, 1-dstA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR : SDL_BlendFactor = 8 ; 
 /// < dstA, dstA, dstA, dstA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_ALPHA : SDL_BlendFactor = 9 ; 
 /// < 1-dstA, 1-dstA, 1-dstA, 1-dstA 
 pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA : SDL_BlendFactor = 10 ; 
 /// \brief The normalized factor used to multiply pixel components 
 pub type SDL_BlendFactor = u32 ; extern "C" { 
 /// \brief Create a custom blend mode, which may or may not be supported by a given renderer
///
/// \param srcColorFactor
/// \param dstColorFactor
/// \param colorOperation
/// \param srcAlphaFactor
/// \param dstAlphaFactor
/// \param alphaOperation
///
/// The result of the blend mode operation will be:
/// dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor
/// and
/// dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor 
 pub fn SDL_ComposeCustomBlendMode ( srcColorFactor : SDL_BlendFactor , dstColorFactor : SDL_BlendFactor , colorOperation : SDL_BlendOperation , srcAlphaFactor : SDL_BlendFactor , dstAlphaFactor : SDL_BlendFactor , alphaOperation : SDL_BlendOperation ) -> SDL_BlendMode ; } 
 /// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
/// which, if not NULL, contains the raw pixel data for the surface. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Surface { 
 /// < Read-only 
 pub flags : Uint32 , 
 /// < Read-only 
 pub format : * mut SDL_PixelFormat , 
 /// < Read-only 
 pub w : ctypes :: c_int , 
 /// < Read-only 
 pub h : ctypes :: c_int , 
 /// < Read-only 
 pub pitch : ctypes :: c_int , 
 /// < Read-write 
 pub pixels : * mut ctypes :: c_void , 
 /// < Read-write 
 pub userdata : * mut ctypes :: c_void , 
 /// < Read-only 
 pub locked : ctypes :: c_int , 
 /// < Read-only 
 pub lock_data : * mut ctypes :: c_void , 
 /// < Read-only 
 pub clip_rect : SDL_Rect , 
 /// < Private 
 pub map : * mut SDL_BlitMap , 
 /// < Read-mostly 
 pub refcount : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_Surface ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Surface > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( SDL_Surface ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Surface > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_Surface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . format as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . w as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . h as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( h ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . pitch as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( pitch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . pixels as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( pixels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . userdata as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( userdata ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . locked as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( locked ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . lock_data as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( lock_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . clip_rect as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( clip_rect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . map as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( map ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Surface > ( ) ) ) . refcount as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Surface ) , "::" , stringify ! ( refcount ) ) ) ; } 
 /// \brief The type of function used for surface blitting functions. 
 pub type SDL_blit = :: core :: option :: Option < unsafe extern "C" fn ( src : * mut SDL_Surface , srcrect : * mut SDL_Rect , dst : * mut SDL_Surface , dstrect : * mut SDL_Rect ) -> ctypes :: c_int > ; 
 /// < Full range JPEG 
 pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_JPEG : SDL_YUV_CONVERSION_MODE = 0 ; 
 /// < BT.601 (the default) 
 pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_BT601 : SDL_YUV_CONVERSION_MODE = 1 ; 
 /// < BT.709 
 pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_BT709 : SDL_YUV_CONVERSION_MODE = 2 ; 
 /// < BT.601 for SD content, BT.709 for HD content 
 pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_AUTOMATIC : SDL_YUV_CONVERSION_MODE = 3 ; 
 /// \brief The formula used for converting between YUV and RGB 
 pub type SDL_YUV_CONVERSION_MODE = u32 ; extern "C" { 
 /// Allocate and free an RGB surface.
///
/// If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
/// If the depth is greater than 8 bits, the pixel format is set using the
/// flags '[RGB]mask'.
///
/// If the function runs out of memory, it will return NULL.
///
/// \param flags The \c flags are obsolete and should be set to 0.
/// \param width The width in pixels of the surface to create.
/// \param height The height in pixels of the surface to create.
/// \param depth The depth in bits of the surface to create.
/// \param Rmask The red mask of the surface to create.
/// \param Gmask The green mask of the surface to create.
/// \param Bmask The blue mask of the surface to create.
/// \param Amask The alpha mask of the surface to create. 
 pub fn SDL_CreateRGBSurface ( flags : Uint32 , width : ctypes :: c_int , height : ctypes :: c_int , depth : ctypes :: c_int , Rmask : Uint32 , Gmask : Uint32 , Bmask : Uint32 , Amask : Uint32 ) -> * mut SDL_Surface ; } extern "C" { pub fn SDL_CreateRGBSurfaceWithFormat ( flags : Uint32 , width : ctypes :: c_int , height : ctypes :: c_int , depth : ctypes :: c_int , format : Uint32 ) -> * mut SDL_Surface ; } extern "C" { pub fn SDL_CreateRGBSurfaceFrom ( pixels : * mut ctypes :: c_void , width : ctypes :: c_int , height : ctypes :: c_int , depth : ctypes :: c_int , pitch : ctypes :: c_int , Rmask : Uint32 , Gmask : Uint32 , Bmask : Uint32 , Amask : Uint32 ) -> * mut SDL_Surface ; } extern "C" { pub fn SDL_CreateRGBSurfaceWithFormatFrom ( pixels : * mut ctypes :: c_void , width : ctypes :: c_int , height : ctypes :: c_int , depth : ctypes :: c_int , pitch : ctypes :: c_int , format : Uint32 ) -> * mut SDL_Surface ; } extern "C" { pub fn SDL_FreeSurface ( surface : * mut SDL_Surface ) ; } extern "C" { 
 /// \brief Set the palette used by a surface.
///
/// \return 0, or -1 if the surface format doesn't use a palette.
///
/// \note A single palette can be shared with many surfaces. 
 pub fn SDL_SetSurfacePalette ( surface : * mut SDL_Surface , palette : * mut SDL_Palette ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Sets up a surface for directly accessing the pixels.
///
/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write
/// to and read from \c surface->pixels, using the pixel format stored in
/// \c surface->format.  Once you are done accessing the surface, you should
/// use SDL_UnlockSurface() to release it.
///
/// Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates
/// to 0, then you can read and write to the surface at any time, and the
/// pixel format of the surface will not change.
///
/// No operating system or library calls should be made between lock/unlock
/// pairs, as critical system locks may be held during this time.
///
/// SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.
///
/// \sa SDL_UnlockSurface() 
 pub fn SDL_LockSurface ( surface : * mut SDL_Surface ) -> ctypes :: c_int ; } extern "C" { 
 /// \sa SDL_LockSurface() 
 pub fn SDL_UnlockSurface ( surface : * mut SDL_Surface ) ; } extern "C" { 
 /// Load a surface from a seekable SDL data stream (memory or file).
///
/// If \c freesrc is non-zero, the stream will be closed after being read.
///
/// The new surface should be freed with SDL_FreeSurface().
///
/// \return the new surface, or NULL if there was an error. 
 pub fn SDL_LoadBMP_RW ( src : * mut SDL_RWops , freesrc : ctypes :: c_int ) -> * mut SDL_Surface ; } extern "C" { 
 /// Save a surface to a seekable SDL data stream (memory or file).
///
/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
/// BMP directly. Other RGB formats with 8-bit or higher get converted to a
/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
/// not supported.
///
/// If \c freedst is non-zero, the stream will be closed after being written.
///
/// \return 0 if successful or -1 if there was an error. 
 pub fn SDL_SaveBMP_RW ( surface : * mut SDL_Surface , dst : * mut SDL_RWops , freedst : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Sets the RLE acceleration hint for a surface.
///
/// \return 0 on success, or -1 if the surface is not valid
///
/// \note If RLE is enabled, colorkey and alpha blending blits are much faster,
/// but the surface must be locked before directly accessing the pixels. 
 pub fn SDL_SetSurfaceRLE ( surface : * mut SDL_Surface , flag : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Sets the color key (transparent pixel) in a blittable surface.
///
/// \param surface The surface to update
/// \param flag Non-zero to enable colorkey and 0 to disable colorkey
/// \param key The transparent pixel in the native surface format
///
/// \return 0 on success, or -1 if the surface is not valid
///
/// You can pass SDL_RLEACCEL to enable RLE accelerated blits. 
 pub fn SDL_SetColorKey ( surface : * mut SDL_Surface , flag : ctypes :: c_int , key : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Gets the color key (transparent pixel) in a blittable surface.
///
/// \param surface The surface to update
/// \param key A pointer filled in with the transparent pixel in the native
/// surface format
///
/// \return 0 on success, or -1 if the surface is not valid or colorkey is not
/// enabled. 
 pub fn SDL_GetColorKey ( surface : * mut SDL_Surface , key : * mut Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set an additional color value used in blit operations.
///
/// \param surface The surface to update.
/// \param r The red color value multiplied into blit operations.
/// \param g The green color value multiplied into blit operations.
/// \param b The blue color value multiplied into blit operations.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_GetSurfaceColorMod() 
 pub fn SDL_SetSurfaceColorMod ( surface : * mut SDL_Surface , r : Uint8 , g : Uint8 , b : Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the additional color value used in blit operations.
///
/// \param surface The surface to query.
/// \param r A pointer filled in with the current red color value.
/// \param g A pointer filled in with the current green color value.
/// \param b A pointer filled in with the current blue color value.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_SetSurfaceColorMod() 
 pub fn SDL_GetSurfaceColorMod ( surface : * mut SDL_Surface , r : * mut Uint8 , g : * mut Uint8 , b : * mut Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set an additional alpha value used in blit operations.
///
/// \param surface The surface to update.
/// \param alpha The alpha value multiplied into blit operations.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_GetSurfaceAlphaMod() 
 pub fn SDL_SetSurfaceAlphaMod ( surface : * mut SDL_Surface , alpha : Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the additional alpha value used in blit operations.
///
/// \param surface The surface to query.
/// \param alpha A pointer filled in with the current alpha value.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_SetSurfaceAlphaMod() 
 pub fn SDL_GetSurfaceAlphaMod ( surface : * mut SDL_Surface , alpha : * mut Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the blend mode used for blit operations.
///
/// \param surface The surface to update.
/// \param blendMode ::SDL_BlendMode to use for blit blending.
///
/// \return 0 on success, or -1 if the parameters are not valid.
///
/// \sa SDL_GetSurfaceBlendMode() 
 pub fn SDL_SetSurfaceBlendMode ( surface : * mut SDL_Surface , blendMode : SDL_BlendMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the blend mode used for blit operations.
///
/// \param surface   The surface to query.
/// \param blendMode A pointer filled in with the current blend mode.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_SetSurfaceBlendMode() 
 pub fn SDL_GetSurfaceBlendMode ( surface : * mut SDL_Surface , blendMode : * mut SDL_BlendMode ) -> ctypes :: c_int ; } extern "C" { 
 /// Sets the clipping rectangle for the destination surface in a blit.
///
/// If the clip rectangle is NULL, clipping will be disabled.
///
/// If the clip rectangle doesn't intersect the surface, the function will
/// return SDL_FALSE and blits will be completely clipped.  Otherwise the
/// function returns SDL_TRUE and blits to the surface will be clipped to
/// the intersection of the surface area and the clipping rectangle.
///
/// Note that blits are automatically clipped to the edges of the source
/// and destination surfaces. 
 pub fn SDL_SetClipRect ( surface : * mut SDL_Surface , rect : * const SDL_Rect ) -> SDL_bool ; } extern "C" { 
 /// Gets the clipping rectangle for the destination surface in a blit.
///
/// \c rect must be a pointer to a valid rectangle which will be filled
/// with the correct values. 
 pub fn SDL_GetClipRect ( surface : * mut SDL_Surface , rect : * mut SDL_Rect ) ; } extern "C" { pub fn SDL_DuplicateSurface ( surface : * mut SDL_Surface ) -> * mut SDL_Surface ; } extern "C" { 
 /// Creates a new surface of the specified format, and then copies and maps
/// the given surface to it so the blit of the converted surface will be as
/// fast as possible.  If this function fails, it returns NULL.
///
/// The \c flags parameter is passed to SDL_CreateRGBSurface() and has those
/// semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and
/// SDL will try to RLE accelerate colorkey and alpha blits in the resulting
/// surface. 
 pub fn SDL_ConvertSurface ( src : * mut SDL_Surface , fmt : * const SDL_PixelFormat , flags : Uint32 ) -> * mut SDL_Surface ; } extern "C" { pub fn SDL_ConvertSurfaceFormat ( src : * mut SDL_Surface , pixel_format : Uint32 , flags : Uint32 ) -> * mut SDL_Surface ; } extern "C" { 
 /// \brief Copy a block of pixels of one format to another format
///
/// \return 0 on success, or -1 if there was an error 
 pub fn SDL_ConvertPixels ( width : ctypes :: c_int , height : ctypes :: c_int , src_format : Uint32 , src : * const ctypes :: c_void , src_pitch : ctypes :: c_int , dst_format : Uint32 , dst : * mut ctypes :: c_void , dst_pitch : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Performs a fast fill of the given rectangle with \c color.
///
/// If \c rect is NULL, the whole surface will be filled with \c color.
///
/// The color should be a pixel of the format used by the surface, and
/// can be generated by the SDL_MapRGB() function.
///
/// \return 0 on success, or -1 on error. 
 pub fn SDL_FillRect ( dst : * mut SDL_Surface , rect : * const SDL_Rect , color : Uint32 ) -> ctypes :: c_int ; } extern "C" { pub fn SDL_FillRects ( dst : * mut SDL_Surface , rects : * const SDL_Rect , count : ctypes :: c_int , color : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// This is the public blit function, SDL_BlitSurface(), and it performs
/// rectangle validation and clipping before passing it to SDL_LowerBlit() 
 pub fn SDL_UpperBlit ( src : * mut SDL_Surface , srcrect : * const SDL_Rect , dst : * mut SDL_Surface , dstrect : * mut SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// This is a semi-private blit function and it performs low-level surface
/// blitting only. 
 pub fn SDL_LowerBlit ( src : * mut SDL_Surface , srcrect : * mut SDL_Rect , dst : * mut SDL_Surface , dstrect : * mut SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Perform a fast, low quality, stretch blit between two surfaces of the
/// same pixel format.
///
/// \note This function uses a static buffer, and is not thread-safe. 
 pub fn SDL_SoftStretch ( src : * mut SDL_Surface , srcrect : * const SDL_Rect , dst : * mut SDL_Surface , dstrect : * const SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// This is the public scaled blit function, SDL_BlitScaled(), and it performs
/// rectangle validation and clipping before passing it to SDL_LowerBlitScaled() 
 pub fn SDL_UpperBlitScaled ( src : * mut SDL_Surface , srcrect : * const SDL_Rect , dst : * mut SDL_Surface , dstrect : * mut SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// This is a semi-private blit function and it performs low-level surface
/// scaled blitting only. 
 pub fn SDL_LowerBlitScaled ( src : * mut SDL_Surface , srcrect : * mut SDL_Rect , dst : * mut SDL_Surface , dstrect : * mut SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the YUV conversion mode 
 pub fn SDL_SetYUVConversionMode ( mode : SDL_YUV_CONVERSION_MODE ) ; } extern "C" { 
 /// \brief Get the YUV conversion mode 
 pub fn SDL_GetYUVConversionMode ( ) -> SDL_YUV_CONVERSION_MODE ; } extern "C" { 
 /// \brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC 
 pub fn SDL_GetYUVConversionModeForResolution ( width : ctypes :: c_int , height : ctypes :: c_int ) -> SDL_YUV_CONVERSION_MODE ; } 
 /// \brief  The structure that defines a display mode
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
/// \sa SDL_GetDesktopDisplayMode()
/// \sa SDL_GetCurrentDisplayMode()
/// \sa SDL_GetClosestDisplayMode()
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode() 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_DisplayMode { 
 /// < pixel format 
 pub format : Uint32 , 
 /// < width, in screen coordinates 
 pub w : ctypes :: c_int , 
 /// < height, in screen coordinates 
 pub h : ctypes :: c_int , 
 /// < refresh rate (or zero for unspecified) 
 pub refresh_rate : ctypes :: c_int , 
 /// < driver-specific data, initialize to 0 
 pub driverdata : * mut ctypes :: c_void , } # [ test ] fn bindgen_test_layout_SDL_DisplayMode ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_DisplayMode > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_DisplayMode ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_DisplayMode > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_DisplayMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DisplayMode > ( ) ) ) . format as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DisplayMode ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DisplayMode > ( ) ) ) . w as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DisplayMode ) , "::" , stringify ! ( w ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DisplayMode > ( ) ) ) . h as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DisplayMode ) , "::" , stringify ! ( h ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DisplayMode > ( ) ) ) . refresh_rate as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DisplayMode ) , "::" , stringify ! ( refresh_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DisplayMode > ( ) ) ) . driverdata as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DisplayMode ) , "::" , stringify ! ( driverdata ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Window { _unused : [ u8 ; 0 ] , } 
 /// < fullscreen window 
 pub const SDL_WindowFlags_SDL_WINDOW_FULLSCREEN : SDL_WindowFlags = 1 ; 
 /// < window usable with OpenGL context 
 pub const SDL_WindowFlags_SDL_WINDOW_OPENGL : SDL_WindowFlags = 2 ; 
 /// < window is visible 
 pub const SDL_WindowFlags_SDL_WINDOW_SHOWN : SDL_WindowFlags = 4 ; 
 /// < window is not visible 
 pub const SDL_WindowFlags_SDL_WINDOW_HIDDEN : SDL_WindowFlags = 8 ; 
 /// < no window decoration 
 pub const SDL_WindowFlags_SDL_WINDOW_BORDERLESS : SDL_WindowFlags = 16 ; 
 /// < window can be resized 
 pub const SDL_WindowFlags_SDL_WINDOW_RESIZABLE : SDL_WindowFlags = 32 ; 
 /// < window is minimized 
 pub const SDL_WindowFlags_SDL_WINDOW_MINIMIZED : SDL_WindowFlags = 64 ; 
 /// < window is maximized 
 pub const SDL_WindowFlags_SDL_WINDOW_MAXIMIZED : SDL_WindowFlags = 128 ; 
 /// < window has grabbed input focus 
 pub const SDL_WindowFlags_SDL_WINDOW_INPUT_GRABBED : SDL_WindowFlags = 256 ; 
 /// < window has input focus 
 pub const SDL_WindowFlags_SDL_WINDOW_INPUT_FOCUS : SDL_WindowFlags = 512 ; 
 /// < window has mouse focus 
 pub const SDL_WindowFlags_SDL_WINDOW_MOUSE_FOCUS : SDL_WindowFlags = 1024 ; pub const SDL_WindowFlags_SDL_WINDOW_FULLSCREEN_DESKTOP : SDL_WindowFlags = 4097 ; 
 /// < window not created by SDL 
 pub const SDL_WindowFlags_SDL_WINDOW_FOREIGN : SDL_WindowFlags = 2048 ; 
 /// < window should be created in high-DPI mode if supported.
/// On macOS NSHighResolutionCapable must be set true in the
/// application's Info.plist for this to have any effect. 
 pub const SDL_WindowFlags_SDL_WINDOW_ALLOW_HIGHDPI : SDL_WindowFlags = 8192 ; 
 /// < window has mouse captured (unrelated to INPUT_GRABBED) 
 pub const SDL_WindowFlags_SDL_WINDOW_MOUSE_CAPTURE : SDL_WindowFlags = 16384 ; 
 /// < window should always be above others 
 pub const SDL_WindowFlags_SDL_WINDOW_ALWAYS_ON_TOP : SDL_WindowFlags = 32768 ; 
 /// < window should not be added to the taskbar 
 pub const SDL_WindowFlags_SDL_WINDOW_SKIP_TASKBAR : SDL_WindowFlags = 65536 ; 
 /// < window should be treated as a utility window 
 pub const SDL_WindowFlags_SDL_WINDOW_UTILITY : SDL_WindowFlags = 131072 ; 
 /// < window should be treated as a tooltip 
 pub const SDL_WindowFlags_SDL_WINDOW_TOOLTIP : SDL_WindowFlags = 262144 ; 
 /// < window should be treated as a popup menu 
 pub const SDL_WindowFlags_SDL_WINDOW_POPUP_MENU : SDL_WindowFlags = 524288 ; 
 /// < window usable for Vulkan surface 
 pub const SDL_WindowFlags_SDL_WINDOW_VULKAN : SDL_WindowFlags = 268435456 ; 
 /// \brief The flags on a window
///
/// \sa SDL_GetWindowFlags() 
 pub type SDL_WindowFlags = u32 ; 
 /// < Never used 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_NONE : SDL_WindowEventID = 0 ; 
 /// < Window has been shown 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_SHOWN : SDL_WindowEventID = 1 ; 
 /// < Window has been hidden 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_HIDDEN : SDL_WindowEventID = 2 ; 
 /// < Window has been exposed and should be
/// redrawn 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_EXPOSED : SDL_WindowEventID = 3 ; 
 /// < Window has been moved to data1, data2 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_MOVED : SDL_WindowEventID = 4 ; 
 /// < Window has been resized to data1xdata2 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_RESIZED : SDL_WindowEventID = 5 ; 
 /// < The window size has changed, either as
/// a result of an API call or through the
/// system or user changing the window size. 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_SIZE_CHANGED : SDL_WindowEventID = 6 ; 
 /// < Window has been minimized 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_MINIMIZED : SDL_WindowEventID = 7 ; 
 /// < Window has been maximized 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_MAXIMIZED : SDL_WindowEventID = 8 ; 
 /// < Window has been restored to normal size
/// and position 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_RESTORED : SDL_WindowEventID = 9 ; 
 /// < Window has gained mouse focus 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_ENTER : SDL_WindowEventID = 10 ; 
 /// < Window has lost mouse focus 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_LEAVE : SDL_WindowEventID = 11 ; 
 /// < Window has gained keyboard focus 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_FOCUS_GAINED : SDL_WindowEventID = 12 ; 
 /// < Window has lost keyboard focus 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_FOCUS_LOST : SDL_WindowEventID = 13 ; 
 /// < The window manager requests that the window be closed 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_CLOSE : SDL_WindowEventID = 14 ; 
 /// < Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore) 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_TAKE_FOCUS : SDL_WindowEventID = 15 ; 
 /// < Window had a hit test that wasn't SDL_HITTEST_NORMAL. 
 pub const SDL_WindowEventID_SDL_WINDOWEVENT_HIT_TEST : SDL_WindowEventID = 16 ; 
 /// \brief Event subtype for window events 
 pub type SDL_WindowEventID = u32 ; 
 /// \brief An opaque handle to an OpenGL context. 
 pub type SDL_GLContext = * mut ctypes :: c_void ; pub const SDL_GLattr_SDL_GL_RED_SIZE : SDL_GLattr = 0 ; pub const SDL_GLattr_SDL_GL_GREEN_SIZE : SDL_GLattr = 1 ; pub const SDL_GLattr_SDL_GL_BLUE_SIZE : SDL_GLattr = 2 ; pub const SDL_GLattr_SDL_GL_ALPHA_SIZE : SDL_GLattr = 3 ; pub const SDL_GLattr_SDL_GL_BUFFER_SIZE : SDL_GLattr = 4 ; pub const SDL_GLattr_SDL_GL_DOUBLEBUFFER : SDL_GLattr = 5 ; pub const SDL_GLattr_SDL_GL_DEPTH_SIZE : SDL_GLattr = 6 ; pub const SDL_GLattr_SDL_GL_STENCIL_SIZE : SDL_GLattr = 7 ; pub const SDL_GLattr_SDL_GL_ACCUM_RED_SIZE : SDL_GLattr = 8 ; pub const SDL_GLattr_SDL_GL_ACCUM_GREEN_SIZE : SDL_GLattr = 9 ; pub const SDL_GLattr_SDL_GL_ACCUM_BLUE_SIZE : SDL_GLattr = 10 ; pub const SDL_GLattr_SDL_GL_ACCUM_ALPHA_SIZE : SDL_GLattr = 11 ; pub const SDL_GLattr_SDL_GL_STEREO : SDL_GLattr = 12 ; pub const SDL_GLattr_SDL_GL_MULTISAMPLEBUFFERS : SDL_GLattr = 13 ; pub const SDL_GLattr_SDL_GL_MULTISAMPLESAMPLES : SDL_GLattr = 14 ; pub const SDL_GLattr_SDL_GL_ACCELERATED_VISUAL : SDL_GLattr = 15 ; pub const SDL_GLattr_SDL_GL_RETAINED_BACKING : SDL_GLattr = 16 ; pub const SDL_GLattr_SDL_GL_CONTEXT_MAJOR_VERSION : SDL_GLattr = 17 ; pub const SDL_GLattr_SDL_GL_CONTEXT_MINOR_VERSION : SDL_GLattr = 18 ; pub const SDL_GLattr_SDL_GL_CONTEXT_EGL : SDL_GLattr = 19 ; pub const SDL_GLattr_SDL_GL_CONTEXT_FLAGS : SDL_GLattr = 20 ; pub const SDL_GLattr_SDL_GL_CONTEXT_PROFILE_MASK : SDL_GLattr = 21 ; pub const SDL_GLattr_SDL_GL_SHARE_WITH_CURRENT_CONTEXT : SDL_GLattr = 22 ; pub const SDL_GLattr_SDL_GL_FRAMEBUFFER_SRGB_CAPABLE : SDL_GLattr = 23 ; pub const SDL_GLattr_SDL_GL_CONTEXT_RELEASE_BEHAVIOR : SDL_GLattr = 24 ; pub const SDL_GLattr_SDL_GL_CONTEXT_RESET_NOTIFICATION : SDL_GLattr = 25 ; pub const SDL_GLattr_SDL_GL_CONTEXT_NO_ERROR : SDL_GLattr = 26 ; 
 /// \brief OpenGL configuration attributes 
 pub type SDL_GLattr = u32 ; pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_CORE : SDL_GLprofile = 1 ; pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_COMPATIBILITY : SDL_GLprofile = 2 ; 
 /// < GLX_CONTEXT_ES2_PROFILE_BIT_EXT 
 pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_ES : SDL_GLprofile = 4 ; pub type SDL_GLprofile = u32 ; pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_DEBUG_FLAG : SDL_GLcontextFlag = 1 ; pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG : SDL_GLcontextFlag = 2 ; pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG : SDL_GLcontextFlag = 4 ; pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_RESET_ISOLATION_FLAG : SDL_GLcontextFlag = 8 ; pub type SDL_GLcontextFlag = u32 ; pub const SDL_GLcontextReleaseFlag_SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE : SDL_GLcontextReleaseFlag = 0 ; pub const SDL_GLcontextReleaseFlag_SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH : SDL_GLcontextReleaseFlag = 1 ; pub type SDL_GLcontextReleaseFlag = u32 ; pub const SDL_GLContextResetNotification_SDL_GL_CONTEXT_RESET_NO_NOTIFICATION : SDL_GLContextResetNotification = 0 ; pub const SDL_GLContextResetNotification_SDL_GL_CONTEXT_RESET_LOSE_CONTEXT : SDL_GLContextResetNotification = 1 ; pub type SDL_GLContextResetNotification = u32 ; extern "C" { 
 /// \brief Get the number of video drivers compiled into SDL
///
/// \sa SDL_GetVideoDriver() 
 pub fn SDL_GetNumVideoDrivers ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the name of a built in video driver.
///
/// \note The video drivers are presented in the order in which they are
/// normally checked during initialization.
///
/// \sa SDL_GetNumVideoDrivers() 
 pub fn SDL_GetVideoDriver ( index : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Initialize the video subsystem, optionally specifying a video driver.
///
/// \param driver_name Initialize a specific driver by name, or NULL for the
/// default video driver.
///
/// \return 0 on success, -1 on error
///
/// This function initializes the video subsystem; setting up a connection
/// to the window manager, etc, and determines the available display modes
/// and pixel formats, but does not initialize a window or graphics mode.
///
/// \sa SDL_VideoQuit() 
 pub fn SDL_VideoInit ( driver_name : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Shuts down the video subsystem.
///
/// This function closes all windows, and restores the original video mode.
///
/// \sa SDL_VideoInit() 
 pub fn SDL_VideoQuit ( ) ; } extern "C" { 
 /// \brief Returns the name of the currently initialized video driver.
///
/// \return The name of the current video driver or NULL if no driver
/// has been initialized
///
/// \sa SDL_GetNumVideoDrivers()
/// \sa SDL_GetVideoDriver() 
 pub fn SDL_GetCurrentVideoDriver ( ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Returns the number of available video displays.
///
/// \sa SDL_GetDisplayBounds() 
 pub fn SDL_GetNumVideoDisplays ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the name of a display in UTF-8 encoding
///
/// \return The name of a display, or NULL for an invalid display index.
///
/// \sa SDL_GetNumVideoDisplays() 
 pub fn SDL_GetDisplayName ( displayIndex : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Get the desktop area represented by a display, with the primary
/// display located at 0,0
///
/// \return 0 on success, or -1 if the index is out of range.
///
/// \sa SDL_GetNumVideoDisplays() 
 pub fn SDL_GetDisplayBounds ( displayIndex : ctypes :: c_int , rect : * mut SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the dots/pixels-per-inch for a display
///
/// \note Diagonal, horizontal and vertical DPI can all be optionally
/// returned if the parameter is non-NULL.
///
/// \return 0 on success, or -1 if no DPI information is available or the index is out of range.
///
/// \sa SDL_GetNumVideoDisplays() 
 pub fn SDL_GetDisplayDPI ( displayIndex : ctypes :: c_int , ddpi : * mut f32 , hdpi : * mut f32 , vdpi : * mut f32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the usable desktop area represented by a display, with the
/// primary display located at 0,0
///
/// This is the same area as SDL_GetDisplayBounds() reports, but with portions
/// reserved by the system removed. For example, on Mac OS X, this subtracts
/// the area occupied by the menu bar and dock.
///
/// Setting a window to be fullscreen generally bypasses these unusable areas,
/// so these are good guidelines for the maximum space available to a
/// non-fullscreen window.
///
/// \return 0 on success, or -1 if the index is out of range.
///
/// \sa SDL_GetDisplayBounds()
/// \sa SDL_GetNumVideoDisplays() 
 pub fn SDL_GetDisplayUsableBounds ( displayIndex : ctypes :: c_int , rect : * mut SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Returns the number of available display modes.
///
/// \sa SDL_GetDisplayMode() 
 pub fn SDL_GetNumDisplayModes ( displayIndex : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Fill in information about a specific display mode.
///
/// \note The display modes are sorted in this priority:
/// \li bits per pixel -> more colors to fewer colors
/// \li width -> largest to smallest
/// \li height -> largest to smallest
/// \li refresh rate -> highest to lowest
///
/// \sa SDL_GetNumDisplayModes() 
 pub fn SDL_GetDisplayMode ( displayIndex : ctypes :: c_int , modeIndex : ctypes :: c_int , mode : * mut SDL_DisplayMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Fill in information about the desktop display mode. 
 pub fn SDL_GetDesktopDisplayMode ( displayIndex : ctypes :: c_int , mode : * mut SDL_DisplayMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Fill in information about the current display mode. 
 pub fn SDL_GetCurrentDisplayMode ( displayIndex : ctypes :: c_int , mode : * mut SDL_DisplayMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the closest match to the requested display mode.
///
/// \param displayIndex The index of display from which mode should be queried.
/// \param mode The desired display mode
/// \param closest A pointer to a display mode to be filled in with the closest
/// match of the available display modes.
///
/// \return The passed in value \c closest, or NULL if no matching video mode
/// was available.
///
/// The available display modes are scanned, and \c closest is filled in with the
/// closest mode matching the requested mode and returned.  The mode format and
/// refresh_rate default to the desktop mode if they are 0.  The modes are
/// scanned with size being first priority, format being second priority, and
/// finally checking the refresh_rate.  If all the available modes are too
/// small, then NULL is returned.
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode() 
 pub fn SDL_GetClosestDisplayMode ( displayIndex : ctypes :: c_int , mode : * const SDL_DisplayMode , closest : * mut SDL_DisplayMode ) -> * mut SDL_DisplayMode ; } extern "C" { 
 /// \brief Get the display index associated with a window.
///
/// \return the display index of the display containing the center of the
/// window, or -1 on error. 
 pub fn SDL_GetWindowDisplayIndex ( window : * mut SDL_Window ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the display mode used when a fullscreen window is visible.
///
/// By default the window's dimensions and the desktop format and refresh rate
/// are used.
///
/// \param window The window for which the display mode should be set.
/// \param mode The mode to use, or NULL for the default mode.
///
/// \return 0 on success, or -1 if setting the display mode failed.
///
/// \sa SDL_GetWindowDisplayMode()
/// \sa SDL_SetWindowFullscreen() 
 pub fn SDL_SetWindowDisplayMode ( window : * mut SDL_Window , mode : * const SDL_DisplayMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Fill in information about the display mode used when a fullscreen
/// window is visible.
///
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_SetWindowFullscreen() 
 pub fn SDL_GetWindowDisplayMode ( window : * mut SDL_Window , mode : * mut SDL_DisplayMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the pixel format associated with the window. 
 pub fn SDL_GetWindowPixelFormat ( window : * mut SDL_Window ) -> Uint32 ; } extern "C" { 
 /// \brief Create a window with the specified position, dimensions, and flags.
///
/// \param title The title of the window, in UTF-8 encoding.
/// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param w     The width of the window, in screen coordinates.
/// \param h     The height of the window, in screen coordinates.
/// \param flags The flags for the window, a mask of any of the following:
/// ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,
/// ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,
/// ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,
/// ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,
/// ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN.
///
/// \return The created window, or NULL if window creation failed.
///
/// If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size
/// in pixels may differ from its size in screen coordinates on platforms with
/// high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query
/// the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),
/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the
/// drawable size in pixels.
///
/// If the window is created with any of the SDL_WINDOW_OPENGL or
/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().
///
/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
///
/// \note On non-Apple devices, SDL requires you to either not link to the
/// Vulkan loader or link to a dynamic library version. This limitation
/// may be removed in a future version of SDL.
///
/// \sa SDL_DestroyWindow()
/// \sa SDL_GL_LoadLibrary()
/// \sa SDL_Vulkan_LoadLibrary() 
 pub fn SDL_CreateWindow ( title : * const ctypes :: c_char , x : ctypes :: c_int , y : ctypes :: c_int , w : ctypes :: c_int , h : ctypes :: c_int , flags : Uint32 ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Create an SDL window from an existing native window.
///
/// \param data A pointer to driver-dependent window creation data
///
/// \return The created window, or NULL if window creation failed.
///
/// \sa SDL_DestroyWindow() 
 pub fn SDL_CreateWindowFrom ( data : * const ctypes :: c_void ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Get the numeric ID of a window, for logging purposes. 
 pub fn SDL_GetWindowID ( window : * mut SDL_Window ) -> Uint32 ; } extern "C" { 
 /// \brief Get a window from a stored ID, or NULL if it doesn't exist. 
 pub fn SDL_GetWindowFromID ( id : Uint32 ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Get the window flags. 
 pub fn SDL_GetWindowFlags ( window : * mut SDL_Window ) -> Uint32 ; } extern "C" { 
 /// \brief Set the title of a window, in UTF-8 format.
///
/// \sa SDL_GetWindowTitle() 
 pub fn SDL_SetWindowTitle ( window : * mut SDL_Window , title : * const ctypes :: c_char ) ; } extern "C" { 
 /// \brief Get the title of a window, in UTF-8 format.
///
/// \sa SDL_SetWindowTitle() 
 pub fn SDL_GetWindowTitle ( window : * mut SDL_Window ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Set the icon for a window.
///
/// \param window The window for which the icon should be set.
/// \param icon The icon for the window. 
 pub fn SDL_SetWindowIcon ( window : * mut SDL_Window , icon : * mut SDL_Surface ) ; } extern "C" { 
 /// \brief Associate an arbitrary named pointer with a window.
///
/// \param window   The window to associate with the pointer.
/// \param name     The name of the pointer.
/// \param userdata The associated pointer.
///
/// \return The previous value associated with 'name'
///
/// \note The name is case-sensitive.
///
/// \sa SDL_GetWindowData() 
 pub fn SDL_SetWindowData ( window : * mut SDL_Window , name : * const ctypes :: c_char , userdata : * mut ctypes :: c_void ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Retrieve the data pointer associated with a window.
///
/// \param window   The window to query.
/// \param name     The name of the pointer.
///
/// \return The value associated with 'name'
///
/// \sa SDL_SetWindowData() 
 pub fn SDL_GetWindowData ( window : * mut SDL_Window , name : * const ctypes :: c_char ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Set the position of a window.
///
/// \param window   The window to reposition.
/// \param x        The x coordinate of the window in screen coordinates, or
/// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
/// \param y        The y coordinate of the window in screen coordinates, or
/// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
///
/// \note The window coordinate origin is the upper left of the display.
///
/// \sa SDL_GetWindowPosition() 
 pub fn SDL_SetWindowPosition ( window : * mut SDL_Window , x : ctypes :: c_int , y : ctypes :: c_int ) ; } extern "C" { 
 /// \brief Get the position of a window.
///
/// \param window   The window to query.
/// \param x        Pointer to variable for storing the x position, in screen
/// coordinates. May be NULL.
/// \param y        Pointer to variable for storing the y position, in screen
/// coordinates. May be NULL.
///
/// \sa SDL_SetWindowPosition() 
 pub fn SDL_GetWindowPosition ( window : * mut SDL_Window , x : * mut ctypes :: c_int , y : * mut ctypes :: c_int ) ; } extern "C" { 
 /// \brief Set the size of a window's client area.
///
/// \param window   The window to resize.
/// \param w        The width of the window, in screen coordinates. Must be >0.
/// \param h        The height of the window, in screen coordinates. Must be >0.
///
/// \note Fullscreen windows automatically match the size of the display mode,
/// and you should use SDL_SetWindowDisplayMode() to change their size.
///
/// The window size in screen coordinates may differ from the size in pixels, if
/// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
/// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
/// SDL_GetRendererOutputSize() to get the real client area size in pixels.
///
/// \sa SDL_GetWindowSize()
/// \sa SDL_SetWindowDisplayMode() 
 pub fn SDL_SetWindowSize ( window : * mut SDL_Window , w : ctypes :: c_int , h : ctypes :: c_int ) ; } extern "C" { 
 /// \brief Get the size of a window's client area.
///
/// \param window   The window to query.
/// \param w        Pointer to variable for storing the width, in screen
/// coordinates. May be NULL.
/// \param h        Pointer to variable for storing the height, in screen
/// coordinates. May be NULL.
///
/// The window size in screen coordinates may differ from the size in pixels, if
/// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
/// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
/// SDL_GetRendererOutputSize() to get the real client area size in pixels.
///
/// \sa SDL_SetWindowSize() 
 pub fn SDL_GetWindowSize ( window : * mut SDL_Window , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) ; } extern "C" { 
 /// \brief Get the size of a window's borders (decorations) around the client area.
///
/// \param window The window to query.
/// \param top Pointer to variable for storing the size of the top border. NULL is permitted.
/// \param left Pointer to variable for storing the size of the left border. NULL is permitted.
/// \param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted.
/// \param right Pointer to variable for storing the size of the right border. NULL is permitted.
///
/// \return 0 on success, or -1 if getting this information is not supported.
///
/// \note if this function fails (returns -1), the size values will be
/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as
/// if the window in question was borderless. 
 pub fn SDL_GetWindowBordersSize ( window : * mut SDL_Window , top : * mut ctypes :: c_int , left : * mut ctypes :: c_int , bottom : * mut ctypes :: c_int , right : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the minimum size of a window's client area.
///
/// \param window    The window to set a new minimum size.
/// \param min_w     The minimum width of the window, must be >0
/// \param min_h     The minimum height of the window, must be >0
///
/// \note You can't change the minimum size of a fullscreen window, it
/// automatically matches the size of the display mode.
///
/// \sa SDL_GetWindowMinimumSize()
/// \sa SDL_SetWindowMaximumSize() 
 pub fn SDL_SetWindowMinimumSize ( window : * mut SDL_Window , min_w : ctypes :: c_int , min_h : ctypes :: c_int ) ; } extern "C" { 
 /// \brief Get the minimum size of a window's client area.
///
/// \param window   The window to query.
/// \param w        Pointer to variable for storing the minimum width, may be NULL
/// \param h        Pointer to variable for storing the minimum height, may be NULL
///
/// \sa SDL_GetWindowMaximumSize()
/// \sa SDL_SetWindowMinimumSize() 
 pub fn SDL_GetWindowMinimumSize ( window : * mut SDL_Window , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) ; } extern "C" { 
 /// \brief Set the maximum size of a window's client area.
///
/// \param window    The window to set a new maximum size.
/// \param max_w     The maximum width of the window, must be >0
/// \param max_h     The maximum height of the window, must be >0
///
/// \note You can't change the maximum size of a fullscreen window, it
/// automatically matches the size of the display mode.
///
/// \sa SDL_GetWindowMaximumSize()
/// \sa SDL_SetWindowMinimumSize() 
 pub fn SDL_SetWindowMaximumSize ( window : * mut SDL_Window , max_w : ctypes :: c_int , max_h : ctypes :: c_int ) ; } extern "C" { 
 /// \brief Get the maximum size of a window's client area.
///
/// \param window   The window to query.
/// \param w        Pointer to variable for storing the maximum width, may be NULL
/// \param h        Pointer to variable for storing the maximum height, may be NULL
///
/// \sa SDL_GetWindowMinimumSize()
/// \sa SDL_SetWindowMaximumSize() 
 pub fn SDL_GetWindowMaximumSize ( window : * mut SDL_Window , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) ; } extern "C" { 
 /// \brief Set the border state of a window.
///
/// This will add or remove the window's SDL_WINDOW_BORDERLESS flag and
/// add or remove the border from the actual window. This is a no-op if the
/// window's border already matches the requested state.
///
/// \param window The window of which to change the border state.
/// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border.
///
/// \note You can't change the border state of a fullscreen window.
///
/// \sa SDL_GetWindowFlags() 
 pub fn SDL_SetWindowBordered ( window : * mut SDL_Window , bordered : SDL_bool ) ; } extern "C" { 
 /// \brief Set the user-resizable state of a window.
///
/// This will add or remove the window's SDL_WINDOW_RESIZABLE flag and
/// allow/disallow user resizing of the window. This is a no-op if the
/// window's resizable state already matches the requested state.
///
/// \param window The window of which to change the resizable state.
/// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow.
///
/// \note You can't change the resizable state of a fullscreen window.
///
/// \sa SDL_GetWindowFlags() 
 pub fn SDL_SetWindowResizable ( window : * mut SDL_Window , resizable : SDL_bool ) ; } extern "C" { 
 /// \brief Show a window.
///
/// \sa SDL_HideWindow() 
 pub fn SDL_ShowWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Hide a window.
///
/// \sa SDL_ShowWindow() 
 pub fn SDL_HideWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Raise a window above other windows and set the input focus. 
 pub fn SDL_RaiseWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Make a window as large as possible.
///
/// \sa SDL_RestoreWindow() 
 pub fn SDL_MaximizeWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Minimize a window to an iconic representation.
///
/// \sa SDL_RestoreWindow() 
 pub fn SDL_MinimizeWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Restore the size and position of a minimized or maximized window.
///
/// \sa SDL_MaximizeWindow()
/// \sa SDL_MinimizeWindow() 
 pub fn SDL_RestoreWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Set a window's fullscreen state.
///
/// \return 0 on success, or -1 if setting the display mode failed.
///
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode() 
 pub fn SDL_SetWindowFullscreen ( window : * mut SDL_Window , flags : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the SDL surface associated with the window.
///
/// \return The window's framebuffer surface, or NULL on error.
///
/// A new surface will be created with the optimal format for the window,
/// if necessary. This surface will be freed when the window is destroyed.
///
/// \note You may not combine this with 3D or the rendering API on this window.
///
/// \sa SDL_UpdateWindowSurface()
/// \sa SDL_UpdateWindowSurfaceRects() 
 pub fn SDL_GetWindowSurface ( window : * mut SDL_Window ) -> * mut SDL_Surface ; } extern "C" { 
 /// \brief Copy the window surface to the screen.
///
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_GetWindowSurface()
/// \sa SDL_UpdateWindowSurfaceRects() 
 pub fn SDL_UpdateWindowSurface ( window : * mut SDL_Window ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Copy a number of rectangles on the window surface to the screen.
///
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_GetWindowSurface()
/// \sa SDL_UpdateWindowSurface() 
 pub fn SDL_UpdateWindowSurfaceRects ( window : * mut SDL_Window , rects : * const SDL_Rect , numrects : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set a window's input grab mode.
///
/// \param window The window for which the input grab mode should be set.
/// \param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.
///
/// If the caller enables a grab while another window is currently grabbed,
/// the other window loses its grab in favor of the caller's window.
///
/// \sa SDL_GetWindowGrab() 
 pub fn SDL_SetWindowGrab ( window : * mut SDL_Window , grabbed : SDL_bool ) ; } extern "C" { 
 /// \brief Get a window's input grab mode.
///
/// \return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.
///
/// \sa SDL_SetWindowGrab() 
 pub fn SDL_GetWindowGrab ( window : * mut SDL_Window ) -> SDL_bool ; } extern "C" { 
 /// \brief Get the window that currently has an input grab enabled.
///
/// \return This returns the window if input is grabbed, and NULL otherwise.
///
/// \sa SDL_SetWindowGrab() 
 pub fn SDL_GetGrabbedWindow ( ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Set the brightness (gamma correction) for a window.
///
/// \return 0 on success, or -1 if setting the brightness isn't supported.
///
/// \sa SDL_GetWindowBrightness()
/// \sa SDL_SetWindowGammaRamp() 
 pub fn SDL_SetWindowBrightness ( window : * mut SDL_Window , brightness : f32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the brightness (gamma correction) for a window.
///
/// \return The last brightness value passed to SDL_SetWindowBrightness()
///
/// \sa SDL_SetWindowBrightness() 
 pub fn SDL_GetWindowBrightness ( window : * mut SDL_Window ) -> f32 ; } extern "C" { 
 /// \brief Set the opacity for a window
///
/// \param window The window which will be made transparent or opaque
/// \param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be
/// clamped internally between 0.0f and 1.0f.
///
/// \return 0 on success, or -1 if setting the opacity isn't supported.
///
/// \sa SDL_GetWindowOpacity() 
 pub fn SDL_SetWindowOpacity ( window : * mut SDL_Window , opacity : f32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the opacity of a window.
///
/// If transparency isn't supported on this platform, opacity will be reported
/// as 1.0f without error.
///
/// \param window The window in question.
/// \param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)
///
/// \return 0 on success, or -1 on error (invalid window, etc).
///
/// \sa SDL_SetWindowOpacity() 
 pub fn SDL_GetWindowOpacity ( window : * mut SDL_Window , out_opacity : * mut f32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)
///
/// \param modal_window The window that should be modal
/// \param parent_window The parent window
///
/// \return 0 on success, or -1 otherwise. 
 pub fn SDL_SetWindowModalFor ( modal_window : * mut SDL_Window , parent_window : * mut SDL_Window ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Explicitly sets input focus to the window.
///
/// You almost certainly want SDL_RaiseWindow() instead of this function. Use
/// this with caution, as you might give focus to a window that's completely
/// obscured by other windows.
///
/// \param window The window that should get the input focus
///
/// \return 0 on success, or -1 otherwise.
/// \sa SDL_RaiseWindow() 
 pub fn SDL_SetWindowInputFocus ( window : * mut SDL_Window ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the gamma ramp for a window.
///
/// \param window The window for which the gamma ramp should be set.
/// \param red The translation table for the red channel, or NULL.
/// \param green The translation table for the green channel, or NULL.
/// \param blue The translation table for the blue channel, or NULL.
///
/// \return 0 on success, or -1 if gamma ramps are unsupported.
///
/// Set the gamma translation table for the red, green, and blue channels
/// of the video hardware.  Each table is an array of 256 16-bit quantities,
/// representing a mapping between the input and output for that channel.
/// The input is the index into the array, and the output is the 16-bit
/// gamma value at that index, scaled to the output color precision.
///
/// \sa SDL_GetWindowGammaRamp() 
 pub fn SDL_SetWindowGammaRamp ( window : * mut SDL_Window , red : * const Uint16 , green : * const Uint16 , blue : * const Uint16 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the gamma ramp for a window.
///
/// \param window The window from which the gamma ramp should be queried.
/// \param red   A pointer to a 256 element array of 16-bit quantities to hold
/// the translation table for the red channel, or NULL.
/// \param green A pointer to a 256 element array of 16-bit quantities to hold
/// the translation table for the green channel, or NULL.
/// \param blue  A pointer to a 256 element array of 16-bit quantities to hold
/// the translation table for the blue channel, or NULL.
///
/// \return 0 on success, or -1 if gamma ramps are unsupported.
///
/// \sa SDL_SetWindowGammaRamp() 
 pub fn SDL_GetWindowGammaRamp ( window : * mut SDL_Window , red : * mut Uint16 , green : * mut Uint16 , blue : * mut Uint16 ) -> ctypes :: c_int ; } 
 /// < Region is normal. No special properties. 
 pub const SDL_HitTestResult_SDL_HITTEST_NORMAL : SDL_HitTestResult = 0 ; 
 /// < Region can drag entire window. 
 pub const SDL_HitTestResult_SDL_HITTEST_DRAGGABLE : SDL_HitTestResult = 1 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPLEFT : SDL_HitTestResult = 2 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOP : SDL_HitTestResult = 3 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPRIGHT : SDL_HitTestResult = 4 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_RIGHT : SDL_HitTestResult = 5 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMRIGHT : SDL_HitTestResult = 6 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOM : SDL_HitTestResult = 7 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMLEFT : SDL_HitTestResult = 8 ; pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_LEFT : SDL_HitTestResult = 9 ; 
 /// \brief Possible return values from the SDL_HitTest callback.
///
/// \sa SDL_HitTest 
 pub type SDL_HitTestResult = u32 ; 
 /// \brief Callback used for hit-testing.
///
/// \sa SDL_SetWindowHitTest 
 pub type SDL_HitTest = :: core :: option :: Option < unsafe extern "C" fn ( win : * mut SDL_Window , area : * const SDL_Point , data : * mut ctypes :: c_void ) -> SDL_HitTestResult > ; extern "C" { 
 /// \brief Provide a callback that decides if a window region has special properties.
///
/// Normally windows are dragged and resized by decorations provided by the
/// system window manager (a title bar, borders, etc), but for some apps, it
/// makes sense to drag them from somewhere else inside the window itself; for
/// example, one might have a borderless window that wants to be draggable
/// from any part, or simulate its own title bar, etc.
///
/// This function lets the app provide a callback that designates pieces of
/// a given window as special. This callback is run during event processing
/// if we need to tell the OS to treat a region of the window specially; the
/// use of this callback is known as "hit testing."
///
/// Mouse input may not be delivered to your application if it is within
/// a special area; the OS will often apply that input to moving the window or
/// resizing the window and not deliver it to the application.
///
/// Specifying NULL for a callback disables hit-testing. Hit-testing is
/// disabled by default.
///
/// Platforms that don't support this functionality will return -1
/// unconditionally, even if you're attempting to disable hit-testing.
///
/// Your callback may fire at any time, and its firing does not indicate any
/// specific behavior (for example, on Windows, this certainly might fire
/// when the OS is deciding whether to drag your window, but it fires for lots
/// of other reasons, too, some unrelated to anything you probably care about
/// _and when the mouse isn't actually at the location it is testing_).
/// Since this can fire at any time, you should try to keep your callback
/// efficient, devoid of allocations, etc.
///
/// \param window The window to set hit-testing on.
/// \param callback The callback to call when doing a hit-test.
/// \param callback_data An app-defined void pointer passed to the callback.
/// \return 0 on success, -1 on error (including unsupported). 
 pub fn SDL_SetWindowHitTest ( window : * mut SDL_Window , callback : SDL_HitTest , callback_data : * mut ctypes :: c_void ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Destroy a window. 
 pub fn SDL_DestroyWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Returns whether the screensaver is currently enabled (default off).
///
/// \sa SDL_EnableScreenSaver()
/// \sa SDL_DisableScreenSaver() 
 pub fn SDL_IsScreenSaverEnabled ( ) -> SDL_bool ; } extern "C" { 
 /// \brief Allow the screen to be blanked by a screensaver
///
/// \sa SDL_IsScreenSaverEnabled()
/// \sa SDL_DisableScreenSaver() 
 pub fn SDL_EnableScreenSaver ( ) ; } extern "C" { 
 /// \brief Prevent the screen from being blanked by a screensaver
///
/// \sa SDL_IsScreenSaverEnabled()
/// \sa SDL_EnableScreenSaver() 
 pub fn SDL_DisableScreenSaver ( ) ; } extern "C" { 
 /// \brief Dynamically load an OpenGL library.
///
/// \param path The platform dependent OpenGL library name, or NULL to open the
/// default OpenGL library.
///
/// \return 0 on success, or -1 if the library couldn't be loaded.
///
/// This should be done after initializing the video driver, but before
/// creating any OpenGL windows.  If no OpenGL library is loaded, the default
/// library will be loaded upon creation of the first OpenGL window.
///
/// \note If you do this, you need to retrieve all of the GL functions used in
/// your program from the dynamic library using SDL_GL_GetProcAddress().
///
/// \sa SDL_GL_GetProcAddress()
/// \sa SDL_GL_UnloadLibrary() 
 pub fn SDL_GL_LoadLibrary ( path : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the address of an OpenGL function. 
 pub fn SDL_GL_GetProcAddress ( proc_ : * const ctypes :: c_char ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
///
/// \sa SDL_GL_LoadLibrary() 
 pub fn SDL_GL_UnloadLibrary ( ) ; } extern "C" { 
 /// \brief Return true if an OpenGL extension is supported for the current
/// context. 
 pub fn SDL_GL_ExtensionSupported ( extension : * const ctypes :: c_char ) -> SDL_bool ; } extern "C" { 
 /// \brief Reset all previously set OpenGL context attributes to their default values 
 pub fn SDL_GL_ResetAttributes ( ) ; } extern "C" { 
 /// \brief Set an OpenGL window attribute before window creation.
///
/// \return 0 on success, or -1 if the attribute could not be set. 
 pub fn SDL_GL_SetAttribute ( attr : SDL_GLattr , value : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the actual value for an attribute from the current context.
///
/// \return 0 on success, or -1 if the attribute could not be retrieved.
/// The integer at \c value will be modified in either case. 
 pub fn SDL_GL_GetAttribute ( attr : SDL_GLattr , value : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Create an OpenGL context for use with an OpenGL window, and make it
/// current.
///
/// \sa SDL_GL_DeleteContext() 
 pub fn SDL_GL_CreateContext ( window : * mut SDL_Window ) -> SDL_GLContext ; } extern "C" { 
 /// \brief Set up an OpenGL context for rendering into an OpenGL window.
///
/// \note The context must have been created with a compatible window. 
 pub fn SDL_GL_MakeCurrent ( window : * mut SDL_Window , context : SDL_GLContext ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the currently active OpenGL window. 
 pub fn SDL_GL_GetCurrentWindow ( ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Get the currently active OpenGL context. 
 pub fn SDL_GL_GetCurrentContext ( ) -> SDL_GLContext ; } extern "C" { 
 /// \brief Get the size of a window's underlying drawable in pixels (for use
/// with glViewport).
///
/// \param window   Window from which the drawable size should be queried
/// \param w        Pointer to variable for storing the width in pixels, may be NULL
/// \param h        Pointer to variable for storing the height in pixels, may be NULL
///
/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
/// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
/// platform with high-DPI support (Apple calls this "Retina"), and not disabled
/// by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
///
/// \sa SDL_GetWindowSize()
/// \sa SDL_CreateWindow() 
 pub fn SDL_GL_GetDrawableSize ( window : * mut SDL_Window , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) ; } extern "C" { 
 /// \brief Set the swap interval for the current OpenGL context.
///
/// \param interval 0 for immediate updates, 1 for updates synchronized with the
/// vertical retrace. If the system supports it, you may
/// specify -1 to allow late swaps to happen immediately
/// instead of waiting for the next retrace.
///
/// \return 0 on success, or -1 if setting the swap interval is not supported.
///
/// \sa SDL_GL_GetSwapInterval() 
 pub fn SDL_GL_SetSwapInterval ( interval : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the swap interval for the current OpenGL context.
///
/// \return 0 if there is no vertical retrace synchronization, 1 if the buffer
/// swap is synchronized with the vertical retrace, and -1 if late
/// swaps happen immediately instead of waiting for the next retrace.
/// If the system can't determine the swap interval, or there isn't a
/// valid current context, this will return 0 as a safe default.
///
/// \sa SDL_GL_SetSwapInterval() 
 pub fn SDL_GL_GetSwapInterval ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Swap the OpenGL buffers for a window, if double-buffering is
/// supported. 
 pub fn SDL_GL_SwapWindow ( window : * mut SDL_Window ) ; } extern "C" { 
 /// \brief Delete an OpenGL context.
///
/// \sa SDL_GL_CreateContext() 
 pub fn SDL_GL_DeleteContext ( context : SDL_GLContext ) ; } pub const SDL_Scancode_SDL_SCANCODE_UNKNOWN : SDL_Scancode = 0 ; pub const SDL_Scancode_SDL_SCANCODE_A : SDL_Scancode = 4 ; pub const SDL_Scancode_SDL_SCANCODE_B : SDL_Scancode = 5 ; pub const SDL_Scancode_SDL_SCANCODE_C : SDL_Scancode = 6 ; pub const SDL_Scancode_SDL_SCANCODE_D : SDL_Scancode = 7 ; pub const SDL_Scancode_SDL_SCANCODE_E : SDL_Scancode = 8 ; pub const SDL_Scancode_SDL_SCANCODE_F : SDL_Scancode = 9 ; pub const SDL_Scancode_SDL_SCANCODE_G : SDL_Scancode = 10 ; pub const SDL_Scancode_SDL_SCANCODE_H : SDL_Scancode = 11 ; pub const SDL_Scancode_SDL_SCANCODE_I : SDL_Scancode = 12 ; pub const SDL_Scancode_SDL_SCANCODE_J : SDL_Scancode = 13 ; pub const SDL_Scancode_SDL_SCANCODE_K : SDL_Scancode = 14 ; pub const SDL_Scancode_SDL_SCANCODE_L : SDL_Scancode = 15 ; pub const SDL_Scancode_SDL_SCANCODE_M : SDL_Scancode = 16 ; pub const SDL_Scancode_SDL_SCANCODE_N : SDL_Scancode = 17 ; pub const SDL_Scancode_SDL_SCANCODE_O : SDL_Scancode = 18 ; pub const SDL_Scancode_SDL_SCANCODE_P : SDL_Scancode = 19 ; pub const SDL_Scancode_SDL_SCANCODE_Q : SDL_Scancode = 20 ; pub const SDL_Scancode_SDL_SCANCODE_R : SDL_Scancode = 21 ; pub const SDL_Scancode_SDL_SCANCODE_S : SDL_Scancode = 22 ; pub const SDL_Scancode_SDL_SCANCODE_T : SDL_Scancode = 23 ; pub const SDL_Scancode_SDL_SCANCODE_U : SDL_Scancode = 24 ; pub const SDL_Scancode_SDL_SCANCODE_V : SDL_Scancode = 25 ; pub const SDL_Scancode_SDL_SCANCODE_W : SDL_Scancode = 26 ; pub const SDL_Scancode_SDL_SCANCODE_X : SDL_Scancode = 27 ; pub const SDL_Scancode_SDL_SCANCODE_Y : SDL_Scancode = 28 ; pub const SDL_Scancode_SDL_SCANCODE_Z : SDL_Scancode = 29 ; pub const SDL_Scancode_SDL_SCANCODE_1 : SDL_Scancode = 30 ; pub const SDL_Scancode_SDL_SCANCODE_2 : SDL_Scancode = 31 ; pub const SDL_Scancode_SDL_SCANCODE_3 : SDL_Scancode = 32 ; pub const SDL_Scancode_SDL_SCANCODE_4 : SDL_Scancode = 33 ; pub const SDL_Scancode_SDL_SCANCODE_5 : SDL_Scancode = 34 ; pub const SDL_Scancode_SDL_SCANCODE_6 : SDL_Scancode = 35 ; pub const SDL_Scancode_SDL_SCANCODE_7 : SDL_Scancode = 36 ; pub const SDL_Scancode_SDL_SCANCODE_8 : SDL_Scancode = 37 ; pub const SDL_Scancode_SDL_SCANCODE_9 : SDL_Scancode = 38 ; pub const SDL_Scancode_SDL_SCANCODE_0 : SDL_Scancode = 39 ; pub const SDL_Scancode_SDL_SCANCODE_RETURN : SDL_Scancode = 40 ; pub const SDL_Scancode_SDL_SCANCODE_ESCAPE : SDL_Scancode = 41 ; pub const SDL_Scancode_SDL_SCANCODE_BACKSPACE : SDL_Scancode = 42 ; pub const SDL_Scancode_SDL_SCANCODE_TAB : SDL_Scancode = 43 ; pub const SDL_Scancode_SDL_SCANCODE_SPACE : SDL_Scancode = 44 ; pub const SDL_Scancode_SDL_SCANCODE_MINUS : SDL_Scancode = 45 ; pub const SDL_Scancode_SDL_SCANCODE_EQUALS : SDL_Scancode = 46 ; pub const SDL_Scancode_SDL_SCANCODE_LEFTBRACKET : SDL_Scancode = 47 ; pub const SDL_Scancode_SDL_SCANCODE_RIGHTBRACKET : SDL_Scancode = 48 ; 
 /// < Located at the lower left of the return
/// key on ISO keyboards and at the right end
/// of the QWERTY row on ANSI keyboards.
/// Produces REVERSE SOLIDUS (backslash) and
/// VERTICAL LINE in a US layout, REVERSE
/// SOLIDUS and VERTICAL LINE in a UK Mac
/// layout, NUMBER SIGN and TILDE in a UK
/// Windows layout, DOLLAR SIGN and POUND SIGN
/// in a Swiss German layout, NUMBER SIGN and
/// APOSTROPHE in a German layout, GRAVE
/// ACCENT and POUND SIGN in a French Mac
/// layout, and ASTERISK and MICRO SIGN in a
/// French Windows layout. 
 pub const SDL_Scancode_SDL_SCANCODE_BACKSLASH : SDL_Scancode = 49 ; 
 /// < ISO USB keyboards actually use this code
/// instead of 49 for the same key, but all
/// OSes I've seen treat the two codes
/// identically. So, as an implementor, unless
/// your keyboard generates both of those
/// codes and your OS treats them differently,
/// you should generate SDL_SCANCODE_BACKSLASH
/// instead of this code. As a user, you
/// should not rely on this code because SDL
/// will never generate it with most (all?)
/// keyboards. 
 pub const SDL_Scancode_SDL_SCANCODE_NONUSHASH : SDL_Scancode = 50 ; pub const SDL_Scancode_SDL_SCANCODE_SEMICOLON : SDL_Scancode = 51 ; pub const SDL_Scancode_SDL_SCANCODE_APOSTROPHE : SDL_Scancode = 52 ; 
 /// < Located in the top left corner (on both ANSI
/// and ISO keyboards). Produces GRAVE ACCENT and
/// TILDE in a US Windows layout and in US and UK
/// Mac layouts on ANSI keyboards, GRAVE ACCENT
/// and NOT SIGN in a UK Windows layout, SECTION
/// SIGN and PLUS-MINUS SIGN in US and UK Mac
/// layouts on ISO keyboards, SECTION SIGN and
/// DEGREE SIGN in a Swiss German layout (Mac:
/// only on ISO keyboards), CIRCUMFLEX ACCENT and
/// DEGREE SIGN in a German layout (Mac: only on
/// ISO keyboards), SUPERSCRIPT TWO and TILDE in a
/// French Windows layout, COMMERCIAL AT and
/// NUMBER SIGN in a French Mac layout on ISO
/// keyboards, and LESS-THAN SIGN and GREATER-THAN
/// SIGN in a Swiss German, German, or French Mac
/// layout on ANSI keyboards. 
 pub const SDL_Scancode_SDL_SCANCODE_GRAVE : SDL_Scancode = 53 ; pub const SDL_Scancode_SDL_SCANCODE_COMMA : SDL_Scancode = 54 ; pub const SDL_Scancode_SDL_SCANCODE_PERIOD : SDL_Scancode = 55 ; pub const SDL_Scancode_SDL_SCANCODE_SLASH : SDL_Scancode = 56 ; pub const SDL_Scancode_SDL_SCANCODE_CAPSLOCK : SDL_Scancode = 57 ; pub const SDL_Scancode_SDL_SCANCODE_F1 : SDL_Scancode = 58 ; pub const SDL_Scancode_SDL_SCANCODE_F2 : SDL_Scancode = 59 ; pub const SDL_Scancode_SDL_SCANCODE_F3 : SDL_Scancode = 60 ; pub const SDL_Scancode_SDL_SCANCODE_F4 : SDL_Scancode = 61 ; pub const SDL_Scancode_SDL_SCANCODE_F5 : SDL_Scancode = 62 ; pub const SDL_Scancode_SDL_SCANCODE_F6 : SDL_Scancode = 63 ; pub const SDL_Scancode_SDL_SCANCODE_F7 : SDL_Scancode = 64 ; pub const SDL_Scancode_SDL_SCANCODE_F8 : SDL_Scancode = 65 ; pub const SDL_Scancode_SDL_SCANCODE_F9 : SDL_Scancode = 66 ; pub const SDL_Scancode_SDL_SCANCODE_F10 : SDL_Scancode = 67 ; pub const SDL_Scancode_SDL_SCANCODE_F11 : SDL_Scancode = 68 ; pub const SDL_Scancode_SDL_SCANCODE_F12 : SDL_Scancode = 69 ; pub const SDL_Scancode_SDL_SCANCODE_PRINTSCREEN : SDL_Scancode = 70 ; pub const SDL_Scancode_SDL_SCANCODE_SCROLLLOCK : SDL_Scancode = 71 ; pub const SDL_Scancode_SDL_SCANCODE_PAUSE : SDL_Scancode = 72 ; 
 /// < insert on PC, help on some Mac keyboards (but
/// does send code 73, not 117) 
 pub const SDL_Scancode_SDL_SCANCODE_INSERT : SDL_Scancode = 73 ; pub const SDL_Scancode_SDL_SCANCODE_HOME : SDL_Scancode = 74 ; pub const SDL_Scancode_SDL_SCANCODE_PAGEUP : SDL_Scancode = 75 ; pub const SDL_Scancode_SDL_SCANCODE_DELETE : SDL_Scancode = 76 ; pub const SDL_Scancode_SDL_SCANCODE_END : SDL_Scancode = 77 ; pub const SDL_Scancode_SDL_SCANCODE_PAGEDOWN : SDL_Scancode = 78 ; pub const SDL_Scancode_SDL_SCANCODE_RIGHT : SDL_Scancode = 79 ; pub const SDL_Scancode_SDL_SCANCODE_LEFT : SDL_Scancode = 80 ; pub const SDL_Scancode_SDL_SCANCODE_DOWN : SDL_Scancode = 81 ; pub const SDL_Scancode_SDL_SCANCODE_UP : SDL_Scancode = 82 ; 
 /// < num lock on PC, clear on Mac keyboards 
 pub const SDL_Scancode_SDL_SCANCODE_NUMLOCKCLEAR : SDL_Scancode = 83 ; pub const SDL_Scancode_SDL_SCANCODE_KP_DIVIDE : SDL_Scancode = 84 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MULTIPLY : SDL_Scancode = 85 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MINUS : SDL_Scancode = 86 ; pub const SDL_Scancode_SDL_SCANCODE_KP_PLUS : SDL_Scancode = 87 ; pub const SDL_Scancode_SDL_SCANCODE_KP_ENTER : SDL_Scancode = 88 ; pub const SDL_Scancode_SDL_SCANCODE_KP_1 : SDL_Scancode = 89 ; pub const SDL_Scancode_SDL_SCANCODE_KP_2 : SDL_Scancode = 90 ; pub const SDL_Scancode_SDL_SCANCODE_KP_3 : SDL_Scancode = 91 ; pub const SDL_Scancode_SDL_SCANCODE_KP_4 : SDL_Scancode = 92 ; pub const SDL_Scancode_SDL_SCANCODE_KP_5 : SDL_Scancode = 93 ; pub const SDL_Scancode_SDL_SCANCODE_KP_6 : SDL_Scancode = 94 ; pub const SDL_Scancode_SDL_SCANCODE_KP_7 : SDL_Scancode = 95 ; pub const SDL_Scancode_SDL_SCANCODE_KP_8 : SDL_Scancode = 96 ; pub const SDL_Scancode_SDL_SCANCODE_KP_9 : SDL_Scancode = 97 ; pub const SDL_Scancode_SDL_SCANCODE_KP_0 : SDL_Scancode = 98 ; pub const SDL_Scancode_SDL_SCANCODE_KP_PERIOD : SDL_Scancode = 99 ; 
 /// < This is the additional key that ISO
/// keyboards have over ANSI ones,
/// located between left shift and Y.
/// Produces GRAVE ACCENT and TILDE in a
/// US or UK Mac layout, REVERSE SOLIDUS
/// (backslash) and VERTICAL LINE in a
/// US or UK Windows layout, and
/// LESS-THAN SIGN and GREATER-THAN SIGN
/// in a Swiss German, German, or French
/// layout. 
 pub const SDL_Scancode_SDL_SCANCODE_NONUSBACKSLASH : SDL_Scancode = 100 ; 
 /// < windows contextual menu, compose 
 pub const SDL_Scancode_SDL_SCANCODE_APPLICATION : SDL_Scancode = 101 ; 
 /// < The USB document says this is a status flag,
/// not a physical key - but some Mac keyboards
/// do have a power key. 
 pub const SDL_Scancode_SDL_SCANCODE_POWER : SDL_Scancode = 102 ; pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALS : SDL_Scancode = 103 ; pub const SDL_Scancode_SDL_SCANCODE_F13 : SDL_Scancode = 104 ; pub const SDL_Scancode_SDL_SCANCODE_F14 : SDL_Scancode = 105 ; pub const SDL_Scancode_SDL_SCANCODE_F15 : SDL_Scancode = 106 ; pub const SDL_Scancode_SDL_SCANCODE_F16 : SDL_Scancode = 107 ; pub const SDL_Scancode_SDL_SCANCODE_F17 : SDL_Scancode = 108 ; pub const SDL_Scancode_SDL_SCANCODE_F18 : SDL_Scancode = 109 ; pub const SDL_Scancode_SDL_SCANCODE_F19 : SDL_Scancode = 110 ; pub const SDL_Scancode_SDL_SCANCODE_F20 : SDL_Scancode = 111 ; pub const SDL_Scancode_SDL_SCANCODE_F21 : SDL_Scancode = 112 ; pub const SDL_Scancode_SDL_SCANCODE_F22 : SDL_Scancode = 113 ; pub const SDL_Scancode_SDL_SCANCODE_F23 : SDL_Scancode = 114 ; pub const SDL_Scancode_SDL_SCANCODE_F24 : SDL_Scancode = 115 ; pub const SDL_Scancode_SDL_SCANCODE_EXECUTE : SDL_Scancode = 116 ; pub const SDL_Scancode_SDL_SCANCODE_HELP : SDL_Scancode = 117 ; pub const SDL_Scancode_SDL_SCANCODE_MENU : SDL_Scancode = 118 ; pub const SDL_Scancode_SDL_SCANCODE_SELECT : SDL_Scancode = 119 ; pub const SDL_Scancode_SDL_SCANCODE_STOP : SDL_Scancode = 120 ; 
 /// < redo 
 pub const SDL_Scancode_SDL_SCANCODE_AGAIN : SDL_Scancode = 121 ; pub const SDL_Scancode_SDL_SCANCODE_UNDO : SDL_Scancode = 122 ; pub const SDL_Scancode_SDL_SCANCODE_CUT : SDL_Scancode = 123 ; pub const SDL_Scancode_SDL_SCANCODE_COPY : SDL_Scancode = 124 ; pub const SDL_Scancode_SDL_SCANCODE_PASTE : SDL_Scancode = 125 ; pub const SDL_Scancode_SDL_SCANCODE_FIND : SDL_Scancode = 126 ; pub const SDL_Scancode_SDL_SCANCODE_MUTE : SDL_Scancode = 127 ; pub const SDL_Scancode_SDL_SCANCODE_VOLUMEUP : SDL_Scancode = 128 ; pub const SDL_Scancode_SDL_SCANCODE_VOLUMEDOWN : SDL_Scancode = 129 ; pub const SDL_Scancode_SDL_SCANCODE_KP_COMMA : SDL_Scancode = 133 ; pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALSAS400 : SDL_Scancode = 134 ; 
 /// < used on Asian keyboards, see
/// footnotes in USB doc 
 pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL1 : SDL_Scancode = 135 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL2 : SDL_Scancode = 136 ; 
 /// < Yen 
 pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL3 : SDL_Scancode = 137 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL4 : SDL_Scancode = 138 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL5 : SDL_Scancode = 139 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL6 : SDL_Scancode = 140 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL7 : SDL_Scancode = 141 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL8 : SDL_Scancode = 142 ; pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL9 : SDL_Scancode = 143 ; 
 /// < Hangul/English toggle 
 pub const SDL_Scancode_SDL_SCANCODE_LANG1 : SDL_Scancode = 144 ; 
 /// < Hanja conversion 
 pub const SDL_Scancode_SDL_SCANCODE_LANG2 : SDL_Scancode = 145 ; 
 /// < Katakana 
 pub const SDL_Scancode_SDL_SCANCODE_LANG3 : SDL_Scancode = 146 ; 
 /// < Hiragana 
 pub const SDL_Scancode_SDL_SCANCODE_LANG4 : SDL_Scancode = 147 ; 
 /// < Zenkaku/Hankaku 
 pub const SDL_Scancode_SDL_SCANCODE_LANG5 : SDL_Scancode = 148 ; 
 /// < reserved 
 pub const SDL_Scancode_SDL_SCANCODE_LANG6 : SDL_Scancode = 149 ; 
 /// < reserved 
 pub const SDL_Scancode_SDL_SCANCODE_LANG7 : SDL_Scancode = 150 ; 
 /// < reserved 
 pub const SDL_Scancode_SDL_SCANCODE_LANG8 : SDL_Scancode = 151 ; 
 /// < reserved 
 pub const SDL_Scancode_SDL_SCANCODE_LANG9 : SDL_Scancode = 152 ; 
 /// < Erase-Eaze 
 pub const SDL_Scancode_SDL_SCANCODE_ALTERASE : SDL_Scancode = 153 ; pub const SDL_Scancode_SDL_SCANCODE_SYSREQ : SDL_Scancode = 154 ; pub const SDL_Scancode_SDL_SCANCODE_CANCEL : SDL_Scancode = 155 ; pub const SDL_Scancode_SDL_SCANCODE_CLEAR : SDL_Scancode = 156 ; pub const SDL_Scancode_SDL_SCANCODE_PRIOR : SDL_Scancode = 157 ; pub const SDL_Scancode_SDL_SCANCODE_RETURN2 : SDL_Scancode = 158 ; pub const SDL_Scancode_SDL_SCANCODE_SEPARATOR : SDL_Scancode = 159 ; pub const SDL_Scancode_SDL_SCANCODE_OUT : SDL_Scancode = 160 ; pub const SDL_Scancode_SDL_SCANCODE_OPER : SDL_Scancode = 161 ; pub const SDL_Scancode_SDL_SCANCODE_CLEARAGAIN : SDL_Scancode = 162 ; pub const SDL_Scancode_SDL_SCANCODE_CRSEL : SDL_Scancode = 163 ; pub const SDL_Scancode_SDL_SCANCODE_EXSEL : SDL_Scancode = 164 ; pub const SDL_Scancode_SDL_SCANCODE_KP_00 : SDL_Scancode = 176 ; pub const SDL_Scancode_SDL_SCANCODE_KP_000 : SDL_Scancode = 177 ; pub const SDL_Scancode_SDL_SCANCODE_THOUSANDSSEPARATOR : SDL_Scancode = 178 ; pub const SDL_Scancode_SDL_SCANCODE_DECIMALSEPARATOR : SDL_Scancode = 179 ; pub const SDL_Scancode_SDL_SCANCODE_CURRENCYUNIT : SDL_Scancode = 180 ; pub const SDL_Scancode_SDL_SCANCODE_CURRENCYSUBUNIT : SDL_Scancode = 181 ; pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTPAREN : SDL_Scancode = 182 ; pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTPAREN : SDL_Scancode = 183 ; pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTBRACE : SDL_Scancode = 184 ; pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTBRACE : SDL_Scancode = 185 ; pub const SDL_Scancode_SDL_SCANCODE_KP_TAB : SDL_Scancode = 186 ; pub const SDL_Scancode_SDL_SCANCODE_KP_BACKSPACE : SDL_Scancode = 187 ; pub const SDL_Scancode_SDL_SCANCODE_KP_A : SDL_Scancode = 188 ; pub const SDL_Scancode_SDL_SCANCODE_KP_B : SDL_Scancode = 189 ; pub const SDL_Scancode_SDL_SCANCODE_KP_C : SDL_Scancode = 190 ; pub const SDL_Scancode_SDL_SCANCODE_KP_D : SDL_Scancode = 191 ; pub const SDL_Scancode_SDL_SCANCODE_KP_E : SDL_Scancode = 192 ; pub const SDL_Scancode_SDL_SCANCODE_KP_F : SDL_Scancode = 193 ; pub const SDL_Scancode_SDL_SCANCODE_KP_XOR : SDL_Scancode = 194 ; pub const SDL_Scancode_SDL_SCANCODE_KP_POWER : SDL_Scancode = 195 ; pub const SDL_Scancode_SDL_SCANCODE_KP_PERCENT : SDL_Scancode = 196 ; pub const SDL_Scancode_SDL_SCANCODE_KP_LESS : SDL_Scancode = 197 ; pub const SDL_Scancode_SDL_SCANCODE_KP_GREATER : SDL_Scancode = 198 ; pub const SDL_Scancode_SDL_SCANCODE_KP_AMPERSAND : SDL_Scancode = 199 ; pub const SDL_Scancode_SDL_SCANCODE_KP_DBLAMPERSAND : SDL_Scancode = 200 ; pub const SDL_Scancode_SDL_SCANCODE_KP_VERTICALBAR : SDL_Scancode = 201 ; pub const SDL_Scancode_SDL_SCANCODE_KP_DBLVERTICALBAR : SDL_Scancode = 202 ; pub const SDL_Scancode_SDL_SCANCODE_KP_COLON : SDL_Scancode = 203 ; pub const SDL_Scancode_SDL_SCANCODE_KP_HASH : SDL_Scancode = 204 ; pub const SDL_Scancode_SDL_SCANCODE_KP_SPACE : SDL_Scancode = 205 ; pub const SDL_Scancode_SDL_SCANCODE_KP_AT : SDL_Scancode = 206 ; pub const SDL_Scancode_SDL_SCANCODE_KP_EXCLAM : SDL_Scancode = 207 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSTORE : SDL_Scancode = 208 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMRECALL : SDL_Scancode = 209 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMCLEAR : SDL_Scancode = 210 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMADD : SDL_Scancode = 211 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSUBTRACT : SDL_Scancode = 212 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMMULTIPLY : SDL_Scancode = 213 ; pub const SDL_Scancode_SDL_SCANCODE_KP_MEMDIVIDE : SDL_Scancode = 214 ; pub const SDL_Scancode_SDL_SCANCODE_KP_PLUSMINUS : SDL_Scancode = 215 ; pub const SDL_Scancode_SDL_SCANCODE_KP_CLEAR : SDL_Scancode = 216 ; pub const SDL_Scancode_SDL_SCANCODE_KP_CLEARENTRY : SDL_Scancode = 217 ; pub const SDL_Scancode_SDL_SCANCODE_KP_BINARY : SDL_Scancode = 218 ; pub const SDL_Scancode_SDL_SCANCODE_KP_OCTAL : SDL_Scancode = 219 ; pub const SDL_Scancode_SDL_SCANCODE_KP_DECIMAL : SDL_Scancode = 220 ; pub const SDL_Scancode_SDL_SCANCODE_KP_HEXADECIMAL : SDL_Scancode = 221 ; pub const SDL_Scancode_SDL_SCANCODE_LCTRL : SDL_Scancode = 224 ; pub const SDL_Scancode_SDL_SCANCODE_LSHIFT : SDL_Scancode = 225 ; 
 /// < alt, option 
 pub const SDL_Scancode_SDL_SCANCODE_LALT : SDL_Scancode = 226 ; 
 /// < windows, command (apple), meta 
 pub const SDL_Scancode_SDL_SCANCODE_LGUI : SDL_Scancode = 227 ; pub const SDL_Scancode_SDL_SCANCODE_RCTRL : SDL_Scancode = 228 ; pub const SDL_Scancode_SDL_SCANCODE_RSHIFT : SDL_Scancode = 229 ; 
 /// < alt gr, option 
 pub const SDL_Scancode_SDL_SCANCODE_RALT : SDL_Scancode = 230 ; 
 /// < windows, command (apple), meta 
 pub const SDL_Scancode_SDL_SCANCODE_RGUI : SDL_Scancode = 231 ; 
 /// < I'm not sure if this is really not covered
/// by any of the above, but since there's a
/// special KMOD_MODE for it I'm adding it here 
 pub const SDL_Scancode_SDL_SCANCODE_MODE : SDL_Scancode = 257 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIONEXT : SDL_Scancode = 258 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIOPREV : SDL_Scancode = 259 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIOSTOP : SDL_Scancode = 260 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIOPLAY : SDL_Scancode = 261 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIOMUTE : SDL_Scancode = 262 ; pub const SDL_Scancode_SDL_SCANCODE_MEDIASELECT : SDL_Scancode = 263 ; pub const SDL_Scancode_SDL_SCANCODE_WWW : SDL_Scancode = 264 ; pub const SDL_Scancode_SDL_SCANCODE_MAIL : SDL_Scancode = 265 ; pub const SDL_Scancode_SDL_SCANCODE_CALCULATOR : SDL_Scancode = 266 ; pub const SDL_Scancode_SDL_SCANCODE_COMPUTER : SDL_Scancode = 267 ; pub const SDL_Scancode_SDL_SCANCODE_AC_SEARCH : SDL_Scancode = 268 ; pub const SDL_Scancode_SDL_SCANCODE_AC_HOME : SDL_Scancode = 269 ; pub const SDL_Scancode_SDL_SCANCODE_AC_BACK : SDL_Scancode = 270 ; pub const SDL_Scancode_SDL_SCANCODE_AC_FORWARD : SDL_Scancode = 271 ; pub const SDL_Scancode_SDL_SCANCODE_AC_STOP : SDL_Scancode = 272 ; pub const SDL_Scancode_SDL_SCANCODE_AC_REFRESH : SDL_Scancode = 273 ; pub const SDL_Scancode_SDL_SCANCODE_AC_BOOKMARKS : SDL_Scancode = 274 ; pub const SDL_Scancode_SDL_SCANCODE_BRIGHTNESSDOWN : SDL_Scancode = 275 ; pub const SDL_Scancode_SDL_SCANCODE_BRIGHTNESSUP : SDL_Scancode = 276 ; 
 /// < display mirroring/dual display
/// switch, video mode switch 
 pub const SDL_Scancode_SDL_SCANCODE_DISPLAYSWITCH : SDL_Scancode = 277 ; pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMTOGGLE : SDL_Scancode = 278 ; pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMDOWN : SDL_Scancode = 279 ; pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMUP : SDL_Scancode = 280 ; pub const SDL_Scancode_SDL_SCANCODE_EJECT : SDL_Scancode = 281 ; pub const SDL_Scancode_SDL_SCANCODE_SLEEP : SDL_Scancode = 282 ; pub const SDL_Scancode_SDL_SCANCODE_APP1 : SDL_Scancode = 283 ; pub const SDL_Scancode_SDL_SCANCODE_APP2 : SDL_Scancode = 284 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIOREWIND : SDL_Scancode = 285 ; pub const SDL_Scancode_SDL_SCANCODE_AUDIOFASTFORWARD : SDL_Scancode = 286 ; 
 /// < not a key, just marks the number of scancodes
/// for array bounds 
 pub const SDL_Scancode_SDL_NUM_SCANCODES : SDL_Scancode = 512 ; 
 /// \brief The SDL keyboard scancode representation.
///
/// Values of this type are used to represent keyboard keys, among other places
/// in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
/// SDL_Event structure.
///
/// The values in this enumeration are based on the USB usage page standard:
/// http://www.usb.org/developers/hidpage/Hut1_12v2.pdf 
 pub type SDL_Scancode = u32 ; 
 /// \brief The SDL virtual key representation.
///
/// Values of this type are used to represent keyboard keys using the current
/// layout of the keyboard.  These values include Unicode values representing
/// the unmodified character that would be generated by pressing the key, or
/// an SDLK_* constant for those keys that do not generate characters.
///
/// A special exception is the number keys at the top of the keyboard which
/// always map to SDLK_0...SDLK_9, regardless of layout. 
 pub type SDL_Keycode = Sint32 ; pub const SDLK_UNKNOWN : _bindgen_ty_7 = 0 ; pub const SDLK_RETURN : _bindgen_ty_7 = 13 ; pub const SDLK_ESCAPE : _bindgen_ty_7 = 27 ; pub const SDLK_BACKSPACE : _bindgen_ty_7 = 8 ; pub const SDLK_TAB : _bindgen_ty_7 = 9 ; pub const SDLK_SPACE : _bindgen_ty_7 = 32 ; pub const SDLK_EXCLAIM : _bindgen_ty_7 = 33 ; pub const SDLK_QUOTEDBL : _bindgen_ty_7 = 34 ; pub const SDLK_HASH : _bindgen_ty_7 = 35 ; pub const SDLK_PERCENT : _bindgen_ty_7 = 37 ; pub const SDLK_DOLLAR : _bindgen_ty_7 = 36 ; pub const SDLK_AMPERSAND : _bindgen_ty_7 = 38 ; pub const SDLK_QUOTE : _bindgen_ty_7 = 39 ; pub const SDLK_LEFTPAREN : _bindgen_ty_7 = 40 ; pub const SDLK_RIGHTPAREN : _bindgen_ty_7 = 41 ; pub const SDLK_ASTERISK : _bindgen_ty_7 = 42 ; pub const SDLK_PLUS : _bindgen_ty_7 = 43 ; pub const SDLK_COMMA : _bindgen_ty_7 = 44 ; pub const SDLK_MINUS : _bindgen_ty_7 = 45 ; pub const SDLK_PERIOD : _bindgen_ty_7 = 46 ; pub const SDLK_SLASH : _bindgen_ty_7 = 47 ; pub const SDLK_0 : _bindgen_ty_7 = 48 ; pub const SDLK_1 : _bindgen_ty_7 = 49 ; pub const SDLK_2 : _bindgen_ty_7 = 50 ; pub const SDLK_3 : _bindgen_ty_7 = 51 ; pub const SDLK_4 : _bindgen_ty_7 = 52 ; pub const SDLK_5 : _bindgen_ty_7 = 53 ; pub const SDLK_6 : _bindgen_ty_7 = 54 ; pub const SDLK_7 : _bindgen_ty_7 = 55 ; pub const SDLK_8 : _bindgen_ty_7 = 56 ; pub const SDLK_9 : _bindgen_ty_7 = 57 ; pub const SDLK_COLON : _bindgen_ty_7 = 58 ; pub const SDLK_SEMICOLON : _bindgen_ty_7 = 59 ; pub const SDLK_LESS : _bindgen_ty_7 = 60 ; pub const SDLK_EQUALS : _bindgen_ty_7 = 61 ; pub const SDLK_GREATER : _bindgen_ty_7 = 62 ; pub const SDLK_QUESTION : _bindgen_ty_7 = 63 ; pub const SDLK_AT : _bindgen_ty_7 = 64 ; pub const SDLK_LEFTBRACKET : _bindgen_ty_7 = 91 ; pub const SDLK_BACKSLASH : _bindgen_ty_7 = 92 ; pub const SDLK_RIGHTBRACKET : _bindgen_ty_7 = 93 ; pub const SDLK_CARET : _bindgen_ty_7 = 94 ; pub const SDLK_UNDERSCORE : _bindgen_ty_7 = 95 ; pub const SDLK_BACKQUOTE : _bindgen_ty_7 = 96 ; pub const SDLK_a : _bindgen_ty_7 = 97 ; pub const SDLK_b : _bindgen_ty_7 = 98 ; pub const SDLK_c : _bindgen_ty_7 = 99 ; pub const SDLK_d : _bindgen_ty_7 = 100 ; pub const SDLK_e : _bindgen_ty_7 = 101 ; pub const SDLK_f : _bindgen_ty_7 = 102 ; pub const SDLK_g : _bindgen_ty_7 = 103 ; pub const SDLK_h : _bindgen_ty_7 = 104 ; pub const SDLK_i : _bindgen_ty_7 = 105 ; pub const SDLK_j : _bindgen_ty_7 = 106 ; pub const SDLK_k : _bindgen_ty_7 = 107 ; pub const SDLK_l : _bindgen_ty_7 = 108 ; pub const SDLK_m : _bindgen_ty_7 = 109 ; pub const SDLK_n : _bindgen_ty_7 = 110 ; pub const SDLK_o : _bindgen_ty_7 = 111 ; pub const SDLK_p : _bindgen_ty_7 = 112 ; pub const SDLK_q : _bindgen_ty_7 = 113 ; pub const SDLK_r : _bindgen_ty_7 = 114 ; pub const SDLK_s : _bindgen_ty_7 = 115 ; pub const SDLK_t : _bindgen_ty_7 = 116 ; pub const SDLK_u : _bindgen_ty_7 = 117 ; pub const SDLK_v : _bindgen_ty_7 = 118 ; pub const SDLK_w : _bindgen_ty_7 = 119 ; pub const SDLK_x : _bindgen_ty_7 = 120 ; pub const SDLK_y : _bindgen_ty_7 = 121 ; pub const SDLK_z : _bindgen_ty_7 = 122 ; pub const SDLK_CAPSLOCK : _bindgen_ty_7 = 1073741881 ; pub const SDLK_F1 : _bindgen_ty_7 = 1073741882 ; pub const SDLK_F2 : _bindgen_ty_7 = 1073741883 ; pub const SDLK_F3 : _bindgen_ty_7 = 1073741884 ; pub const SDLK_F4 : _bindgen_ty_7 = 1073741885 ; pub const SDLK_F5 : _bindgen_ty_7 = 1073741886 ; pub const SDLK_F6 : _bindgen_ty_7 = 1073741887 ; pub const SDLK_F7 : _bindgen_ty_7 = 1073741888 ; pub const SDLK_F8 : _bindgen_ty_7 = 1073741889 ; pub const SDLK_F9 : _bindgen_ty_7 = 1073741890 ; pub const SDLK_F10 : _bindgen_ty_7 = 1073741891 ; pub const SDLK_F11 : _bindgen_ty_7 = 1073741892 ; pub const SDLK_F12 : _bindgen_ty_7 = 1073741893 ; pub const SDLK_PRINTSCREEN : _bindgen_ty_7 = 1073741894 ; pub const SDLK_SCROLLLOCK : _bindgen_ty_7 = 1073741895 ; pub const SDLK_PAUSE : _bindgen_ty_7 = 1073741896 ; pub const SDLK_INSERT : _bindgen_ty_7 = 1073741897 ; pub const SDLK_HOME : _bindgen_ty_7 = 1073741898 ; pub const SDLK_PAGEUP : _bindgen_ty_7 = 1073741899 ; pub const SDLK_DELETE : _bindgen_ty_7 = 127 ; pub const SDLK_END : _bindgen_ty_7 = 1073741901 ; pub const SDLK_PAGEDOWN : _bindgen_ty_7 = 1073741902 ; pub const SDLK_RIGHT : _bindgen_ty_7 = 1073741903 ; pub const SDLK_LEFT : _bindgen_ty_7 = 1073741904 ; pub const SDLK_DOWN : _bindgen_ty_7 = 1073741905 ; pub const SDLK_UP : _bindgen_ty_7 = 1073741906 ; pub const SDLK_NUMLOCKCLEAR : _bindgen_ty_7 = 1073741907 ; pub const SDLK_KP_DIVIDE : _bindgen_ty_7 = 1073741908 ; pub const SDLK_KP_MULTIPLY : _bindgen_ty_7 = 1073741909 ; pub const SDLK_KP_MINUS : _bindgen_ty_7 = 1073741910 ; pub const SDLK_KP_PLUS : _bindgen_ty_7 = 1073741911 ; pub const SDLK_KP_ENTER : _bindgen_ty_7 = 1073741912 ; pub const SDLK_KP_1 : _bindgen_ty_7 = 1073741913 ; pub const SDLK_KP_2 : _bindgen_ty_7 = 1073741914 ; pub const SDLK_KP_3 : _bindgen_ty_7 = 1073741915 ; pub const SDLK_KP_4 : _bindgen_ty_7 = 1073741916 ; pub const SDLK_KP_5 : _bindgen_ty_7 = 1073741917 ; pub const SDLK_KP_6 : _bindgen_ty_7 = 1073741918 ; pub const SDLK_KP_7 : _bindgen_ty_7 = 1073741919 ; pub const SDLK_KP_8 : _bindgen_ty_7 = 1073741920 ; pub const SDLK_KP_9 : _bindgen_ty_7 = 1073741921 ; pub const SDLK_KP_0 : _bindgen_ty_7 = 1073741922 ; pub const SDLK_KP_PERIOD : _bindgen_ty_7 = 1073741923 ; pub const SDLK_APPLICATION : _bindgen_ty_7 = 1073741925 ; pub const SDLK_POWER : _bindgen_ty_7 = 1073741926 ; pub const SDLK_KP_EQUALS : _bindgen_ty_7 = 1073741927 ; pub const SDLK_F13 : _bindgen_ty_7 = 1073741928 ; pub const SDLK_F14 : _bindgen_ty_7 = 1073741929 ; pub const SDLK_F15 : _bindgen_ty_7 = 1073741930 ; pub const SDLK_F16 : _bindgen_ty_7 = 1073741931 ; pub const SDLK_F17 : _bindgen_ty_7 = 1073741932 ; pub const SDLK_F18 : _bindgen_ty_7 = 1073741933 ; pub const SDLK_F19 : _bindgen_ty_7 = 1073741934 ; pub const SDLK_F20 : _bindgen_ty_7 = 1073741935 ; pub const SDLK_F21 : _bindgen_ty_7 = 1073741936 ; pub const SDLK_F22 : _bindgen_ty_7 = 1073741937 ; pub const SDLK_F23 : _bindgen_ty_7 = 1073741938 ; pub const SDLK_F24 : _bindgen_ty_7 = 1073741939 ; pub const SDLK_EXECUTE : _bindgen_ty_7 = 1073741940 ; pub const SDLK_HELP : _bindgen_ty_7 = 1073741941 ; pub const SDLK_MENU : _bindgen_ty_7 = 1073741942 ; pub const SDLK_SELECT : _bindgen_ty_7 = 1073741943 ; pub const SDLK_STOP : _bindgen_ty_7 = 1073741944 ; pub const SDLK_AGAIN : _bindgen_ty_7 = 1073741945 ; pub const SDLK_UNDO : _bindgen_ty_7 = 1073741946 ; pub const SDLK_CUT : _bindgen_ty_7 = 1073741947 ; pub const SDLK_COPY : _bindgen_ty_7 = 1073741948 ; pub const SDLK_PASTE : _bindgen_ty_7 = 1073741949 ; pub const SDLK_FIND : _bindgen_ty_7 = 1073741950 ; pub const SDLK_MUTE : _bindgen_ty_7 = 1073741951 ; pub const SDLK_VOLUMEUP : _bindgen_ty_7 = 1073741952 ; pub const SDLK_VOLUMEDOWN : _bindgen_ty_7 = 1073741953 ; pub const SDLK_KP_COMMA : _bindgen_ty_7 = 1073741957 ; pub const SDLK_KP_EQUALSAS400 : _bindgen_ty_7 = 1073741958 ; pub const SDLK_ALTERASE : _bindgen_ty_7 = 1073741977 ; pub const SDLK_SYSREQ : _bindgen_ty_7 = 1073741978 ; pub const SDLK_CANCEL : _bindgen_ty_7 = 1073741979 ; pub const SDLK_CLEAR : _bindgen_ty_7 = 1073741980 ; pub const SDLK_PRIOR : _bindgen_ty_7 = 1073741981 ; pub const SDLK_RETURN2 : _bindgen_ty_7 = 1073741982 ; pub const SDLK_SEPARATOR : _bindgen_ty_7 = 1073741983 ; pub const SDLK_OUT : _bindgen_ty_7 = 1073741984 ; pub const SDLK_OPER : _bindgen_ty_7 = 1073741985 ; pub const SDLK_CLEARAGAIN : _bindgen_ty_7 = 1073741986 ; pub const SDLK_CRSEL : _bindgen_ty_7 = 1073741987 ; pub const SDLK_EXSEL : _bindgen_ty_7 = 1073741988 ; pub const SDLK_KP_00 : _bindgen_ty_7 = 1073742000 ; pub const SDLK_KP_000 : _bindgen_ty_7 = 1073742001 ; pub const SDLK_THOUSANDSSEPARATOR : _bindgen_ty_7 = 1073742002 ; pub const SDLK_DECIMALSEPARATOR : _bindgen_ty_7 = 1073742003 ; pub const SDLK_CURRENCYUNIT : _bindgen_ty_7 = 1073742004 ; pub const SDLK_CURRENCYSUBUNIT : _bindgen_ty_7 = 1073742005 ; pub const SDLK_KP_LEFTPAREN : _bindgen_ty_7 = 1073742006 ; pub const SDLK_KP_RIGHTPAREN : _bindgen_ty_7 = 1073742007 ; pub const SDLK_KP_LEFTBRACE : _bindgen_ty_7 = 1073742008 ; pub const SDLK_KP_RIGHTBRACE : _bindgen_ty_7 = 1073742009 ; pub const SDLK_KP_TAB : _bindgen_ty_7 = 1073742010 ; pub const SDLK_KP_BACKSPACE : _bindgen_ty_7 = 1073742011 ; pub const SDLK_KP_A : _bindgen_ty_7 = 1073742012 ; pub const SDLK_KP_B : _bindgen_ty_7 = 1073742013 ; pub const SDLK_KP_C : _bindgen_ty_7 = 1073742014 ; pub const SDLK_KP_D : _bindgen_ty_7 = 1073742015 ; pub const SDLK_KP_E : _bindgen_ty_7 = 1073742016 ; pub const SDLK_KP_F : _bindgen_ty_7 = 1073742017 ; pub const SDLK_KP_XOR : _bindgen_ty_7 = 1073742018 ; pub const SDLK_KP_POWER : _bindgen_ty_7 = 1073742019 ; pub const SDLK_KP_PERCENT : _bindgen_ty_7 = 1073742020 ; pub const SDLK_KP_LESS : _bindgen_ty_7 = 1073742021 ; pub const SDLK_KP_GREATER : _bindgen_ty_7 = 1073742022 ; pub const SDLK_KP_AMPERSAND : _bindgen_ty_7 = 1073742023 ; pub const SDLK_KP_DBLAMPERSAND : _bindgen_ty_7 = 1073742024 ; pub const SDLK_KP_VERTICALBAR : _bindgen_ty_7 = 1073742025 ; pub const SDLK_KP_DBLVERTICALBAR : _bindgen_ty_7 = 1073742026 ; pub const SDLK_KP_COLON : _bindgen_ty_7 = 1073742027 ; pub const SDLK_KP_HASH : _bindgen_ty_7 = 1073742028 ; pub const SDLK_KP_SPACE : _bindgen_ty_7 = 1073742029 ; pub const SDLK_KP_AT : _bindgen_ty_7 = 1073742030 ; pub const SDLK_KP_EXCLAM : _bindgen_ty_7 = 1073742031 ; pub const SDLK_KP_MEMSTORE : _bindgen_ty_7 = 1073742032 ; pub const SDLK_KP_MEMRECALL : _bindgen_ty_7 = 1073742033 ; pub const SDLK_KP_MEMCLEAR : _bindgen_ty_7 = 1073742034 ; pub const SDLK_KP_MEMADD : _bindgen_ty_7 = 1073742035 ; pub const SDLK_KP_MEMSUBTRACT : _bindgen_ty_7 = 1073742036 ; pub const SDLK_KP_MEMMULTIPLY : _bindgen_ty_7 = 1073742037 ; pub const SDLK_KP_MEMDIVIDE : _bindgen_ty_7 = 1073742038 ; pub const SDLK_KP_PLUSMINUS : _bindgen_ty_7 = 1073742039 ; pub const SDLK_KP_CLEAR : _bindgen_ty_7 = 1073742040 ; pub const SDLK_KP_CLEARENTRY : _bindgen_ty_7 = 1073742041 ; pub const SDLK_KP_BINARY : _bindgen_ty_7 = 1073742042 ; pub const SDLK_KP_OCTAL : _bindgen_ty_7 = 1073742043 ; pub const SDLK_KP_DECIMAL : _bindgen_ty_7 = 1073742044 ; pub const SDLK_KP_HEXADECIMAL : _bindgen_ty_7 = 1073742045 ; pub const SDLK_LCTRL : _bindgen_ty_7 = 1073742048 ; pub const SDLK_LSHIFT : _bindgen_ty_7 = 1073742049 ; pub const SDLK_LALT : _bindgen_ty_7 = 1073742050 ; pub const SDLK_LGUI : _bindgen_ty_7 = 1073742051 ; pub const SDLK_RCTRL : _bindgen_ty_7 = 1073742052 ; pub const SDLK_RSHIFT : _bindgen_ty_7 = 1073742053 ; pub const SDLK_RALT : _bindgen_ty_7 = 1073742054 ; pub const SDLK_RGUI : _bindgen_ty_7 = 1073742055 ; pub const SDLK_MODE : _bindgen_ty_7 = 1073742081 ; pub const SDLK_AUDIONEXT : _bindgen_ty_7 = 1073742082 ; pub const SDLK_AUDIOPREV : _bindgen_ty_7 = 1073742083 ; pub const SDLK_AUDIOSTOP : _bindgen_ty_7 = 1073742084 ; pub const SDLK_AUDIOPLAY : _bindgen_ty_7 = 1073742085 ; pub const SDLK_AUDIOMUTE : _bindgen_ty_7 = 1073742086 ; pub const SDLK_MEDIASELECT : _bindgen_ty_7 = 1073742087 ; pub const SDLK_WWW : _bindgen_ty_7 = 1073742088 ; pub const SDLK_MAIL : _bindgen_ty_7 = 1073742089 ; pub const SDLK_CALCULATOR : _bindgen_ty_7 = 1073742090 ; pub const SDLK_COMPUTER : _bindgen_ty_7 = 1073742091 ; pub const SDLK_AC_SEARCH : _bindgen_ty_7 = 1073742092 ; pub const SDLK_AC_HOME : _bindgen_ty_7 = 1073742093 ; pub const SDLK_AC_BACK : _bindgen_ty_7 = 1073742094 ; pub const SDLK_AC_FORWARD : _bindgen_ty_7 = 1073742095 ; pub const SDLK_AC_STOP : _bindgen_ty_7 = 1073742096 ; pub const SDLK_AC_REFRESH : _bindgen_ty_7 = 1073742097 ; pub const SDLK_AC_BOOKMARKS : _bindgen_ty_7 = 1073742098 ; pub const SDLK_BRIGHTNESSDOWN : _bindgen_ty_7 = 1073742099 ; pub const SDLK_BRIGHTNESSUP : _bindgen_ty_7 = 1073742100 ; pub const SDLK_DISPLAYSWITCH : _bindgen_ty_7 = 1073742101 ; pub const SDLK_KBDILLUMTOGGLE : _bindgen_ty_7 = 1073742102 ; pub const SDLK_KBDILLUMDOWN : _bindgen_ty_7 = 1073742103 ; pub const SDLK_KBDILLUMUP : _bindgen_ty_7 = 1073742104 ; pub const SDLK_EJECT : _bindgen_ty_7 = 1073742105 ; pub const SDLK_SLEEP : _bindgen_ty_7 = 1073742106 ; pub const SDLK_APP1 : _bindgen_ty_7 = 1073742107 ; pub const SDLK_APP2 : _bindgen_ty_7 = 1073742108 ; pub const SDLK_AUDIOREWIND : _bindgen_ty_7 = 1073742109 ; pub const SDLK_AUDIOFASTFORWARD : _bindgen_ty_7 = 1073742110 ; pub type _bindgen_ty_7 = u32 ; pub const SDL_Keymod_KMOD_NONE : SDL_Keymod = 0 ; pub const SDL_Keymod_KMOD_LSHIFT : SDL_Keymod = 1 ; pub const SDL_Keymod_KMOD_RSHIFT : SDL_Keymod = 2 ; pub const SDL_Keymod_KMOD_LCTRL : SDL_Keymod = 64 ; pub const SDL_Keymod_KMOD_RCTRL : SDL_Keymod = 128 ; pub const SDL_Keymod_KMOD_LALT : SDL_Keymod = 256 ; pub const SDL_Keymod_KMOD_RALT : SDL_Keymod = 512 ; pub const SDL_Keymod_KMOD_LGUI : SDL_Keymod = 1024 ; pub const SDL_Keymod_KMOD_RGUI : SDL_Keymod = 2048 ; pub const SDL_Keymod_KMOD_NUM : SDL_Keymod = 4096 ; pub const SDL_Keymod_KMOD_CAPS : SDL_Keymod = 8192 ; pub const SDL_Keymod_KMOD_MODE : SDL_Keymod = 16384 ; pub const SDL_Keymod_KMOD_RESERVED : SDL_Keymod = 32768 ; 
 /// \brief Enumeration of valid key mods (possibly OR'd together). 
 pub type SDL_Keymod = u32 ; 
 /// \brief The SDL keysym structure, used in key events.
///
/// \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Keysym { 
 /// < SDL physical key code - see ::SDL_Scancode for details 
 pub scancode : SDL_Scancode , 
 /// < SDL virtual key code - see ::SDL_Keycode for details 
 pub sym : SDL_Keycode , 
 /// < current key modifiers 
 pub mod_ : Uint16 , pub unused : Uint32 , } # [ test ] fn bindgen_test_layout_SDL_Keysym ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Keysym > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_Keysym ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Keysym > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_Keysym ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Keysym > ( ) ) ) . scancode as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Keysym ) , "::" , stringify ! ( scancode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Keysym > ( ) ) ) . sym as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Keysym ) , "::" , stringify ! ( sym ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Keysym > ( ) ) ) . mod_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Keysym ) , "::" , stringify ! ( mod_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Keysym > ( ) ) ) . unused as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Keysym ) , "::" , stringify ! ( unused ) ) ) ; } extern "C" { 
 /// \brief Get the window which currently has keyboard focus. 
 pub fn SDL_GetKeyboardFocus ( ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Get a snapshot of the current state of the keyboard.
///
/// \param numkeys if non-NULL, receives the length of the returned array.
///
/// \return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.
///
/// \b Example:
/// \code
/// const Uint8 *state = SDL_GetKeyboardState(NULL);
/// if ( state[SDL_SCANCODE_RETURN] )   {
/// printf("<RETURN> is pressed.\n");
/// }
/// \endcode 
 pub fn SDL_GetKeyboardState ( numkeys : * mut ctypes :: c_int ) -> * const Uint8 ; } extern "C" { 
 /// \brief Get the current key modifier state for the keyboard. 
 pub fn SDL_GetModState ( ) -> SDL_Keymod ; } extern "C" { 
 /// \brief Set the current key modifier state for the keyboard.
///
/// \note This does not change the keyboard state, only the key modifier flags. 
 pub fn SDL_SetModState ( modstate : SDL_Keymod ) ; } extern "C" { 
 /// \brief Get the key code corresponding to the given scancode according
/// to the current keyboard layout.
///
/// See ::SDL_Keycode for details.
///
/// \sa SDL_GetKeyName() 
 pub fn SDL_GetKeyFromScancode ( scancode : SDL_Scancode ) -> SDL_Keycode ; } extern "C" { 
 /// \brief Get the scancode corresponding to the given key code according to the
/// current keyboard layout.
///
/// See ::SDL_Scancode for details.
///
/// \sa SDL_GetScancodeName() 
 pub fn SDL_GetScancodeFromKey ( key : SDL_Keycode ) -> SDL_Scancode ; } extern "C" { 
 /// \brief Get a human-readable name for a scancode.
///
/// \return A pointer to the name for the scancode.
/// If the scancode doesn't have a name, this function returns
/// an empty string ("").
///
/// \sa SDL_Scancode 
 pub fn SDL_GetScancodeName ( scancode : SDL_Scancode ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Get a scancode from a human-readable name
///
/// \return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized
///
/// \sa SDL_Scancode 
 pub fn SDL_GetScancodeFromName ( name : * const ctypes :: c_char ) -> SDL_Scancode ; } extern "C" { 
 /// \brief Get a human-readable name for a key.
///
/// \return A pointer to a UTF-8 string that stays valid at least until the next
/// call to this function. If you need it around any longer, you must
/// copy it.  If the key doesn't have a name, this function returns an
/// empty string ("").
///
/// \sa SDL_Keycode 
 pub fn SDL_GetKeyName ( key : SDL_Keycode ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Get a key code from a human-readable name
///
/// \return key code, or SDLK_UNKNOWN if the name wasn't recognized
///
/// \sa SDL_Keycode 
 pub fn SDL_GetKeyFromName ( name : * const ctypes :: c_char ) -> SDL_Keycode ; } extern "C" { 
 /// \brief Start accepting Unicode text input events.
/// This function will show the on-screen keyboard if supported.
///
/// \sa SDL_StopTextInput()
/// \sa SDL_SetTextInputRect()
/// \sa SDL_HasScreenKeyboardSupport() 
 pub fn SDL_StartTextInput ( ) ; } extern "C" { 
 /// \brief Return whether or not Unicode text input events are enabled.
///
/// \sa SDL_StartTextInput()
/// \sa SDL_StopTextInput() 
 pub fn SDL_IsTextInputActive ( ) -> SDL_bool ; } extern "C" { 
 /// \brief Stop receiving any text input events.
/// This function will hide the on-screen keyboard if supported.
///
/// \sa SDL_StartTextInput()
/// \sa SDL_HasScreenKeyboardSupport() 
 pub fn SDL_StopTextInput ( ) ; } extern "C" { 
 /// \brief Set the rectangle used to type Unicode text inputs.
/// This is used as a hint for IME and on-screen keyboard placement.
///
/// \sa SDL_StartTextInput() 
 pub fn SDL_SetTextInputRect ( rect : * mut SDL_Rect ) ; } extern "C" { 
 /// \brief Returns whether the platform has some screen keyboard support.
///
/// \return SDL_TRUE if some keyboard support is available else SDL_FALSE.
///
/// \note Not all screen keyboard functions are supported on all platforms.
///
/// \sa SDL_IsScreenKeyboardShown() 
 pub fn SDL_HasScreenKeyboardSupport ( ) -> SDL_bool ; } extern "C" { 
 /// \brief Returns whether the screen keyboard is shown for given window.
///
/// \param window The window for which screen keyboard should be queried.
///
/// \return SDL_TRUE if screen keyboard is shown else SDL_FALSE.
///
/// \sa SDL_HasScreenKeyboardSupport() 
 pub fn SDL_IsScreenKeyboardShown ( window : * mut SDL_Window ) -> SDL_bool ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Cursor { _unused : [ u8 ; 0 ] , } 
 /// < Arrow 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_ARROW : SDL_SystemCursor = 0 ; 
 /// < I-beam 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_IBEAM : SDL_SystemCursor = 1 ; 
 /// < Wait 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAIT : SDL_SystemCursor = 2 ; 
 /// < Crosshair 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_CROSSHAIR : SDL_SystemCursor = 3 ; 
 /// < Small wait cursor (or Wait if not available) 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAITARROW : SDL_SystemCursor = 4 ; 
 /// < Double arrow pointing northwest and southeast 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENWSE : SDL_SystemCursor = 5 ; 
 /// < Double arrow pointing northeast and southwest 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENESW : SDL_SystemCursor = 6 ; 
 /// < Double arrow pointing west and east 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZEWE : SDL_SystemCursor = 7 ; 
 /// < Double arrow pointing north and south 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENS : SDL_SystemCursor = 8 ; 
 /// < Four pointed arrow pointing north, south, east, and west 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZEALL : SDL_SystemCursor = 9 ; 
 /// < Slashed circle or crossbones 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NO : SDL_SystemCursor = 10 ; 
 /// < Hand 
 pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_HAND : SDL_SystemCursor = 11 ; pub const SDL_SystemCursor_SDL_NUM_SYSTEM_CURSORS : SDL_SystemCursor = 12 ; 
 /// \brief Cursor types for SDL_CreateSystemCursor(). 
 pub type SDL_SystemCursor = u32 ; 
 /// < The scroll direction is normal 
 pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_NORMAL : SDL_MouseWheelDirection = 0 ; 
 /// < The scroll direction is flipped / natural 
 pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_FLIPPED : SDL_MouseWheelDirection = 1 ; 
 /// \brief Scroll direction types for the Scroll event 
 pub type SDL_MouseWheelDirection = u32 ; extern "C" { 
 /// \brief Get the window which currently has mouse focus. 
 pub fn SDL_GetMouseFocus ( ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Retrieve the current state of the mouse.
///
/// The current button state is returned as a button bitmask, which can
/// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
/// mouse cursor position relative to the focus window for the currently
/// selected mouse.  You can pass NULL for either x or y. 
 pub fn SDL_GetMouseState ( x : * mut ctypes :: c_int , y : * mut ctypes :: c_int ) -> Uint32 ; } extern "C" { 
 /// \brief Get the current state of the mouse, in relation to the desktop
///
/// This works just like SDL_GetMouseState(), but the coordinates will be
/// reported relative to the top-left of the desktop. This can be useful if
/// you need to track the mouse outside of a specific window and
/// SDL_CaptureMouse() doesn't fit your needs. For example, it could be
/// useful if you need to track the mouse while dragging a window, where
/// coordinates relative to a window might not be in sync at all times.
///
/// \note SDL_GetMouseState() returns the mouse position as SDL understands
/// it from the last pump of the event queue. This function, however,
/// queries the OS for the current mouse position, and as such, might
/// be a slightly less efficient function. Unless you know what you're
/// doing and have a good reason to use this function, you probably want
/// SDL_GetMouseState() instead.
///
/// \param x Returns the current X coord, relative to the desktop. Can be NULL.
/// \param y Returns the current Y coord, relative to the desktop. Can be NULL.
/// \return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros.
///
/// \sa SDL_GetMouseState 
 pub fn SDL_GetGlobalMouseState ( x : * mut ctypes :: c_int , y : * mut ctypes :: c_int ) -> Uint32 ; } extern "C" { 
 /// \brief Retrieve the relative state of the mouse.
///
/// The current button state is returned as a button bitmask, which can
/// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
/// mouse deltas since the last call to SDL_GetRelativeMouseState(). 
 pub fn SDL_GetRelativeMouseState ( x : * mut ctypes :: c_int , y : * mut ctypes :: c_int ) -> Uint32 ; } extern "C" { 
 /// \brief Moves the mouse to the given position within the window.
///
/// \param window The window to move the mouse into, or NULL for the current mouse focus
/// \param x The x coordinate within the window
/// \param y The y coordinate within the window
///
/// \note This function generates a mouse motion event 
 pub fn SDL_WarpMouseInWindow ( window : * mut SDL_Window , x : ctypes :: c_int , y : ctypes :: c_int ) ; } extern "C" { 
 /// \brief Moves the mouse to the given position in global screen space.
///
/// \param x The x coordinate
/// \param y The y coordinate
/// \return 0 on success, -1 on error (usually: unsupported by a platform).
///
/// \note This function generates a mouse motion event 
 pub fn SDL_WarpMouseGlobal ( x : ctypes :: c_int , y : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set relative mouse mode.
///
/// \param enabled Whether or not to enable relative mode
///
/// \return 0 on success, or -1 if relative mode is not supported.
///
/// While the mouse is in relative mode, the cursor is hidden, and the
/// driver will try to report continuous motion in the current window.
/// Only relative motion events will be delivered, the mouse position
/// will not change.
///
/// \note This function will flush any pending mouse motion.
///
/// \sa SDL_GetRelativeMouseMode() 
 pub fn SDL_SetRelativeMouseMode ( enabled : SDL_bool ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Capture the mouse, to track input outside an SDL window.
///
/// \param enabled Whether or not to enable capturing
///
/// Capturing enables your app to obtain mouse events globally, instead of
/// just within your window. Not all video targets support this function.
/// When capturing is enabled, the current window will get all mouse events,
/// but unlike relative mode, no change is made to the cursor and it is
/// not restrained to your window.
///
/// This function may also deny mouse input to other windows--both those in
/// your application and others on the system--so you should use this
/// function sparingly, and in small bursts. For example, you might want to
/// track the mouse while the user is dragging something, until the user
/// releases a mouse button. It is not recommended that you capture the mouse
/// for long periods of time, such as the entire time your app is running.
///
/// While captured, mouse events still report coordinates relative to the
/// current (foreground) window, but those coordinates may be outside the
/// bounds of the window (including negative values). Capturing is only
/// allowed for the foreground window. If the window loses focus while
/// capturing, the capture will be disabled automatically.
///
/// While capturing is enabled, the current window will have the
/// SDL_WINDOW_MOUSE_CAPTURE flag set.
///
/// \return 0 on success, or -1 if not supported. 
 pub fn SDL_CaptureMouse ( enabled : SDL_bool ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Query whether relative mouse mode is enabled.
///
/// \sa SDL_SetRelativeMouseMode() 
 pub fn SDL_GetRelativeMouseMode ( ) -> SDL_bool ; } extern "C" { 
 /// \brief Create a cursor, using the specified bitmap data and
/// mask (in MSB format).
///
/// The cursor width must be a multiple of 8 bits.
///
/// The cursor is created in black and white according to the following:
/// <table>
/// <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>
/// <tr><td>  0   </td><td>  1   </td><td> White </td></tr>
/// <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>
/// <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>
/// <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black
/// if not. </td></tr>
/// </table>
///
/// \sa SDL_FreeCursor() 
 pub fn SDL_CreateCursor ( data : * const Uint8 , mask : * const Uint8 , w : ctypes :: c_int , h : ctypes :: c_int , hot_x : ctypes :: c_int , hot_y : ctypes :: c_int ) -> * mut SDL_Cursor ; } extern "C" { 
 /// \brief Create a color cursor.
///
/// \sa SDL_FreeCursor() 
 pub fn SDL_CreateColorCursor ( surface : * mut SDL_Surface , hot_x : ctypes :: c_int , hot_y : ctypes :: c_int ) -> * mut SDL_Cursor ; } extern "C" { 
 /// \brief Create a system cursor.
///
/// \sa SDL_FreeCursor() 
 pub fn SDL_CreateSystemCursor ( id : SDL_SystemCursor ) -> * mut SDL_Cursor ; } extern "C" { 
 /// \brief Set the active cursor. 
 pub fn SDL_SetCursor ( cursor : * mut SDL_Cursor ) ; } extern "C" { 
 /// \brief Return the active cursor. 
 pub fn SDL_GetCursor ( ) -> * mut SDL_Cursor ; } extern "C" { 
 /// \brief Return the default cursor. 
 pub fn SDL_GetDefaultCursor ( ) -> * mut SDL_Cursor ; } extern "C" { 
 /// \brief Frees a cursor created with SDL_CreateCursor() or similar functions.
///
/// \sa SDL_CreateCursor()
/// \sa SDL_CreateColorCursor()
/// \sa SDL_CreateSystemCursor() 
 pub fn SDL_FreeCursor ( cursor : * mut SDL_Cursor ) ; } extern "C" { 
 /// \brief Toggle whether or not the cursor is shown.
///
/// \param toggle 1 to show the cursor, 0 to hide it, -1 to query the current
/// state.
///
/// \return 1 if the cursor is shown, or 0 if the cursor is hidden. 
 pub fn SDL_ShowCursor ( toggle : ctypes :: c_int ) -> ctypes :: c_int ; } 
 /// The joystick structure used to identify an SDL joystick 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _SDL_Joystick { _unused : [ u8 ; 0 ] , } pub type SDL_Joystick = _SDL_Joystick ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_JoystickGUID { pub data : [ Uint8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_SDL_JoystickGUID ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_JoystickGUID > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_JoystickGUID ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_JoystickGUID > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_JoystickGUID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoystickGUID > ( ) ) ) . data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoystickGUID ) , "::" , stringify ! ( data ) ) ) ; } 
 /// This is a unique ID for a joystick for the time it is connected to the system,
/// and is never reused for the lifetime of the application. If the joystick is
/// disconnected and reconnected, it will get a new ID.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID. 
 pub type SDL_JoystickID = Sint32 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_UNKNOWN : SDL_JoystickType = 0 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GAMECONTROLLER : SDL_JoystickType = 1 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_WHEEL : SDL_JoystickType = 2 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_STICK : SDL_JoystickType = 3 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_FLIGHT_STICK : SDL_JoystickType = 4 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DANCE_PAD : SDL_JoystickType = 5 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GUITAR : SDL_JoystickType = 6 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DRUM_KIT : SDL_JoystickType = 7 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_PAD : SDL_JoystickType = 8 ; pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_THROTTLE : SDL_JoystickType = 9 ; pub type SDL_JoystickType = u32 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_UNKNOWN : SDL_JoystickPowerLevel = -1 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_EMPTY : SDL_JoystickPowerLevel = 0 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_LOW : SDL_JoystickPowerLevel = 1 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_MEDIUM : SDL_JoystickPowerLevel = 2 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_FULL : SDL_JoystickPowerLevel = 3 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_WIRED : SDL_JoystickPowerLevel = 4 ; pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_MAX : SDL_JoystickPowerLevel = 5 ; pub type SDL_JoystickPowerLevel = i32 ; extern "C" { 
 /// Locking for multi-threaded access to the joystick API
///
/// If you are using the joystick API or handling events from multiple threads
/// you should use these locking functions to protect access to the joysticks.
///
/// In particular, you are guaranteed that the joystick list won't change, so
/// the API functions that take a joystick index will be valid, and joystick
/// and game controller events will not be delivered. 
 pub fn SDL_LockJoysticks ( ) ; } extern "C" { pub fn SDL_UnlockJoysticks ( ) ; } extern "C" { 
 /// Count the number of joysticks attached to the system right now 
 pub fn SDL_NumJoysticks ( ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the implementation dependent name of a joystick.
/// This can be called before any joysticks are opened.
/// If no name can be found, this function returns NULL. 
 pub fn SDL_JoystickNameForIndex ( device_index : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Return the GUID for the joystick at this index
/// This can be called before any joysticks are opened. 
 pub fn SDL_JoystickGetDeviceGUID ( device_index : ctypes :: c_int ) -> SDL_JoystickGUID ; } extern "C" { 
 /// Get the USB vendor ID of a joystick, if available.
/// This can be called before any joysticks are opened.
/// If the vendor ID isn't available this function returns 0. 
 pub fn SDL_JoystickGetDeviceVendor ( device_index : ctypes :: c_int ) -> Uint16 ; } extern "C" { 
 /// Get the USB product ID of a joystick, if available.
/// This can be called before any joysticks are opened.
/// If the product ID isn't available this function returns 0. 
 pub fn SDL_JoystickGetDeviceProduct ( device_index : ctypes :: c_int ) -> Uint16 ; } extern "C" { 
 /// Get the product version of a joystick, if available.
/// This can be called before any joysticks are opened.
/// If the product version isn't available this function returns 0. 
 pub fn SDL_JoystickGetDeviceProductVersion ( device_index : ctypes :: c_int ) -> Uint16 ; } extern "C" { 
 /// Get the type of a joystick, if available.
/// This can be called before any joysticks are opened. 
 pub fn SDL_JoystickGetDeviceType ( device_index : ctypes :: c_int ) -> SDL_JoystickType ; } extern "C" { 
 /// Get the instance ID of a joystick.
/// This can be called before any joysticks are opened.
/// If the index is out of range, this function will return -1. 
 pub fn SDL_JoystickGetDeviceInstanceID ( device_index : ctypes :: c_int ) -> SDL_JoystickID ; } extern "C" { 
 /// Open a joystick for use.
/// The index passed as an argument refers to the N'th joystick on the system.
/// This index is not the value which will identify this joystick in future
/// joystick events.  The joystick's instance id (::SDL_JoystickID) will be used
/// there instead.
///
/// \return A joystick identifier, or NULL if an error occurred. 
 pub fn SDL_JoystickOpen ( device_index : ctypes :: c_int ) -> * mut SDL_Joystick ; } extern "C" { 
 /// Return the SDL_Joystick associated with an instance id. 
 pub fn SDL_JoystickFromInstanceID ( joyid : SDL_JoystickID ) -> * mut SDL_Joystick ; } extern "C" { 
 /// Return the name for this currently opened joystick.
/// If no name can be found, this function returns NULL. 
 pub fn SDL_JoystickName ( joystick : * mut SDL_Joystick ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Return the GUID for this opened joystick 
 pub fn SDL_JoystickGetGUID ( joystick : * mut SDL_Joystick ) -> SDL_JoystickGUID ; } extern "C" { 
 /// Get the USB vendor ID of an opened joystick, if available.
/// If the vendor ID isn't available this function returns 0. 
 pub fn SDL_JoystickGetVendor ( joystick : * mut SDL_Joystick ) -> Uint16 ; } extern "C" { 
 /// Get the USB product ID of an opened joystick, if available.
/// If the product ID isn't available this function returns 0. 
 pub fn SDL_JoystickGetProduct ( joystick : * mut SDL_Joystick ) -> Uint16 ; } extern "C" { 
 /// Get the product version of an opened joystick, if available.
/// If the product version isn't available this function returns 0. 
 pub fn SDL_JoystickGetProductVersion ( joystick : * mut SDL_Joystick ) -> Uint16 ; } extern "C" { 
 /// Get the type of an opened joystick. 
 pub fn SDL_JoystickGetType ( joystick : * mut SDL_Joystick ) -> SDL_JoystickType ; } extern "C" { 
 /// Return a string representation for this guid. pszGUID must point to at least 33 bytes
/// (32 for the string plus a NULL terminator). 
 pub fn SDL_JoystickGetGUIDString ( guid : SDL_JoystickGUID , pszGUID : * mut ctypes :: c_char , cbGUID : ctypes :: c_int ) ; } extern "C" { 
 /// Convert a string into a joystick guid 
 pub fn SDL_JoystickGetGUIDFromString ( pchGUID : * const ctypes :: c_char ) -> SDL_JoystickGUID ; } extern "C" { 
 /// Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not. 
 pub fn SDL_JoystickGetAttached ( joystick : * mut SDL_Joystick ) -> SDL_bool ; } extern "C" { 
 /// Get the instance ID of an opened joystick or -1 if the joystick is invalid. 
 pub fn SDL_JoystickInstanceID ( joystick : * mut SDL_Joystick ) -> SDL_JoystickID ; } extern "C" { 
 /// Get the number of general axis controls on a joystick. 
 pub fn SDL_JoystickNumAxes ( joystick : * mut SDL_Joystick ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the number of trackballs on a joystick.
///
/// Joystick trackballs have only relative motion events associated
/// with them and their state cannot be polled. 
 pub fn SDL_JoystickNumBalls ( joystick : * mut SDL_Joystick ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the number of POV hats on a joystick. 
 pub fn SDL_JoystickNumHats ( joystick : * mut SDL_Joystick ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the number of buttons on a joystick. 
 pub fn SDL_JoystickNumButtons ( joystick : * mut SDL_Joystick ) -> ctypes :: c_int ; } extern "C" { 
 /// Update the current state of the open joysticks.
///
/// This is called automatically by the event loop if any joystick
/// events are enabled. 
 pub fn SDL_JoystickUpdate ( ) ; } extern "C" { 
 /// Enable/disable joystick event polling.
///
/// If joystick events are disabled, you must call SDL_JoystickUpdate()
/// yourself and check the state of the joystick when you want joystick
/// information.
///
/// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE. 
 pub fn SDL_JoystickEventState ( state : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the current state of an axis control on a joystick.
///
/// The state is a value ranging from -32768 to 32767.
///
/// The axis indices start at index 0. 
 pub fn SDL_JoystickGetAxis ( joystick : * mut SDL_Joystick , axis : ctypes :: c_int ) -> Sint16 ; } extern "C" { 
 /// Get the initial state of an axis control on a joystick.
///
/// The state is a value ranging from -32768 to 32767.
///
/// The axis indices start at index 0.
///
/// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not. 
 pub fn SDL_JoystickGetAxisInitialState ( joystick : * mut SDL_Joystick , axis : ctypes :: c_int , state : * mut Sint16 ) -> SDL_bool ; } extern "C" { 
 /// Get the current state of a POV hat on a joystick.
///
/// The hat indices start at index 0.
///
/// \return The return value is one of the following positions:
/// - ::SDL_HAT_CENTERED
/// - ::SDL_HAT_UP
/// - ::SDL_HAT_RIGHT
/// - ::SDL_HAT_DOWN
/// - ::SDL_HAT_LEFT
/// - ::SDL_HAT_RIGHTUP
/// - ::SDL_HAT_RIGHTDOWN
/// - ::SDL_HAT_LEFTUP
/// - ::SDL_HAT_LEFTDOWN 
 pub fn SDL_JoystickGetHat ( joystick : * mut SDL_Joystick , hat : ctypes :: c_int ) -> Uint8 ; } extern "C" { 
 /// Get the ball axis change since the last poll.
///
/// \return 0, or -1 if you passed it invalid parameters.
///
/// The ball indices start at index 0. 
 pub fn SDL_JoystickGetBall ( joystick : * mut SDL_Joystick , ball : ctypes :: c_int , dx : * mut ctypes :: c_int , dy : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the current state of a button on a joystick.
///
/// The button indices start at index 0. 
 pub fn SDL_JoystickGetButton ( joystick : * mut SDL_Joystick , button : ctypes :: c_int ) -> Uint8 ; } extern "C" { 
 /// Close a joystick previously opened with SDL_JoystickOpen(). 
 pub fn SDL_JoystickClose ( joystick : * mut SDL_Joystick ) ; } extern "C" { 
 /// Return the battery level of this joystick 
 pub fn SDL_JoystickCurrentPowerLevel ( joystick : * mut SDL_Joystick ) -> SDL_JoystickPowerLevel ; } 
 /// The gamecontroller structure used to identify an SDL game controller 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _SDL_GameController { _unused : [ u8 ; 0 ] , } pub type SDL_GameController = _SDL_GameController ; pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_NONE : SDL_GameControllerBindType = 0 ; pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_BUTTON : SDL_GameControllerBindType = 1 ; pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_AXIS : SDL_GameControllerBindType = 2 ; pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_HAT : SDL_GameControllerBindType = 3 ; pub type SDL_GameControllerBindType = u32 ; 
 /// Get the SDL joystick layer binding for this controller button/axis mapping 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct SDL_GameControllerButtonBind { pub bindType : SDL_GameControllerBindType , pub value : SDL_GameControllerButtonBind__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union SDL_GameControllerButtonBind__bindgen_ty_1 { pub button : ctypes :: c_int , pub axis : ctypes :: c_int , pub hat : SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u32 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 { pub hat : ctypes :: c_int , pub hat_mask : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . hat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( hat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . hat_mask as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( hat_mask ) ) ) ; } # [ test ] fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_GameControllerButtonBind__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_GameControllerButtonBind__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind__bindgen_ty_1 > ( ) ) ) . button as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1 ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind__bindgen_ty_1 > ( ) ) ) . axis as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1 ) , "::" , stringify ! ( axis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind__bindgen_ty_1 > ( ) ) ) . hat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind__bindgen_ty_1 ) , "::" , stringify ! ( hat ) ) ) ; } # [ test ] fn bindgen_test_layout_SDL_GameControllerButtonBind ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_GameControllerButtonBind > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( SDL_GameControllerButtonBind ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_GameControllerButtonBind > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_GameControllerButtonBind ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind > ( ) ) ) . bindType as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind ) , "::" , stringify ! ( bindType ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_GameControllerButtonBind > ( ) ) ) . value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_GameControllerButtonBind ) , "::" , stringify ! ( value ) ) ) ; } extern "C" { 
 /// Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()
/// A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt
///
/// If \c freerw is non-zero, the stream will be closed after being read.
///
/// \return number of mappings added, -1 on error 
 pub fn SDL_GameControllerAddMappingsFromRW ( rw : * mut SDL_RWops , freerw : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Add or update an existing mapping configuration
///
/// \return 1 if mapping is added, 0 if updated, -1 on error 
 pub fn SDL_GameControllerAddMapping ( mappingString : * const ctypes :: c_char ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the number of mappings installed
///
/// \return the number of mappings 
 pub fn SDL_GameControllerNumMappings ( ) -> ctypes :: c_int ; } extern "C" { 
 /// Get the mapping at a particular index.
///
/// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range. 
 pub fn SDL_GameControllerMappingForIndex ( mapping_index : ctypes :: c_int ) -> * mut ctypes :: c_char ; } extern "C" { 
 /// Get a mapping string for a GUID
///
/// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available 
 pub fn SDL_GameControllerMappingForGUID ( guid : SDL_JoystickGUID ) -> * mut ctypes :: c_char ; } extern "C" { 
 /// Get a mapping string for an open GameController
///
/// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available 
 pub fn SDL_GameControllerMapping ( gamecontroller : * mut SDL_GameController ) -> * mut ctypes :: c_char ; } extern "C" { 
 /// Is the joystick on this index supported by the game controller interface? 
 pub fn SDL_IsGameController ( joystick_index : ctypes :: c_int ) -> SDL_bool ; } extern "C" { 
 /// Get the implementation dependent name of a game controller.
/// This can be called before any controllers are opened.
/// If no name can be found, this function returns NULL. 
 pub fn SDL_GameControllerNameForIndex ( joystick_index : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Open a game controller for use.
/// The index passed as an argument refers to the N'th game controller on the system.
/// This index is not the value which will identify this controller in future
/// controller events.  The joystick's instance id (::SDL_JoystickID) will be
/// used there instead.
///
/// \return A controller identifier, or NULL if an error occurred. 
 pub fn SDL_GameControllerOpen ( joystick_index : ctypes :: c_int ) -> * mut SDL_GameController ; } extern "C" { 
 /// Return the SDL_GameController associated with an instance id. 
 pub fn SDL_GameControllerFromInstanceID ( joyid : SDL_JoystickID ) -> * mut SDL_GameController ; } extern "C" { 
 /// Return the name for this currently opened controller 
 pub fn SDL_GameControllerName ( gamecontroller : * mut SDL_GameController ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Get the USB vendor ID of an opened controller, if available.
/// If the vendor ID isn't available this function returns 0. 
 pub fn SDL_GameControllerGetVendor ( gamecontroller : * mut SDL_GameController ) -> Uint16 ; } extern "C" { 
 /// Get the USB product ID of an opened controller, if available.
/// If the product ID isn't available this function returns 0. 
 pub fn SDL_GameControllerGetProduct ( gamecontroller : * mut SDL_GameController ) -> Uint16 ; } extern "C" { 
 /// Get the product version of an opened controller, if available.
/// If the product version isn't available this function returns 0. 
 pub fn SDL_GameControllerGetProductVersion ( gamecontroller : * mut SDL_GameController ) -> Uint16 ; } extern "C" { 
 /// Returns SDL_TRUE if the controller has been opened and currently connected,
/// or SDL_FALSE if it has not. 
 pub fn SDL_GameControllerGetAttached ( gamecontroller : * mut SDL_GameController ) -> SDL_bool ; } extern "C" { 
 /// Get the underlying joystick object used by a controller 
 pub fn SDL_GameControllerGetJoystick ( gamecontroller : * mut SDL_GameController ) -> * mut SDL_Joystick ; } extern "C" { 
 /// Enable/disable controller event polling.
///
/// If controller events are disabled, you must call SDL_GameControllerUpdate()
/// yourself and check the state of the controller when you want controller
/// information.
///
/// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE. 
 pub fn SDL_GameControllerEventState ( state : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// Update the current state of the open game controllers.
///
/// This is called automatically by the event loop if any game controller
/// events are enabled. 
 pub fn SDL_GameControllerUpdate ( ) ; } pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_INVALID : SDL_GameControllerAxis = -1 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_LEFTX : SDL_GameControllerAxis = 0 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_LEFTY : SDL_GameControllerAxis = 1 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_RIGHTX : SDL_GameControllerAxis = 2 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_RIGHTY : SDL_GameControllerAxis = 3 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_TRIGGERLEFT : SDL_GameControllerAxis = 4 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_TRIGGERRIGHT : SDL_GameControllerAxis = 5 ; pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_MAX : SDL_GameControllerAxis = 6 ; 
 /// The list of axes available from a controller
///
/// Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,
/// and are centered within ~8000 of zero, though advanced UI will allow users to set
/// or autodetect the dead zone, which varies between controllers.
///
/// Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX. 
 pub type SDL_GameControllerAxis = i32 ; extern "C" { 
 /// turn this string into a axis mapping 
 pub fn SDL_GameControllerGetAxisFromString ( pchString : * const ctypes :: c_char ) -> SDL_GameControllerAxis ; } extern "C" { 
 /// turn this axis enum into a string mapping 
 pub fn SDL_GameControllerGetStringForAxis ( axis : SDL_GameControllerAxis ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Get the SDL joystick layer binding for this controller button mapping 
 pub fn SDL_GameControllerGetBindForAxis ( gamecontroller : * mut SDL_GameController , axis : SDL_GameControllerAxis ) -> SDL_GameControllerButtonBind ; } extern "C" { 
 /// Get the current state of an axis control on a game controller.
///
/// The state is a value ranging from -32768 to 32767 (except for the triggers,
/// which range from 0 to 32767).
///
/// The axis indices start at index 0. 
 pub fn SDL_GameControllerGetAxis ( gamecontroller : * mut SDL_GameController , axis : SDL_GameControllerAxis ) -> Sint16 ; } pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_INVALID : SDL_GameControllerButton = -1 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_A : SDL_GameControllerButton = 0 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_B : SDL_GameControllerButton = 1 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_X : SDL_GameControllerButton = 2 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_Y : SDL_GameControllerButton = 3 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_BACK : SDL_GameControllerButton = 4 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_GUIDE : SDL_GameControllerButton = 5 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_START : SDL_GameControllerButton = 6 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_LEFTSTICK : SDL_GameControllerButton = 7 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_RIGHTSTICK : SDL_GameControllerButton = 8 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_LEFTSHOULDER : SDL_GameControllerButton = 9 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_RIGHTSHOULDER : SDL_GameControllerButton = 10 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_UP : SDL_GameControllerButton = 11 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_DOWN : SDL_GameControllerButton = 12 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_LEFT : SDL_GameControllerButton = 13 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_RIGHT : SDL_GameControllerButton = 14 ; pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_MAX : SDL_GameControllerButton = 15 ; 
 /// The list of buttons available from a controller 
 pub type SDL_GameControllerButton = i32 ; extern "C" { 
 /// turn this string into a button mapping 
 pub fn SDL_GameControllerGetButtonFromString ( pchString : * const ctypes :: c_char ) -> SDL_GameControllerButton ; } extern "C" { 
 /// turn this button enum into a string mapping 
 pub fn SDL_GameControllerGetStringForButton ( button : SDL_GameControllerButton ) -> * const ctypes :: c_char ; } extern "C" { 
 /// Get the SDL joystick layer binding for this controller button mapping 
 pub fn SDL_GameControllerGetBindForButton ( gamecontroller : * mut SDL_GameController , button : SDL_GameControllerButton ) -> SDL_GameControllerButtonBind ; } extern "C" { 
 /// Get the current state of a button on a game controller.
///
/// The button indices start at index 0. 
 pub fn SDL_GameControllerGetButton ( gamecontroller : * mut SDL_GameController , button : SDL_GameControllerButton ) -> Uint8 ; } extern "C" { 
 /// Close a controller previously opened with SDL_GameControllerOpen(). 
 pub fn SDL_GameControllerClose ( gamecontroller : * mut SDL_GameController ) ; } pub type SDL_TouchID = Sint64 ; pub type SDL_FingerID = Sint64 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Finger { pub id : SDL_FingerID , pub x : f32 , pub y : f32 , pub pressure : f32 , } # [ test ] fn bindgen_test_layout_SDL_Finger ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Finger > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_Finger ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Finger > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_Finger ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Finger > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Finger ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Finger > ( ) ) ) . x as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Finger ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Finger > ( ) ) ) . y as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Finger ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Finger > ( ) ) ) . pressure as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Finger ) , "::" , stringify ! ( pressure ) ) ) ; } extern "C" { 
 /// \brief Get the number of registered touch devices. 
 pub fn SDL_GetNumTouchDevices ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the touch ID with the given index, or 0 if the index is invalid. 
 pub fn SDL_GetTouchDevice ( index : ctypes :: c_int ) -> SDL_TouchID ; } extern "C" { 
 /// \brief Get the number of active fingers for a given touch device. 
 pub fn SDL_GetNumTouchFingers ( touchID : SDL_TouchID ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the finger object of the given touch, with the given index. 
 pub fn SDL_GetTouchFinger ( touchID : SDL_TouchID , index : ctypes :: c_int ) -> * mut SDL_Finger ; } pub type SDL_GestureID = Sint64 ; extern "C" { 
 /// \brief Begin Recording a gesture on the specified touch, or all touches (-1)
///
/// 
 pub fn SDL_RecordGesture ( touchId : SDL_TouchID ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Save all currently loaded Dollar Gesture templates
///
/// 
 pub fn SDL_SaveAllDollarTemplates ( dst : * mut SDL_RWops ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Save a currently loaded Dollar Gesture template
///
/// 
 pub fn SDL_SaveDollarTemplate ( gestureId : SDL_GestureID , dst : * mut SDL_RWops ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Load Dollar Gesture templates from a file
///
/// 
 pub fn SDL_LoadDollarTemplates ( touchId : SDL_TouchID , src : * mut SDL_RWops ) -> ctypes :: c_int ; } 
 /// < Unused (do not remove) 
 pub const SDL_EventType_SDL_FIRSTEVENT : SDL_EventType = 0 ; 
 /// < User-requested quit 
 pub const SDL_EventType_SDL_QUIT : SDL_EventType = 256 ; 
 /// < The application is being terminated by the OS
/// Called on iOS in applicationWillTerminate()
/// Called on Android in onDestroy() 
 pub const SDL_EventType_SDL_APP_TERMINATING : SDL_EventType = 257 ; 
 /// < The application is low on memory, free memory if possible.
/// Called on iOS in applicationDidReceiveMemoryWarning()
/// Called on Android in onLowMemory() 
 pub const SDL_EventType_SDL_APP_LOWMEMORY : SDL_EventType = 258 ; 
 /// < The application is about to enter the background
/// Called on iOS in applicationWillResignActive()
/// Called on Android in onPause() 
 pub const SDL_EventType_SDL_APP_WILLENTERBACKGROUND : SDL_EventType = 259 ; 
 /// < The application did enter the background and may not get CPU for some time
/// Called on iOS in applicationDidEnterBackground()
/// Called on Android in onPause() 
 pub const SDL_EventType_SDL_APP_DIDENTERBACKGROUND : SDL_EventType = 260 ; 
 /// < The application is about to enter the foreground
/// Called on iOS in applicationWillEnterForeground()
/// Called on Android in onResume() 
 pub const SDL_EventType_SDL_APP_WILLENTERFOREGROUND : SDL_EventType = 261 ; 
 /// < The application is now interactive
/// Called on iOS in applicationDidBecomeActive()
/// Called on Android in onResume() 
 pub const SDL_EventType_SDL_APP_DIDENTERFOREGROUND : SDL_EventType = 262 ; 
 /// < Window state change 
 pub const SDL_EventType_SDL_WINDOWEVENT : SDL_EventType = 512 ; 
 /// < System specific event 
 pub const SDL_EventType_SDL_SYSWMEVENT : SDL_EventType = 513 ; 
 /// < Key pressed 
 pub const SDL_EventType_SDL_KEYDOWN : SDL_EventType = 768 ; 
 /// < Key released 
 pub const SDL_EventType_SDL_KEYUP : SDL_EventType = 769 ; 
 /// < Keyboard text editing (composition) 
 pub const SDL_EventType_SDL_TEXTEDITING : SDL_EventType = 770 ; 
 /// < Keyboard text input 
 pub const SDL_EventType_SDL_TEXTINPUT : SDL_EventType = 771 ; 
 /// < Keymap changed due to a system event such as an
/// input language or keyboard layout change. 
 pub const SDL_EventType_SDL_KEYMAPCHANGED : SDL_EventType = 772 ; 
 /// < Mouse moved 
 pub const SDL_EventType_SDL_MOUSEMOTION : SDL_EventType = 1024 ; 
 /// < Mouse button pressed 
 pub const SDL_EventType_SDL_MOUSEBUTTONDOWN : SDL_EventType = 1025 ; 
 /// < Mouse button released 
 pub const SDL_EventType_SDL_MOUSEBUTTONUP : SDL_EventType = 1026 ; 
 /// < Mouse wheel motion 
 pub const SDL_EventType_SDL_MOUSEWHEEL : SDL_EventType = 1027 ; 
 /// < Joystick axis motion 
 pub const SDL_EventType_SDL_JOYAXISMOTION : SDL_EventType = 1536 ; 
 /// < Joystick trackball motion 
 pub const SDL_EventType_SDL_JOYBALLMOTION : SDL_EventType = 1537 ; 
 /// < Joystick hat position change 
 pub const SDL_EventType_SDL_JOYHATMOTION : SDL_EventType = 1538 ; 
 /// < Joystick button pressed 
 pub const SDL_EventType_SDL_JOYBUTTONDOWN : SDL_EventType = 1539 ; 
 /// < Joystick button released 
 pub const SDL_EventType_SDL_JOYBUTTONUP : SDL_EventType = 1540 ; 
 /// < A new joystick has been inserted into the system 
 pub const SDL_EventType_SDL_JOYDEVICEADDED : SDL_EventType = 1541 ; 
 /// < An opened joystick has been removed 
 pub const SDL_EventType_SDL_JOYDEVICEREMOVED : SDL_EventType = 1542 ; 
 /// < Game controller axis motion 
 pub const SDL_EventType_SDL_CONTROLLERAXISMOTION : SDL_EventType = 1616 ; 
 /// < Game controller button pressed 
 pub const SDL_EventType_SDL_CONTROLLERBUTTONDOWN : SDL_EventType = 1617 ; 
 /// < Game controller button released 
 pub const SDL_EventType_SDL_CONTROLLERBUTTONUP : SDL_EventType = 1618 ; 
 /// < A new Game controller has been inserted into the system 
 pub const SDL_EventType_SDL_CONTROLLERDEVICEADDED : SDL_EventType = 1619 ; 
 /// < An opened Game controller has been removed 
 pub const SDL_EventType_SDL_CONTROLLERDEVICEREMOVED : SDL_EventType = 1620 ; 
 /// < The controller mapping was updated 
 pub const SDL_EventType_SDL_CONTROLLERDEVICEREMAPPED : SDL_EventType = 1621 ; pub const SDL_EventType_SDL_FINGERDOWN : SDL_EventType = 1792 ; pub const SDL_EventType_SDL_FINGERUP : SDL_EventType = 1793 ; pub const SDL_EventType_SDL_FINGERMOTION : SDL_EventType = 1794 ; pub const SDL_EventType_SDL_DOLLARGESTURE : SDL_EventType = 2048 ; pub const SDL_EventType_SDL_DOLLARRECORD : SDL_EventType = 2049 ; pub const SDL_EventType_SDL_MULTIGESTURE : SDL_EventType = 2050 ; 
 /// < The clipboard changed 
 pub const SDL_EventType_SDL_CLIPBOARDUPDATE : SDL_EventType = 2304 ; 
 /// < The system requests a file open 
 pub const SDL_EventType_SDL_DROPFILE : SDL_EventType = 4096 ; 
 /// < text/plain drag-and-drop event 
 pub const SDL_EventType_SDL_DROPTEXT : SDL_EventType = 4097 ; 
 /// < A new set of drops is beginning (NULL filename) 
 pub const SDL_EventType_SDL_DROPBEGIN : SDL_EventType = 4098 ; 
 /// < Current set of drops is now complete (NULL filename) 
 pub const SDL_EventType_SDL_DROPCOMPLETE : SDL_EventType = 4099 ; 
 /// < A new audio device is available 
 pub const SDL_EventType_SDL_AUDIODEVICEADDED : SDL_EventType = 4352 ; 
 /// < An audio device has been removed. 
 pub const SDL_EventType_SDL_AUDIODEVICEREMOVED : SDL_EventType = 4353 ; 
 /// < The render targets have been reset and their contents need to be updated 
 pub const SDL_EventType_SDL_RENDER_TARGETS_RESET : SDL_EventType = 8192 ; 
 /// < The device has been reset and all textures need to be recreated 
 pub const SDL_EventType_SDL_RENDER_DEVICE_RESET : SDL_EventType = 8193 ; 
 /// Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
/// and should be allocated with SDL_RegisterEvents() 
 pub const SDL_EventType_SDL_USEREVENT : SDL_EventType = 32768 ; 
 /// This last event is only for bounding internal arrays 
 pub const SDL_EventType_SDL_LASTEVENT : SDL_EventType = 65535 ; 
 /// \brief The types of events that can be delivered. 
 pub type SDL_EventType = u32 ; 
 /// \brief Fields shared by every event 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_CommonEvent { pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , } # [ test ] fn bindgen_test_layout_SDL_CommonEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_CommonEvent > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_CommonEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_CommonEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_CommonEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_CommonEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_CommonEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_CommonEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_CommonEvent ) , "::" , stringify ! ( timestamp ) ) ) ; } 
 /// \brief Window state change event data (event.window.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_WindowEvent { 
 /// < ::SDL_WINDOWEVENT 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The associated window 
 pub windowID : Uint32 , 
 /// < ::SDL_WindowEventID 
 pub event : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , pub padding3 : Uint8 , 
 /// < event dependent data 
 pub data1 : Sint32 , 
 /// < event dependent data 
 pub data2 : Sint32 , } # [ test ] fn bindgen_test_layout_SDL_WindowEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_WindowEvent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_WindowEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_WindowEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_WindowEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . event as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( event ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . padding1 as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . padding2 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( padding2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . padding3 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( padding3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . data1 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( data1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowEvent > ( ) ) ) . data2 as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowEvent ) , "::" , stringify ! ( data2 ) ) ) ; } 
 /// \brief Keyboard button event structure (event.key.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_KeyboardEvent { 
 /// < ::SDL_KEYDOWN or ::SDL_KEYUP 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The window with keyboard focus, if any 
 pub windowID : Uint32 , 
 /// < ::SDL_PRESSED or ::SDL_RELEASED 
 pub state : Uint8 , 
 /// < Non-zero if this is a key repeat 
 pub repeat : Uint8 , pub padding2 : Uint8 , pub padding3 : Uint8 , 
 /// < The key that was pressed or released 
 pub keysym : SDL_Keysym , } # [ test ] fn bindgen_test_layout_SDL_KeyboardEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_KeyboardEvent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SDL_KeyboardEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_KeyboardEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_KeyboardEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . state as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . repeat as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( repeat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . padding2 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( padding2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . padding3 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( padding3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_KeyboardEvent > ( ) ) ) . keysym as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_KeyboardEvent ) , "::" , stringify ! ( keysym ) ) ) ; } 
 /// \brief Keyboard text editing event structure (event.edit.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_TextEditingEvent { 
 /// < ::SDL_TEXTEDITING 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The window with keyboard focus, if any 
 pub windowID : Uint32 , 
 /// < The editing text 
 pub text : [ ctypes :: c_char ; 32usize ] , 
 /// < The start cursor of selected editing text 
 pub start : Sint32 , 
 /// < The length of selected editing text 
 pub length : Sint32 , } # [ test ] fn bindgen_test_layout_SDL_TextEditingEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_TextEditingEvent > ( ) , 52usize , concat ! ( "Size of: " , stringify ! ( SDL_TextEditingEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_TextEditingEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_TextEditingEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextEditingEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextEditingEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextEditingEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextEditingEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextEditingEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextEditingEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextEditingEvent > ( ) ) ) . text as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextEditingEvent ) , "::" , stringify ! ( text ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextEditingEvent > ( ) ) ) . start as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextEditingEvent ) , "::" , stringify ! ( start ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextEditingEvent > ( ) ) ) . length as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextEditingEvent ) , "::" , stringify ! ( length ) ) ) ; } 
 /// \brief Keyboard text input event structure (event.text.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_TextInputEvent { 
 /// < ::SDL_TEXTINPUT 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The window with keyboard focus, if any 
 pub windowID : Uint32 , 
 /// < The input text 
 pub text : [ ctypes :: c_char ; 32usize ] , } # [ test ] fn bindgen_test_layout_SDL_TextInputEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_TextInputEvent > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( SDL_TextInputEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_TextInputEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_TextInputEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextInputEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextInputEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextInputEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextInputEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextInputEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextInputEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TextInputEvent > ( ) ) ) . text as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TextInputEvent ) , "::" , stringify ! ( text ) ) ) ; } 
 /// \brief Mouse motion event structure (event.motion.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MouseMotionEvent { 
 /// < ::SDL_MOUSEMOTION 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The window with mouse focus, if any 
 pub windowID : Uint32 , 
 /// < The mouse instance id, or SDL_TOUCH_MOUSEID 
 pub which : Uint32 , 
 /// < The current button state 
 pub state : Uint32 , 
 /// < X coordinate, relative to window 
 pub x : Sint32 , 
 /// < Y coordinate, relative to window 
 pub y : Sint32 , 
 /// < The relative motion in the X direction 
 pub xrel : Sint32 , 
 /// < The relative motion in the Y direction 
 pub yrel : Sint32 , } # [ test ] fn bindgen_test_layout_SDL_MouseMotionEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MouseMotionEvent > ( ) , 36usize , concat ! ( "Size of: " , stringify ! ( SDL_MouseMotionEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MouseMotionEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_MouseMotionEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . which as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . state as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . x as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . y as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . xrel as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( xrel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseMotionEvent > ( ) ) ) . yrel as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseMotionEvent ) , "::" , stringify ! ( yrel ) ) ) ; } 
 /// \brief Mouse button event structure (event.button.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MouseButtonEvent { 
 /// < ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The window with mouse focus, if any 
 pub windowID : Uint32 , 
 /// < The mouse instance id, or SDL_TOUCH_MOUSEID 
 pub which : Uint32 , 
 /// < The mouse button index 
 pub button : Uint8 , 
 /// < ::SDL_PRESSED or ::SDL_RELEASED 
 pub state : Uint8 , 
 /// < 1 for single-click, 2 for double-click, etc. 
 pub clicks : Uint8 , pub padding1 : Uint8 , 
 /// < X coordinate, relative to window 
 pub x : Sint32 , 
 /// < Y coordinate, relative to window 
 pub y : Sint32 , } # [ test ] fn bindgen_test_layout_SDL_MouseButtonEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MouseButtonEvent > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( SDL_MouseButtonEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MouseButtonEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_MouseButtonEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . which as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . button as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . state as * const _ as usize } , 17usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . clicks as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( clicks ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . padding1 as * const _ as usize } , 19usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . x as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseButtonEvent > ( ) ) ) . y as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseButtonEvent ) , "::" , stringify ! ( y ) ) ) ; } 
 /// \brief Mouse wheel event structure (event.wheel.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MouseWheelEvent { 
 /// < ::SDL_MOUSEWHEEL 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The window with mouse focus, if any 
 pub windowID : Uint32 , 
 /// < The mouse instance id, or SDL_TOUCH_MOUSEID 
 pub which : Uint32 , 
 /// < The amount scrolled horizontally, positive to the right and negative to the left 
 pub x : Sint32 , 
 /// < The amount scrolled vertically, positive away from the user and negative toward the user 
 pub y : Sint32 , 
 /// < Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back 
 pub direction : Uint32 , } # [ test ] fn bindgen_test_layout_SDL_MouseWheelEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MouseWheelEvent > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( SDL_MouseWheelEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MouseWheelEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_MouseWheelEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . which as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . x as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . y as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MouseWheelEvent > ( ) ) ) . direction as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MouseWheelEvent ) , "::" , stringify ! ( direction ) ) ) ; } 
 /// \brief Joystick axis motion event structure (event.jaxis.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_JoyAxisEvent { 
 /// < ::SDL_JOYAXISMOTION 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick instance id 
 pub which : SDL_JoystickID , 
 /// < The joystick axis index 
 pub axis : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , pub padding3 : Uint8 , 
 /// < The axis value (range: -32768 to 32767) 
 pub value : Sint16 , pub padding4 : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_JoyAxisEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_JoyAxisEvent > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( SDL_JoyAxisEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_JoyAxisEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_JoyAxisEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . axis as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( axis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . padding1 as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . padding2 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( padding2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . padding3 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( padding3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . value as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyAxisEvent > ( ) ) ) . padding4 as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyAxisEvent ) , "::" , stringify ! ( padding4 ) ) ) ; } 
 /// \brief Joystick trackball motion event structure (event.jball.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_JoyBallEvent { 
 /// < ::SDL_JOYBALLMOTION 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick instance id 
 pub which : SDL_JoystickID , 
 /// < The joystick trackball index 
 pub ball : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , pub padding3 : Uint8 , 
 /// < The relative motion in the X direction 
 pub xrel : Sint16 , 
 /// < The relative motion in the Y direction 
 pub yrel : Sint16 , } # [ test ] fn bindgen_test_layout_SDL_JoyBallEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_JoyBallEvent > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( SDL_JoyBallEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_JoyBallEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_JoyBallEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . ball as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( ball ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . padding1 as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . padding2 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( padding2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . padding3 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( padding3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . xrel as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( xrel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyBallEvent > ( ) ) ) . yrel as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyBallEvent ) , "::" , stringify ! ( yrel ) ) ) ; } 
 /// \brief Joystick hat position change event structure (event.jhat.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_JoyHatEvent { 
 /// < ::SDL_JOYHATMOTION 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick instance id 
 pub which : SDL_JoystickID , 
 /// < The joystick hat index 
 pub hat : Uint8 , 
 /// < The hat position value.
    /// \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
    /// \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
    /// \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
    ///
    /// Note that zero means the POV is centered. 
 pub value : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_JoyHatEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_JoyHatEvent > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_JoyHatEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_JoyHatEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_JoyHatEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . hat as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( hat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . value as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . padding1 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyHatEvent > ( ) ) ) . padding2 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyHatEvent ) , "::" , stringify ! ( padding2 ) ) ) ; } 
 /// \brief Joystick button event structure (event.jbutton.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_JoyButtonEvent { 
 /// < ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick instance id 
 pub which : SDL_JoystickID , 
 /// < The joystick button index 
 pub button : Uint8 , 
 /// < ::SDL_PRESSED or ::SDL_RELEASED 
 pub state : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_JoyButtonEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_JoyButtonEvent > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_JoyButtonEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_JoyButtonEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_JoyButtonEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . button as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . state as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . padding1 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyButtonEvent > ( ) ) ) . padding2 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyButtonEvent ) , "::" , stringify ! ( padding2 ) ) ) ; } 
 /// \brief Joystick device event structure (event.jdevice.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_JoyDeviceEvent { 
 /// < ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick device index for the ADDED event, instance id for the REMOVED event 
 pub which : Sint32 , } # [ test ] fn bindgen_test_layout_SDL_JoyDeviceEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_JoyDeviceEvent > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( SDL_JoyDeviceEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_JoyDeviceEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_JoyDeviceEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyDeviceEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyDeviceEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyDeviceEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyDeviceEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_JoyDeviceEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_JoyDeviceEvent ) , "::" , stringify ! ( which ) ) ) ; } 
 /// \brief Game controller axis motion event structure (event.caxis.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_ControllerAxisEvent { 
 /// < ::SDL_CONTROLLERAXISMOTION 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick instance id 
 pub which : SDL_JoystickID , 
 /// < The controller axis (SDL_GameControllerAxis) 
 pub axis : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , pub padding3 : Uint8 , 
 /// < The axis value (range: -32768 to 32767) 
 pub value : Sint16 , pub padding4 : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_ControllerAxisEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_ControllerAxisEvent > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( SDL_ControllerAxisEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_ControllerAxisEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_ControllerAxisEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . axis as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( axis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . padding1 as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . padding2 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( padding2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . padding3 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( padding3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . value as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerAxisEvent > ( ) ) ) . padding4 as * const _ as usize } , 18usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerAxisEvent ) , "::" , stringify ! ( padding4 ) ) ) ; } 
 /// \brief Game controller button event structure (event.cbutton.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_ControllerButtonEvent { 
 /// < ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick instance id 
 pub which : SDL_JoystickID , 
 /// < The controller button (SDL_GameControllerButton) 
 pub button : Uint8 , 
 /// < ::SDL_PRESSED or ::SDL_RELEASED 
 pub state : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_ControllerButtonEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_ControllerButtonEvent > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_ControllerButtonEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_ControllerButtonEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_ControllerButtonEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . button as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . state as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . padding1 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerButtonEvent > ( ) ) ) . padding2 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerButtonEvent ) , "::" , stringify ! ( padding2 ) ) ) ; } 
 /// \brief Controller device event structure (event.cdevice.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_ControllerDeviceEvent { 
 /// < ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event 
 pub which : Sint32 , } # [ test ] fn bindgen_test_layout_SDL_ControllerDeviceEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_ControllerDeviceEvent > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( SDL_ControllerDeviceEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_ControllerDeviceEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_ControllerDeviceEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerDeviceEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerDeviceEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerDeviceEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerDeviceEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_ControllerDeviceEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_ControllerDeviceEvent ) , "::" , stringify ! ( which ) ) ) ; } 
 /// \brief Audio device event structure (event.adevice.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_AudioDeviceEvent { 
 /// < ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event 
 pub which : Uint32 , 
 /// < zero if an output device, non-zero if a capture device. 
 pub iscapture : Uint8 , pub padding1 : Uint8 , pub padding2 : Uint8 , pub padding3 : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_AudioDeviceEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_AudioDeviceEvent > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_AudioDeviceEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_AudioDeviceEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_AudioDeviceEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . which as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( which ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . iscapture as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( iscapture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . padding1 as * const _ as usize } , 13usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( padding1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . padding2 as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( padding2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_AudioDeviceEvent > ( ) ) ) . padding3 as * const _ as usize } , 15usize , concat ! ( "Offset of field: " , stringify ! ( SDL_AudioDeviceEvent ) , "::" , stringify ! ( padding3 ) ) ) ; } 
 /// \brief Touch finger event structure (event.tfinger.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_TouchFingerEvent { 
 /// < ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The touch device id 
 pub touchId : SDL_TouchID , pub fingerId : SDL_FingerID , 
 /// < Normalized in the range 0...1 
 pub x : f32 , 
 /// < Normalized in the range 0...1 
 pub y : f32 , 
 /// < Normalized in the range -1...1 
 pub dx : f32 , 
 /// < Normalized in the range -1...1 
 pub dy : f32 , 
 /// < Normalized in the range 0...1 
 pub pressure : f32 , } # [ test ] fn bindgen_test_layout_SDL_TouchFingerEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_TouchFingerEvent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SDL_TouchFingerEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_TouchFingerEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_TouchFingerEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . touchId as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( touchId ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . fingerId as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( fingerId ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . x as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . y as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . dx as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( dx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . dy as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( dy ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_TouchFingerEvent > ( ) ) ) . pressure as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_TouchFingerEvent ) , "::" , stringify ! ( pressure ) ) ) ; } 
 /// \brief Multiple Finger Gesture Event (event.mgesture.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MultiGestureEvent { 
 /// < ::SDL_MULTIGESTURE 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The touch device id 
 pub touchId : SDL_TouchID , pub dTheta : f32 , pub dDist : f32 , pub x : f32 , pub y : f32 , pub numFingers : Uint16 , pub padding : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_MultiGestureEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MultiGestureEvent > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SDL_MultiGestureEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MultiGestureEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_MultiGestureEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . touchId as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( touchId ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . dTheta as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( dTheta ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . dDist as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( dDist ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . x as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . y as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . numFingers as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( numFingers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MultiGestureEvent > ( ) ) ) . padding as * const _ as usize } , 34usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MultiGestureEvent ) , "::" , stringify ! ( padding ) ) ) ; } 
 /// \brief Dollar Gesture Event (event.dgesture.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_DollarGestureEvent { 
 /// < ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The touch device id 
 pub touchId : SDL_TouchID , pub gestureId : SDL_GestureID , pub numFingers : Uint32 , pub error : f32 , 
 /// < Normalized center of gesture 
 pub x : f32 , 
 /// < Normalized center of gesture 
 pub y : f32 , } # [ test ] fn bindgen_test_layout_SDL_DollarGestureEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_DollarGestureEvent > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SDL_DollarGestureEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_DollarGestureEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_DollarGestureEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . touchId as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( touchId ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . gestureId as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( gestureId ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . numFingers as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( numFingers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . error as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . x as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DollarGestureEvent > ( ) ) ) . y as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DollarGestureEvent ) , "::" , stringify ! ( y ) ) ) ; } 
 /// \brief An event used to request a file open by the system (event.drop.*)
/// This event is enabled by default, you can disable it with SDL_EventState().
/// \note If this event is enabled, you must free the filename in the event. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_DropEvent { 
 /// < ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The file name, which should be freed with SDL_free(), is NULL on begin/complete 
 pub file : * mut ctypes :: c_char , 
 /// < The window that was dropped on, if any 
 pub windowID : Uint32 , } # [ test ] fn bindgen_test_layout_SDL_DropEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_DropEvent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SDL_DropEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_DropEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_DropEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DropEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DropEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DropEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DropEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DropEvent > ( ) ) ) . file as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DropEvent ) , "::" , stringify ! ( file ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_DropEvent > ( ) ) ) . windowID as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_DropEvent ) , "::" , stringify ! ( windowID ) ) ) ; } 
 /// \brief The "quit requested" event 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_QuitEvent { 
 /// < ::SDL_QUIT 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , } # [ test ] fn bindgen_test_layout_SDL_QuitEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_QuitEvent > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_QuitEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_QuitEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_QuitEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_QuitEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_QuitEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_QuitEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_QuitEvent ) , "::" , stringify ! ( timestamp ) ) ) ; } 
 /// \brief OS Specific event 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_OSEvent { 
 /// < ::SDL_QUIT 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , } # [ test ] fn bindgen_test_layout_SDL_OSEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_OSEvent > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_OSEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_OSEvent > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_OSEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_OSEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_OSEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_OSEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_OSEvent ) , "::" , stringify ! ( timestamp ) ) ) ; } 
 /// \brief A user-defined event type (event.user.*) 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_UserEvent { 
 /// < ::SDL_USEREVENT through ::SDL_LASTEVENT-1 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < The associated window if any 
 pub windowID : Uint32 , 
 /// < User defined event code 
 pub code : Sint32 , 
 /// < User defined data pointer 
 pub data1 : * mut ctypes :: c_void , 
 /// < User defined data pointer 
 pub data2 : * mut ctypes :: c_void , } # [ test ] fn bindgen_test_layout_SDL_UserEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_UserEvent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SDL_UserEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_UserEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_UserEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_UserEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_UserEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_UserEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_UserEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_UserEvent > ( ) ) ) . windowID as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_UserEvent ) , "::" , stringify ! ( windowID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_UserEvent > ( ) ) ) . code as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_UserEvent ) , "::" , stringify ! ( code ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_UserEvent > ( ) ) ) . data1 as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_UserEvent ) , "::" , stringify ! ( data1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_UserEvent > ( ) ) ) . data2 as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_UserEvent ) , "::" , stringify ! ( data2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_SysWMmsg { _unused : [ u8 ; 0 ] , } 
 /// \brief A video driver dependent system event (event.syswm.*)
/// This event is disabled by default, you can enable it with SDL_EventState()
///
/// \note If you want to use this event, you should include SDL_syswm.h. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_SysWMEvent { 
 /// < ::SDL_SYSWMEVENT 
 pub type_ : Uint32 , 
 /// < In milliseconds, populated using SDL_GetTicks() 
 pub timestamp : Uint32 , 
 /// < driver dependent data, defined in SDL_syswm.h 
 pub msg : * mut SDL_SysWMmsg , } # [ test ] fn bindgen_test_layout_SDL_SysWMEvent ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_SysWMEvent > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_SysWMEvent ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_SysWMEvent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_SysWMEvent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_SysWMEvent > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_SysWMEvent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_SysWMEvent > ( ) ) ) . timestamp as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_SysWMEvent ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_SysWMEvent > ( ) ) ) . msg as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_SysWMEvent ) , "::" , stringify ! ( msg ) ) ) ; } 
 /// \brief General event structure 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union SDL_Event { 
 /// < Event type, shared with all events 
 pub type_ : Uint32 , 
 /// < Common event data 
 pub common : SDL_CommonEvent , 
 /// < Window event data 
 pub window : SDL_WindowEvent , 
 /// < Keyboard event data 
 pub key : SDL_KeyboardEvent , 
 /// < Text editing event data 
 pub edit : SDL_TextEditingEvent , 
 /// < Text input event data 
 pub text : SDL_TextInputEvent , 
 /// < Mouse motion event data 
 pub motion : SDL_MouseMotionEvent , 
 /// < Mouse button event data 
 pub button : SDL_MouseButtonEvent , 
 /// < Mouse wheel event data 
 pub wheel : SDL_MouseWheelEvent , 
 /// < Joystick axis event data 
 pub jaxis : SDL_JoyAxisEvent , 
 /// < Joystick ball event data 
 pub jball : SDL_JoyBallEvent , 
 /// < Joystick hat event data 
 pub jhat : SDL_JoyHatEvent , 
 /// < Joystick button event data 
 pub jbutton : SDL_JoyButtonEvent , 
 /// < Joystick device change event data 
 pub jdevice : SDL_JoyDeviceEvent , 
 /// < Game Controller axis event data 
 pub caxis : SDL_ControllerAxisEvent , 
 /// < Game Controller button event data 
 pub cbutton : SDL_ControllerButtonEvent , 
 /// < Game Controller device event data 
 pub cdevice : SDL_ControllerDeviceEvent , 
 /// < Audio device event data 
 pub adevice : SDL_AudioDeviceEvent , 
 /// < Quit request event data 
 pub quit : SDL_QuitEvent , 
 /// < Custom event data 
 pub user : SDL_UserEvent , 
 /// < System dependent window event data 
 pub syswm : SDL_SysWMEvent , 
 /// < Touch finger event data 
 pub tfinger : SDL_TouchFingerEvent , 
 /// < Gesture event data 
 pub mgesture : SDL_MultiGestureEvent , 
 /// < Gesture event data 
 pub dgesture : SDL_DollarGestureEvent , 
 /// < Drag and drop event data 
 pub drop : SDL_DropEvent , pub padding : [ Uint8 ; 56usize ] , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_SDL_Event ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_Event > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SDL_Event ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_Event > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_Event ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . common as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( common ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . window as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( window ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . key as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . edit as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( edit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . text as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( text ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . motion as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( motion ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . button as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . wheel as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( wheel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . jaxis as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( jaxis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . jball as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( jball ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . jhat as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( jhat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . jbutton as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( jbutton ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . jdevice as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( jdevice ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . caxis as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( caxis ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . cbutton as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( cbutton ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . cdevice as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( cdevice ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . adevice as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( adevice ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . quit as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( quit ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . user as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( user ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . syswm as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( syswm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . tfinger as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( tfinger ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . mgesture as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( mgesture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . dgesture as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( dgesture ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . drop as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( drop ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_Event > ( ) ) ) . padding as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_Event ) , "::" , stringify ! ( padding ) ) ) ; } extern "C" { 
 /// Pumps the event loop, gathering events from the input devices.
///
/// This function updates the event queue and internal input device state.
///
/// This should only be run in the thread that sets the video mode. 
 pub fn SDL_PumpEvents ( ) ; } pub const SDL_eventaction_SDL_ADDEVENT : SDL_eventaction = 0 ; pub const SDL_eventaction_SDL_PEEKEVENT : SDL_eventaction = 1 ; pub const SDL_eventaction_SDL_GETEVENT : SDL_eventaction = 2 ; pub type SDL_eventaction = u32 ; extern "C" { 
 /// Checks the event queue for messages and optionally returns them.
///
/// If \c action is ::SDL_ADDEVENT, up to \c numevents events will be added to
/// the back of the event queue.
///
/// If \c action is ::SDL_PEEKEVENT, up to \c numevents events at the front
/// of the event queue, within the specified minimum and maximum type,
/// will be returned and will not be removed from the queue.
///
/// If \c action is ::SDL_GETEVENT, up to \c numevents events at the front
/// of the event queue, within the specified minimum and maximum type,
/// will be returned and will be removed from the queue.
///
/// \return The number of events actually stored, or -1 if there was an error.
///
/// This function is thread-safe. 
 pub fn SDL_PeepEvents ( events : * mut SDL_Event , numevents : ctypes :: c_int , action : SDL_eventaction , minType : Uint32 , maxType : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// Checks to see if certain event types are in the event queue. 
 pub fn SDL_HasEvent ( type_ : Uint32 ) -> SDL_bool ; } extern "C" { pub fn SDL_HasEvents ( minType : Uint32 , maxType : Uint32 ) -> SDL_bool ; } extern "C" { 
 /// This function clears events from the event queue
/// This function only affects currently queued events. If you want to make
/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
/// on the main thread immediately before the flush call. 
 pub fn SDL_FlushEvent ( type_ : Uint32 ) ; } extern "C" { pub fn SDL_FlushEvents ( minType : Uint32 , maxType : Uint32 ) ; } extern "C" { 
 /// \brief Polls for currently pending events.
///
/// \return 1 if there are any pending events, or 0 if there are none available.
///
/// \param event If not NULL, the next event is removed from the queue and
/// stored in that area. 
 pub fn SDL_PollEvent ( event : * mut SDL_Event ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Waits indefinitely for the next available event.
///
/// \return 1, or 0 if there was an error while waiting for events.
///
/// \param event If not NULL, the next event is removed from the queue and
/// stored in that area. 
 pub fn SDL_WaitEvent ( event : * mut SDL_Event ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Waits until the specified timeout (in milliseconds) for the next
/// available event.
///
/// \return 1, or 0 if there was an error while waiting for events.
///
/// \param event If not NULL, the next event is removed from the queue and
/// stored in that area.
/// \param timeout The timeout (in milliseconds) to wait for next event. 
 pub fn SDL_WaitEventTimeout ( event : * mut SDL_Event , timeout : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Add an event to the event queue.
///
/// \return 1 on success, 0 if the event was filtered, or -1 if the event queue
/// was full or there was some other error. 
 pub fn SDL_PushEvent ( event : * mut SDL_Event ) -> ctypes :: c_int ; } pub type SDL_EventFilter = :: core :: option :: Option < unsafe extern "C" fn ( userdata : * mut ctypes :: c_void , event : * mut SDL_Event ) -> ctypes :: c_int > ; extern "C" { 
 /// Sets up a filter to process all events before they change internal state and
/// are posted to the internal event queue.
///
/// The filter is prototyped as:
/// \code
/// int SDL_EventFilter(void *userdata, SDL_Event * event);
/// \endcode
///
/// If the filter returns 1, then the event will be added to the internal queue.
/// If it returns 0, then the event will be dropped from the queue, but the
/// internal state will still be updated.  This allows selective filtering of
/// dynamically arriving events.
///
/// \warning  Be very careful of what you do in the event filter function, as
/// it may run in a different thread!
///
/// There is one caveat when dealing with the ::SDL_QuitEvent event type.  The
/// event filter is only called when the window manager desires to close the
/// application window.  If the event filter returns 1, then the window will
/// be closed, otherwise the window will remain open if possible.
///
/// If the quit event is generated by an interrupt signal, it will bypass the
/// internal queue and be delivered to the application at the next event poll. 
 pub fn SDL_SetEventFilter ( filter : SDL_EventFilter , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// Return the current event filter - can be used to "chain" filters.
/// If there is no event filter set, this function returns SDL_FALSE. 
 pub fn SDL_GetEventFilter ( filter : * mut SDL_EventFilter , userdata : * mut * mut ctypes :: c_void ) -> SDL_bool ; } extern "C" { 
 /// Add a function which is called when an event is added to the queue. 
 pub fn SDL_AddEventWatch ( filter : SDL_EventFilter , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// Remove an event watch function added with SDL_AddEventWatch() 
 pub fn SDL_DelEventWatch ( filter : SDL_EventFilter , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// Run the filter function on the current event queue, removing any
/// events for which the filter returns 0. 
 pub fn SDL_FilterEvents ( filter : SDL_EventFilter , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// This function allows you to set the state of processing certain events.
/// - If \c state is set to ::SDL_IGNORE, that event will be automatically
/// dropped from the event queue and will not be filtered.
/// - If \c state is set to ::SDL_ENABLE, that event will be processed
/// normally.
/// - If \c state is set to ::SDL_QUERY, SDL_EventState() will return the
/// current processing state of the specified event. 
 pub fn SDL_EventState ( type_ : Uint32 , state : ctypes :: c_int ) -> Uint8 ; } extern "C" { 
 /// This function allocates a set of user-defined events, and returns
/// the beginning event number for that set of events.
///
/// If there aren't enough user-defined events left, this function
/// returns (Uint32)-1 
 pub fn SDL_RegisterEvents ( numevents : ctypes :: c_int ) -> Uint32 ; } extern "C" { 
 /// \brief Get the path where the application resides.
///
/// Get the "base path". This is the directory where the application was run
/// from, which is probably the installation directory, and may or may not
/// be the process's current working directory.
///
/// This returns an absolute path in UTF-8 encoding, and is guaranteed to
/// end with a path separator ('\\' on Windows, '/' most other places).
///
/// The pointer returned by this function is owned by you. Please call
/// SDL_free() on the pointer when you are done with it, or it will be a
/// memory leak. This is not necessarily a fast call, though, so you should
/// call this once near startup and save the string if you need it.
///
/// Some platforms can't determine the application's path, and on other
/// platforms, this might be meaningless. In such cases, this function will
/// return NULL.
///
/// \return String of base dir in UTF-8 encoding, or NULL on error.
///
/// \sa SDL_GetPrefPath 
 pub fn SDL_GetBasePath ( ) -> * mut ctypes :: c_char ; } extern "C" { 
 /// \brief Get the user-and-app-specific path where files can be written.
///
/// Get the "pref dir". This is meant to be where users can write personal
/// files (preferences and save games, etc) that are specific to your
/// application. This directory is unique per user, per application.
///
/// This function will decide the appropriate location in the native filesystem,
/// create the directory if necessary, and return a string of the absolute
/// path to the directory in UTF-8 encoding.
///
/// On Windows, the string might look like:
/// "C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\"
///
/// On Linux, the string might look like:
/// "/home/bob/.local/share/My Program Name/"
///
/// On Mac OS X, the string might look like:
/// "/Users/bob/Library/Application Support/My Program Name/"
///
/// (etc.)
///
/// You specify the name of your organization (if it's not a real organization,
/// your name or an Internet domain you own might do) and the name of your
/// application. These should be untranslated proper names.
///
/// Both the org and app strings may become part of a directory name, so
/// please follow these rules:
///
/// - Try to use the same org string (including case-sensitivity) for
/// all your applications that use this function.
/// - Always use a unique app string for each one, and make sure it never
/// changes for an app once you've decided on it.
/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...
/// - ...only use letters, numbers, and spaces. Avoid punctuation like
/// "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
///
/// This returns an absolute path in UTF-8 encoding, and is guaranteed to
/// end with a path separator ('\\' on Windows, '/' most other places).
///
/// The pointer returned by this function is owned by you. Please call
/// SDL_free() on the pointer when you are done with it, or it will be a
/// memory leak. This is not necessarily a fast call, though, so you should
/// call this once near startup and save the string if you need it.
///
/// You should assume the path returned by this function is the only safe
/// place to write files (and that SDL_GetBasePath(), while it might be
/// writable, or even the parent of the returned path, aren't where you
/// should be writing things).
///
/// Some platforms can't determine the pref path, and on other
/// platforms, this might be meaningless. In such cases, this function will
/// return NULL.
///
/// \param org The name of your organization.
/// \param app The name of your application.
/// \return UTF-8 string of user dir in platform-dependent notation. NULL
/// if there's a problem (creating directory failed, etc).
///
/// \sa SDL_GetBasePath 
 pub fn SDL_GetPrefPath ( org : * const ctypes :: c_char , app : * const ctypes :: c_char ) -> * mut ctypes :: c_char ; } 
 /// \typedef SDL_Haptic
///
/// \brief The haptic structure used to identify an SDL haptic.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticOpenFromJoystick
/// \sa SDL_HapticClose 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _SDL_Haptic { _unused : [ u8 ; 0 ] , } pub type SDL_Haptic = _SDL_Haptic ; 
 /// \brief Structure that represents a haptic direction.
///
/// This is the direction where the force comes from,
/// instead of the direction in which the force is exerted.
///
/// Directions can be specified by:
/// - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
/// - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
/// - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
///
/// Cardinal directions of the haptic device are relative to the positioning
/// of the device.  North is considered to be away from the user.
///
/// The following diagram represents the cardinal directions:
/// \verbatim
/// .--.
/// |__| .-------.
/// |=.| |.-----.|
/// |--| ||     ||
/// |  | |'-----'|
/// |__|~')_____('
/// [ COMPUTER ]
///
///
/// North (0,-1)
/// ^
/// |
/// |
/// (-1,0)  West <----[ HAPTIC ]----> East (1,0)
/// |
/// |
/// v
/// South (0,1)
///
///
/// [ USER ]
/// \|||/
/// (o o)
/// ---ooO-(_)-Ooo---
/// \endverbatim
///
/// If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
/// degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
/// the first \c dir parameter.  The cardinal directions would be:
/// - North: 0 (0 degrees)
/// - East: 9000 (90 degrees)
/// - South: 18000 (180 degrees)
/// - West: 27000 (270 degrees)
///
/// If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
/// (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
/// the first three \c dir parameters.  The cardinal directions would be:
/// - North:  0,-1, 0
/// - East:   1, 0, 0
/// - South:  0, 1, 0
/// - West:  -1, 0, 0
///
/// The Z axis represents the height of the effect if supported, otherwise
/// it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
/// can use any multiple you want, only the direction matters.
///
/// If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
/// The first two \c dir parameters are used.  The \c dir parameters are as
/// follows (all values are in hundredths of degrees):
/// - Degrees from (1, 0) rotated towards (0, 1).
/// - Degrees towards (0, 0, 1) (device needs at least 3 axes).
///
///
/// Example of force coming from the south with all encodings (force coming
/// from the south means the user will have to pull the stick to counteract):
/// \code
/// SDL_HapticDirection direction;
///
/// // Cartesian directions
/// direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
/// direction.dir[0] = 0; // X position
/// direction.dir[1] = 1; // Y position
/// // Assuming the device has 2 axes, we don't need to specify third parameter.
///
/// // Polar directions
/// direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
/// direction.dir[0] = 18000; // Polar only uses first parameter
///
/// // Spherical coordinates
/// direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
/// direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
/// \endcode
///
/// \sa SDL_HAPTIC_POLAR
/// \sa SDL_HAPTIC_CARTESIAN
/// \sa SDL_HAPTIC_SPHERICAL
/// \sa SDL_HapticEffect
/// \sa SDL_HapticNumAxes 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticDirection { 
 /// < The type of encoding. 
 pub type_ : Uint8 , 
 /// < The encoded direction. 
 pub dir : [ Sint32 ; 3usize ] , } # [ test ] fn bindgen_test_layout_SDL_HapticDirection ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticDirection > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticDirection ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticDirection > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticDirection ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticDirection > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticDirection ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticDirection > ( ) ) ) . dir as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticDirection ) , "::" , stringify ! ( dir ) ) ) ; } 
 /// \brief A structure containing a template for a Constant effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.
///
/// A constant effect applies a constant force in the specified direction
/// to the joystick.
///
/// \sa SDL_HAPTIC_CONSTANT
/// \sa SDL_HapticEffect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticConstant { 
 /// < ::SDL_HAPTIC_CONSTANT 
 pub type_ : Uint16 , 
 /// < Direction of the effect. 
 pub direction : SDL_HapticDirection , 
 /// < Duration of the effect. 
 pub length : Uint32 , 
 /// < Delay before starting the effect. 
 pub delay : Uint16 , 
 /// < Button that triggers the effect. 
 pub button : Uint16 , 
 /// < How soon it can be triggered again after button. 
 pub interval : Uint16 , 
 /// < Strength of the constant effect. 
 pub level : Sint16 , 
 /// < Duration of the attack. 
 pub attack_length : Uint16 , 
 /// < Level at the start of the attack. 
 pub attack_level : Uint16 , 
 /// < Duration of the fade. 
 pub fade_length : Uint16 , 
 /// < Level at the end of the fade. 
 pub fade_level : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_HapticConstant ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticConstant > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticConstant ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticConstant > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticConstant ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . direction as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( direction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . length as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . delay as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . button as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . interval as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . level as * const _ as usize } , 30usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . attack_length as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( attack_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . attack_level as * const _ as usize } , 34usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( attack_level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . fade_length as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( fade_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticConstant > ( ) ) ) . fade_level as * const _ as usize } , 38usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticConstant ) , "::" , stringify ! ( fade_level ) ) ) ; } 
 /// \brief A structure containing a template for a Periodic effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SINE
/// - ::SDL_HAPTIC_LEFTRIGHT
/// - ::SDL_HAPTIC_TRIANGLE
/// - ::SDL_HAPTIC_SAWTOOTHUP
/// - ::SDL_HAPTIC_SAWTOOTHDOWN
///
/// A periodic effect consists in a wave-shaped effect that repeats itself
/// over time.  The type determines the shape of the wave and the parameters
/// determine the dimensions of the wave.
///
/// Phase is given by hundredth of a degree meaning that giving the phase a value
/// of 9000 will displace it 25% of its period.  Here are sample values:
/// -     0: No phase displacement.
/// -  9000: Displaced 25% of its period.
/// - 18000: Displaced 50% of its period.
/// - 27000: Displaced 75% of its period.
/// - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
///
/// Examples:
/// \verbatim
/// SDL_HAPTIC_SINE
/// __      __      __      __
/// /  \    /  \    /  \    /
/// /    \__/    \__/    \__/
///
/// SDL_HAPTIC_SQUARE
/// __    __    __    __    __
/// |  |  |  |  |  |  |  |  |  |
/// |  |__|  |__|  |__|  |__|  |
///
/// SDL_HAPTIC_TRIANGLE
/// /\    /\    /\    /\    /\
/// /  \  /  \  /  \  /  \  /
/// /    \/    \/    \/    \/
///
/// SDL_HAPTIC_SAWTOOTHUP
/// /|  /|  /|  /|  /|  /|  /|
/// / | / | / | / | / | / | / |
/// /  |/  |/  |/  |/  |/  |/  |
///
/// SDL_HAPTIC_SAWTOOTHDOWN
/// \  |\  |\  |\  |\  |\  |\  |
/// \ | \ | \ | \ | \ | \ | \ |
/// \|  \|  \|  \|  \|  \|  \|
/// \endverbatim
///
/// \sa SDL_HAPTIC_SINE
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HAPTIC_TRIANGLE
/// \sa SDL_HAPTIC_SAWTOOTHUP
/// \sa SDL_HAPTIC_SAWTOOTHDOWN
/// \sa SDL_HapticEffect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticPeriodic { 
 /// < ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,
    /// ::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or
    /// ::SDL_HAPTIC_SAWTOOTHDOWN 
 pub type_ : Uint16 , 
 /// < Direction of the effect. 
 pub direction : SDL_HapticDirection , 
 /// < Duration of the effect. 
 pub length : Uint32 , 
 /// < Delay before starting the effect. 
 pub delay : Uint16 , 
 /// < Button that triggers the effect. 
 pub button : Uint16 , 
 /// < How soon it can be triggered again after button. 
 pub interval : Uint16 , 
 /// < Period of the wave. 
 pub period : Uint16 , 
 /// < Peak value; if negative, equivalent to 180 degrees extra phase shift. 
 pub magnitude : Sint16 , 
 /// < Mean value of the wave. 
 pub offset : Sint16 , 
 /// < Positive phase shift given by hundredth of a degree. 
 pub phase : Uint16 , 
 /// < Duration of the attack. 
 pub attack_length : Uint16 , 
 /// < Level at the start of the attack. 
 pub attack_level : Uint16 , 
 /// < Duration of the fade. 
 pub fade_length : Uint16 , 
 /// < Level at the end of the fade. 
 pub fade_level : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_HapticPeriodic ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticPeriodic > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticPeriodic ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticPeriodic > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticPeriodic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . direction as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( direction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . length as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . delay as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . button as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . interval as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . period as * const _ as usize } , 30usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( period ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . magnitude as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( magnitude ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . offset as * const _ as usize } , 34usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . phase as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( phase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . attack_length as * const _ as usize } , 38usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( attack_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . attack_level as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( attack_level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . fade_length as * const _ as usize } , 42usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( fade_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticPeriodic > ( ) ) ) . fade_level as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticPeriodic ) , "::" , stringify ! ( fade_level ) ) ) ; } 
 /// \brief A structure containing a template for a Condition effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SPRING: Effect based on axes position.
/// - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
/// - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
/// - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
///
/// Direction is handled by condition internals instead of a direction member.
/// The condition effect specific members have three parameters.  The first
/// refers to the X axis, the second refers to the Y axis and the third
/// refers to the Z axis.  The right terms refer to the positive side of the
/// axis and the left terms refer to the negative side of the axis.  Please
/// refer to the ::SDL_HapticDirection diagram for which side is positive and
/// which is negative.
///
/// \sa SDL_HapticDirection
/// \sa SDL_HAPTIC_SPRING
/// \sa SDL_HAPTIC_DAMPER
/// \sa SDL_HAPTIC_INERTIA
/// \sa SDL_HAPTIC_FRICTION
/// \sa SDL_HapticEffect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticCondition { 
 /// < ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,
    /// ::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION 
 pub type_ : Uint16 , 
 /// < Direction of the effect - Not used ATM. 
 pub direction : SDL_HapticDirection , 
 /// < Duration of the effect. 
 pub length : Uint32 , 
 /// < Delay before starting the effect. 
 pub delay : Uint16 , 
 /// < Button that triggers the effect. 
 pub button : Uint16 , 
 /// < How soon it can be triggered again after button. 
 pub interval : Uint16 , 
 /// < Level when joystick is to the positive side; max 0xFFFF. 
 pub right_sat : [ Uint16 ; 3usize ] , 
 /// < Level when joystick is to the negative side; max 0xFFFF. 
 pub left_sat : [ Uint16 ; 3usize ] , 
 /// < How fast to increase the force towards the positive side. 
 pub right_coeff : [ Sint16 ; 3usize ] , 
 /// < How fast to increase the force towards the negative side. 
 pub left_coeff : [ Sint16 ; 3usize ] , 
 /// < Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered. 
 pub deadband : [ Uint16 ; 3usize ] , 
 /// < Position of the dead zone. 
 pub center : [ Sint16 ; 3usize ] , } # [ test ] fn bindgen_test_layout_SDL_HapticCondition ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticCondition > ( ) , 68usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticCondition ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticCondition > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticCondition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . direction as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( direction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . length as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . delay as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . button as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . interval as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . right_sat as * const _ as usize } , 30usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( right_sat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . left_sat as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( left_sat ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . right_coeff as * const _ as usize } , 42usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( right_coeff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . left_coeff as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( left_coeff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . deadband as * const _ as usize } , 54usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( deadband ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCondition > ( ) ) ) . center as * const _ as usize } , 60usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCondition ) , "::" , stringify ! ( center ) ) ) ; } 
 /// \brief A structure containing a template for a Ramp effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
///
/// The ramp effect starts at start strength and ends at end strength.
/// It augments in linear fashion.  If you use attack and fade with a ramp
/// the effects get added to the ramp effect making the effect become
/// quadratic instead of linear.
///
/// \sa SDL_HAPTIC_RAMP
/// \sa SDL_HapticEffect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticRamp { 
 /// < ::SDL_HAPTIC_RAMP 
 pub type_ : Uint16 , 
 /// < Direction of the effect. 
 pub direction : SDL_HapticDirection , 
 /// < Duration of the effect. 
 pub length : Uint32 , 
 /// < Delay before starting the effect. 
 pub delay : Uint16 , 
 /// < Button that triggers the effect. 
 pub button : Uint16 , 
 /// < How soon it can be triggered again after button. 
 pub interval : Uint16 , 
 /// < Beginning strength level. 
 pub start : Sint16 , 
 /// < Ending strength level. 
 pub end : Sint16 , 
 /// < Duration of the attack. 
 pub attack_length : Uint16 , 
 /// < Level at the start of the attack. 
 pub attack_level : Uint16 , 
 /// < Duration of the fade. 
 pub fade_length : Uint16 , 
 /// < Level at the end of the fade. 
 pub fade_level : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_HapticRamp ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticRamp > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticRamp ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticRamp > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticRamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . direction as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( direction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . length as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . delay as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . button as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . interval as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . start as * const _ as usize } , 30usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( start ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . end as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . attack_length as * const _ as usize } , 34usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( attack_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . attack_level as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( attack_level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . fade_length as * const _ as usize } , 38usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( fade_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticRamp > ( ) ) ) . fade_level as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticRamp ) , "::" , stringify ! ( fade_level ) ) ) ; } 
 /// \brief A structure containing a template for a Left/Right effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
///
/// The Left/Right effect is used to explicitly control the large and small
/// motors, commonly found in modern game controllers. One motor is high
/// frequency, the other is low frequency.
///
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HapticEffect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticLeftRight { 
 /// < ::SDL_HAPTIC_LEFTRIGHT 
 pub type_ : Uint16 , 
 /// < Duration of the effect. 
 pub length : Uint32 , 
 /// < Control of the large controller motor. 
 pub large_magnitude : Uint16 , 
 /// < Control of the small controller motor. 
 pub small_magnitude : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_HapticLeftRight ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticLeftRight > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticLeftRight ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticLeftRight > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticLeftRight ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticLeftRight > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticLeftRight ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticLeftRight > ( ) ) ) . length as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticLeftRight ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticLeftRight > ( ) ) ) . large_magnitude as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticLeftRight ) , "::" , stringify ! ( large_magnitude ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticLeftRight > ( ) ) ) . small_magnitude as * const _ as usize } , 10usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticLeftRight ) , "::" , stringify ! ( small_magnitude ) ) ) ; } 
 /// \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.
///
/// A custom force feedback effect is much like a periodic effect, where the
/// application can define its exact shape.  You will have to allocate the
/// data yourself.  Data should consist of channels * samples Uint16 samples.
///
/// If channels is one, the effect is rotated using the defined direction.
/// Otherwise it uses the samples in data for the different axes.
///
/// \sa SDL_HAPTIC_CUSTOM
/// \sa SDL_HapticEffect 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_HapticCustom { 
 /// < ::SDL_HAPTIC_CUSTOM 
 pub type_ : Uint16 , 
 /// < Direction of the effect. 
 pub direction : SDL_HapticDirection , 
 /// < Duration of the effect. 
 pub length : Uint32 , 
 /// < Delay before starting the effect. 
 pub delay : Uint16 , 
 /// < Button that triggers the effect. 
 pub button : Uint16 , 
 /// < How soon it can be triggered again after button. 
 pub interval : Uint16 , 
 /// < Axes to use, minimum of one. 
 pub channels : Uint8 , 
 /// < Sample periods. 
 pub period : Uint16 , 
 /// < Amount of samples. 
 pub samples : Uint16 , 
 /// < Should contain channels*samples items. 
 pub data : * mut Uint16 , 
 /// < Duration of the attack. 
 pub attack_length : Uint16 , 
 /// < Level at the start of the attack. 
 pub attack_level : Uint16 , 
 /// < Duration of the fade. 
 pub fade_length : Uint16 , 
 /// < Level at the end of the fade. 
 pub fade_level : Uint16 , } # [ test ] fn bindgen_test_layout_SDL_HapticCustom ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticCustom > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticCustom ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticCustom > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticCustom ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . direction as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( direction ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . length as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . delay as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . button as * const _ as usize } , 26usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( button ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . interval as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( interval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . channels as * const _ as usize } , 30usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . period as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( period ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . samples as * const _ as usize } , 34usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( samples ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . data as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . attack_length as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( attack_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . attack_level as * const _ as usize } , 50usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( attack_level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . fade_length as * const _ as usize } , 52usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( fade_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticCustom > ( ) ) ) . fade_level as * const _ as usize } , 54usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticCustom ) , "::" , stringify ! ( fade_level ) ) ) ; } 
 /// \brief The generic template for any haptic effect.
///
/// All values max at 32767 (0x7FFF).  Signed values also can be negative.
/// Time values unless specified otherwise are in milliseconds.
///
/// You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767
/// value.  Neither delay, interval, attack_length nor fade_length support
/// ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
///
/// Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of
/// ::SDL_HAPTIC_INFINITY.
///
/// Button triggers may not be supported on all devices, it is advised to not
/// use them if possible.  Buttons start at index 1 instead of index 0 like
/// the joystick.
///
/// If both attack_length and fade_level are 0, the envelope is not used,
/// otherwise both values are used.
///
/// Common parts:
/// \code
/// // Replay - All effects have this
/// Uint32 length;        // Duration of effect (ms).
/// Uint16 delay;         // Delay before starting effect.
///
/// // Trigger - All effects have this
/// Uint16 button;        // Button that triggers effect.
/// Uint16 interval;      // How soon before effect can be triggered again.
///
/// // Envelope - All effects except condition effects have this
/// Uint16 attack_length; // Duration of the attack (ms).
/// Uint16 attack_level;  // Level at the start of the attack.
/// Uint16 fade_length;   // Duration of the fade out (ms).
/// Uint16 fade_level;    // Level at the end of the fade.
/// \endcode
///
///
/// Here we have an example of a constant effect evolution in time:
/// \verbatim
/// Strength
/// ^
/// |
/// |    effect level -->  _________________
/// |                     /                 \
/// |                    /                   \
/// |                   /                     \
/// |                  /                       \
/// | attack_level --> |                        \
/// |                  |                        |  <---  fade_level
/// |
/// +--------------------------------------------------> Time
/// [--]                 [---]
/// attack_length        fade_length
///
/// [------------------][-----------------------]
/// delay               length
/// \endverbatim
///
/// Note either the attack_level or the fade_level may be above the actual
/// effect level.
///
/// \sa SDL_HapticConstant
/// \sa SDL_HapticPeriodic
/// \sa SDL_HapticCondition
/// \sa SDL_HapticRamp
/// \sa SDL_HapticLeftRight
/// \sa SDL_HapticCustom 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union SDL_HapticEffect { 
 /// < Effect type. 
 pub type_ : Uint16 , 
 /// < Constant effect. 
 pub constant : SDL_HapticConstant , 
 /// < Periodic effect. 
 pub periodic : SDL_HapticPeriodic , 
 /// < Condition effect. 
 pub condition : SDL_HapticCondition , 
 /// < Ramp effect. 
 pub ramp : SDL_HapticRamp , 
 /// < Left/Right effect. 
 pub leftright : SDL_HapticLeftRight , 
 /// < Custom effect. 
 pub custom : SDL_HapticCustom , _bindgen_union_align : [ u64 ; 9usize ] , } # [ test ] fn bindgen_test_layout_SDL_HapticEffect ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_HapticEffect > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( SDL_HapticEffect ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_HapticEffect > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_HapticEffect ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . constant as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( constant ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . periodic as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( periodic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . condition as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( condition ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . ramp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( ramp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . leftright as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( leftright ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_HapticEffect > ( ) ) ) . custom as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_HapticEffect ) , "::" , stringify ! ( custom ) ) ) ; } extern "C" { 
 /// \brief Count the number of haptic devices attached to the system.
///
/// \return Number of haptic devices detected on the system. 
 pub fn SDL_NumHaptics ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the implementation dependent name of a haptic device.
///
/// This can be called before any joysticks are opened.
/// If no name can be found, this function returns NULL.
///
/// \param device_index Index of the device to get its name.
/// \return Name of the device or NULL on error.
///
/// \sa SDL_NumHaptics 
 pub fn SDL_HapticName ( device_index : ctypes :: c_int ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Opens a haptic device for use.
///
/// The index passed as an argument refers to the N'th haptic device on this
/// system.
///
/// When opening a haptic device, its gain will be set to maximum and
/// autocenter will be disabled.  To modify these values use
/// SDL_HapticSetGain() and SDL_HapticSetAutocenter().
///
/// \param device_index Index of the device to open.
/// \return Device identifier or NULL on error.
///
/// \sa SDL_HapticIndex
/// \sa SDL_HapticOpenFromMouse
/// \sa SDL_HapticOpenFromJoystick
/// \sa SDL_HapticClose
/// \sa SDL_HapticSetGain
/// \sa SDL_HapticSetAutocenter
/// \sa SDL_HapticPause
/// \sa SDL_HapticStopAll 
 pub fn SDL_HapticOpen ( device_index : ctypes :: c_int ) -> * mut SDL_Haptic ; } extern "C" { 
 /// \brief Checks if the haptic device at index has been opened.
///
/// \param device_index Index to check to see if it has been opened.
/// \return 1 if it has been opened or 0 if it hasn't.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticIndex 
 pub fn SDL_HapticOpened ( device_index : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Gets the index of a haptic device.
///
/// \param haptic Haptic device to get the index of.
/// \return The index of the haptic device or -1 on error.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticOpened 
 pub fn SDL_HapticIndex ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Gets whether or not the current mouse has haptic capabilities.
///
/// \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
///
/// \sa SDL_HapticOpenFromMouse 
 pub fn SDL_MouseIsHaptic ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Tries to open a haptic device from the current mouse.
///
/// \return The haptic device identifier or NULL on error.
///
/// \sa SDL_MouseIsHaptic
/// \sa SDL_HapticOpen 
 pub fn SDL_HapticOpenFromMouse ( ) -> * mut SDL_Haptic ; } extern "C" { 
 /// \brief Checks to see if a joystick has haptic features.
///
/// \param joystick Joystick to test for haptic capabilities.
/// \return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't
/// or -1 if an error occurred.
///
/// \sa SDL_HapticOpenFromJoystick 
 pub fn SDL_JoystickIsHaptic ( joystick : * mut SDL_Joystick ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Opens a haptic device for use from a joystick device.
///
/// You must still close the haptic device separately.  It will not be closed
/// with the joystick.
///
/// When opening from a joystick you should first close the haptic device before
/// closing the joystick device.  If not, on some implementations the haptic
/// device will also get unallocated and you'll be unable to use force feedback
/// on that device.
///
/// \param joystick Joystick to create a haptic device from.
/// \return A valid haptic device identifier on success or NULL on error.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticClose 
 pub fn SDL_HapticOpenFromJoystick ( joystick : * mut SDL_Joystick ) -> * mut SDL_Haptic ; } extern "C" { 
 /// \brief Closes a haptic device previously opened with SDL_HapticOpen().
///
/// \param haptic Haptic device to close. 
 pub fn SDL_HapticClose ( haptic : * mut SDL_Haptic ) ; } extern "C" { 
 /// \brief Returns the number of effects a haptic device can store.
///
/// On some platforms this isn't fully supported, and therefore is an
/// approximation.  Always check to see if your created effect was actually
/// created and do not rely solely on SDL_HapticNumEffects().
///
/// \param haptic The haptic device to query effect max.
/// \return The number of effects the haptic device can store or
/// -1 on error.
///
/// \sa SDL_HapticNumEffectsPlaying
/// \sa SDL_HapticQuery 
 pub fn SDL_HapticNumEffects ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Returns the number of effects a haptic device can play at the same
/// time.
///
/// This is not supported on all platforms, but will always return a value.
/// Added here for the sake of completeness.
///
/// \param haptic The haptic device to query maximum playing effects.
/// \return The number of effects the haptic device can play at the same time
/// or -1 on error.
///
/// \sa SDL_HapticNumEffects
/// \sa SDL_HapticQuery 
 pub fn SDL_HapticNumEffectsPlaying ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Gets the haptic device's supported features in bitwise manner.
///
/// Example:
/// \code
/// if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {
/// printf("We have constant haptic effect!\n");
/// }
/// \endcode
///
/// \param haptic The haptic device to query.
/// \return Haptic features in bitwise manner (OR'd).
///
/// \sa SDL_HapticNumEffects
/// \sa SDL_HapticEffectSupported 
 pub fn SDL_HapticQuery ( haptic : * mut SDL_Haptic ) -> ctypes :: c_uint ; } extern "C" { 
 /// \brief Gets the number of haptic axes the device has.
///
/// \sa SDL_HapticDirection 
 pub fn SDL_HapticNumAxes ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Checks to see if effect is supported by haptic.
///
/// \param haptic Haptic device to check on.
/// \param effect Effect to check to see if it is supported.
/// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
///
/// \sa SDL_HapticQuery
/// \sa SDL_HapticNewEffect 
 pub fn SDL_HapticEffectSupported ( haptic : * mut SDL_Haptic , effect : * mut SDL_HapticEffect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Creates a new haptic effect on the device.
///
/// \param haptic Haptic device to create the effect on.
/// \param effect Properties of the effect to create.
/// \return The identifier of the effect on success or -1 on error.
///
/// \sa SDL_HapticUpdateEffect
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticDestroyEffect 
 pub fn SDL_HapticNewEffect ( haptic : * mut SDL_Haptic , effect : * mut SDL_HapticEffect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Updates the properties of an effect.
///
/// Can be used dynamically, although behavior when dynamically changing
/// direction may be strange.  Specifically the effect may reupload itself
/// and start playing from the start.  You cannot change the type either when
/// running SDL_HapticUpdateEffect().
///
/// \param haptic Haptic device that has the effect.
/// \param effect Identifier of the effect to update.
/// \param data New effect properties to use.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticNewEffect
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticDestroyEffect 
 pub fn SDL_HapticUpdateEffect ( haptic : * mut SDL_Haptic , effect : ctypes :: c_int , data : * mut SDL_HapticEffect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Runs the haptic effect on its associated haptic device.
///
/// If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over
/// repeating the envelope (attack and fade) every time.  If you only want the
/// effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length
/// parameter.
///
/// \param haptic Haptic device to run the effect on.
/// \param effect Identifier of the haptic effect to run.
/// \param iterations Number of iterations to run the effect. Use
/// ::SDL_HAPTIC_INFINITY for infinity.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticStopEffect
/// \sa SDL_HapticDestroyEffect
/// \sa SDL_HapticGetEffectStatus 
 pub fn SDL_HapticRunEffect ( haptic : * mut SDL_Haptic , effect : ctypes :: c_int , iterations : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Stops the haptic effect on its associated haptic device.
///
/// \param haptic Haptic device to stop the effect on.
/// \param effect Identifier of the effect to stop.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticDestroyEffect 
 pub fn SDL_HapticStopEffect ( haptic : * mut SDL_Haptic , effect : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Destroys a haptic effect on the device.
///
/// This will stop the effect if it's running.  Effects are automatically
/// destroyed when the device is closed.
///
/// \param haptic Device to destroy the effect on.
/// \param effect Identifier of the effect to destroy.
///
/// \sa SDL_HapticNewEffect 
 pub fn SDL_HapticDestroyEffect ( haptic : * mut SDL_Haptic , effect : ctypes :: c_int ) ; } extern "C" { 
 /// \brief Gets the status of the current effect on the haptic device.
///
/// Device must support the ::SDL_HAPTIC_STATUS feature.
///
/// \param haptic Haptic device to query the effect status on.
/// \param effect Identifier of the effect to query its status.
/// \return 0 if it isn't playing, 1 if it is playing or -1 on error.
///
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticStopEffect 
 pub fn SDL_HapticGetEffectStatus ( haptic : * mut SDL_Haptic , effect : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Sets the global gain of the device.
///
/// Device must support the ::SDL_HAPTIC_GAIN feature.
///
/// The user may specify the maximum gain by setting the environment variable
/// SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
/// SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the
/// maximum.
///
/// \param haptic Haptic device to set the gain on.
/// \param gain Value to set the gain to, should be between 0 and 100.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticQuery 
 pub fn SDL_HapticSetGain ( haptic : * mut SDL_Haptic , gain : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Sets the global autocenter of the device.
///
/// Autocenter should be between 0 and 100.  Setting it to 0 will disable
/// autocentering.
///
/// Device must support the ::SDL_HAPTIC_AUTOCENTER feature.
///
/// \param haptic Haptic device to set autocentering on.
/// \param autocenter Value to set autocenter to, 0 disables autocentering.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticQuery 
 pub fn SDL_HapticSetAutocenter ( haptic : * mut SDL_Haptic , autocenter : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Pauses a haptic device.
///
/// Device must support the ::SDL_HAPTIC_PAUSE feature.  Call
/// SDL_HapticUnpause() to resume playback.
///
/// Do not modify the effects nor add new ones while the device is paused.
/// That can cause all sorts of weird errors.
///
/// \param haptic Haptic device to pause.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticUnpause 
 pub fn SDL_HapticPause ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Unpauses a haptic device.
///
/// Call to unpause after SDL_HapticPause().
///
/// \param haptic Haptic device to unpause.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticPause 
 pub fn SDL_HapticUnpause ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Stops all the currently playing effects on a haptic device.
///
/// \param haptic Haptic device to stop.
/// \return 0 on success or -1 on error. 
 pub fn SDL_HapticStopAll ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Checks to see if rumble is supported on a haptic device.
///
/// \param haptic Haptic device to check to see if it supports rumble.
/// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
///
/// \sa SDL_HapticRumbleInit
/// \sa SDL_HapticRumblePlay
/// \sa SDL_HapticRumbleStop 
 pub fn SDL_HapticRumbleSupported ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Initializes the haptic device for simple rumble playback.
///
/// \param haptic Haptic device to initialize for simple rumble playback.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticRumbleSupported
/// \sa SDL_HapticRumblePlay
/// \sa SDL_HapticRumbleStop 
 pub fn SDL_HapticRumbleInit ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Runs simple rumble on a haptic device
///
/// \param haptic Haptic device to play rumble effect on.
/// \param strength Strength of the rumble to play as a 0-1 float value.
/// \param length Length of the rumble to play in milliseconds.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticRumbleSupported
/// \sa SDL_HapticRumbleInit
/// \sa SDL_HapticRumbleStop 
 pub fn SDL_HapticRumblePlay ( haptic : * mut SDL_Haptic , strength : f32 , length : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Stops the simple rumble on a haptic device.
///
/// \param haptic Haptic to stop the rumble on.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticRumbleSupported
/// \sa SDL_HapticRumbleInit
/// \sa SDL_HapticRumblePlay 
 pub fn SDL_HapticRumbleStop ( haptic : * mut SDL_Haptic ) -> ctypes :: c_int ; } pub const SDL_HintPriority_SDL_HINT_DEFAULT : SDL_HintPriority = 0 ; pub const SDL_HintPriority_SDL_HINT_NORMAL : SDL_HintPriority = 1 ; pub const SDL_HintPriority_SDL_HINT_OVERRIDE : SDL_HintPriority = 2 ; 
 /// \brief  An enumeration of hint priorities 
 pub type SDL_HintPriority = u32 ; extern "C" { 
 /// \brief Set a hint with a specific priority
///
/// The priority controls the behavior when setting a hint that already
/// has a value.  Hints will replace existing hints of their priority and
/// lower.  Environment variables are considered to have override priority.
///
/// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise 
 pub fn SDL_SetHintWithPriority ( name : * const ctypes :: c_char , value : * const ctypes :: c_char , priority : SDL_HintPriority ) -> SDL_bool ; } extern "C" { 
 /// \brief Set a hint with normal priority
///
/// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise 
 pub fn SDL_SetHint ( name : * const ctypes :: c_char , value : * const ctypes :: c_char ) -> SDL_bool ; } extern "C" { 
 /// \brief Get a hint
///
/// \return The string value of a hint variable. 
 pub fn SDL_GetHint ( name : * const ctypes :: c_char ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Get a hint
///
/// \return The boolean value of a hint variable. 
 pub fn SDL_GetHintBoolean ( name : * const ctypes :: c_char , default_value : SDL_bool ) -> SDL_bool ; } 
 /// \brief type definition of the hint callback function. 
 pub type SDL_HintCallback = :: core :: option :: Option < unsafe extern "C" fn ( userdata : * mut ctypes :: c_void , name : * const ctypes :: c_char , oldValue : * const ctypes :: c_char , newValue : * const ctypes :: c_char ) > ; extern "C" { 
 /// \brief Add a function to watch a particular hint
///
/// \param name The hint to watch
/// \param callback The function to call when the hint value changes
/// \param userdata A pointer to pass to the callback function 
 pub fn SDL_AddHintCallback ( name : * const ctypes :: c_char , callback : SDL_HintCallback , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// \brief Remove a function watching a particular hint
///
/// \param name The hint being watched
/// \param callback The function being called when the hint value changes
/// \param userdata A pointer being passed to the callback function 
 pub fn SDL_DelHintCallback ( name : * const ctypes :: c_char , callback : SDL_HintCallback , userdata : * mut ctypes :: c_void ) ; } extern "C" { 
 /// \brief  Clear all hints
///
/// This function is called during SDL_Quit() to free stored hints. 
 pub fn SDL_ClearHints ( ) ; } extern "C" { 
 /// This function dynamically loads a shared object and returns a pointer
/// to the object handle (or NULL if there was an error).
/// The 'sofile' parameter is a system dependent name of the object file. 
 pub fn SDL_LoadObject ( sofile : * const ctypes :: c_char ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// Given an object handle, this function looks up the address of the
/// named function in the shared object and returns it.  This address
/// is no longer valid after calling SDL_UnloadObject(). 
 pub fn SDL_LoadFunction ( handle : * mut ctypes :: c_void , name : * const ctypes :: c_char ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// Unload a shared object from memory. 
 pub fn SDL_UnloadObject ( handle : * mut ctypes :: c_void ) ; } pub const SDL_LOG_CATEGORY_APPLICATION : _bindgen_ty_8 = 0 ; pub const SDL_LOG_CATEGORY_ERROR : _bindgen_ty_8 = 1 ; pub const SDL_LOG_CATEGORY_ASSERT : _bindgen_ty_8 = 2 ; pub const SDL_LOG_CATEGORY_SYSTEM : _bindgen_ty_8 = 3 ; pub const SDL_LOG_CATEGORY_AUDIO : _bindgen_ty_8 = 4 ; pub const SDL_LOG_CATEGORY_VIDEO : _bindgen_ty_8 = 5 ; pub const SDL_LOG_CATEGORY_RENDER : _bindgen_ty_8 = 6 ; pub const SDL_LOG_CATEGORY_INPUT : _bindgen_ty_8 = 7 ; pub const SDL_LOG_CATEGORY_TEST : _bindgen_ty_8 = 8 ; pub const SDL_LOG_CATEGORY_RESERVED1 : _bindgen_ty_8 = 9 ; pub const SDL_LOG_CATEGORY_RESERVED2 : _bindgen_ty_8 = 10 ; pub const SDL_LOG_CATEGORY_RESERVED3 : _bindgen_ty_8 = 11 ; pub const SDL_LOG_CATEGORY_RESERVED4 : _bindgen_ty_8 = 12 ; pub const SDL_LOG_CATEGORY_RESERVED5 : _bindgen_ty_8 = 13 ; pub const SDL_LOG_CATEGORY_RESERVED6 : _bindgen_ty_8 = 14 ; pub const SDL_LOG_CATEGORY_RESERVED7 : _bindgen_ty_8 = 15 ; pub const SDL_LOG_CATEGORY_RESERVED8 : _bindgen_ty_8 = 16 ; pub const SDL_LOG_CATEGORY_RESERVED9 : _bindgen_ty_8 = 17 ; pub const SDL_LOG_CATEGORY_RESERVED10 : _bindgen_ty_8 = 18 ; pub const SDL_LOG_CATEGORY_CUSTOM : _bindgen_ty_8 = 19 ; 
 /// \brief The predefined log categories
///
/// By default the application category is enabled at the INFO level,
/// the assert category is enabled at the WARN level, test is enabled
/// at the VERBOSE level and all other categories are enabled at the
/// CRITICAL level. 
 pub type _bindgen_ty_8 = u32 ; pub const SDL_LogPriority_SDL_LOG_PRIORITY_VERBOSE : SDL_LogPriority = 1 ; pub const SDL_LogPriority_SDL_LOG_PRIORITY_DEBUG : SDL_LogPriority = 2 ; pub const SDL_LogPriority_SDL_LOG_PRIORITY_INFO : SDL_LogPriority = 3 ; pub const SDL_LogPriority_SDL_LOG_PRIORITY_WARN : SDL_LogPriority = 4 ; pub const SDL_LogPriority_SDL_LOG_PRIORITY_ERROR : SDL_LogPriority = 5 ; pub const SDL_LogPriority_SDL_LOG_PRIORITY_CRITICAL : SDL_LogPriority = 6 ; pub const SDL_LogPriority_SDL_NUM_LOG_PRIORITIES : SDL_LogPriority = 7 ; 
 /// \brief The predefined log priorities 
 pub type SDL_LogPriority = u32 ; extern "C" { 
 /// \brief Set the priority of all log categories 
 pub fn SDL_LogSetAllPriority ( priority : SDL_LogPriority ) ; } extern "C" { 
 /// \brief Set the priority of a particular log category 
 pub fn SDL_LogSetPriority ( category : ctypes :: c_int , priority : SDL_LogPriority ) ; } extern "C" { 
 /// \brief Get the priority of a particular log category 
 pub fn SDL_LogGetPriority ( category : ctypes :: c_int ) -> SDL_LogPriority ; } extern "C" { 
 /// \brief Reset all priorities to default.
///
/// \note This is called in SDL_Quit(). 
 pub fn SDL_LogResetPriorities ( ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO 
 pub fn SDL_Log ( fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_PRIORITY_VERBOSE 
 pub fn SDL_LogVerbose ( category : ctypes :: c_int , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_PRIORITY_DEBUG 
 pub fn SDL_LogDebug ( category : ctypes :: c_int , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_PRIORITY_INFO 
 pub fn SDL_LogInfo ( category : ctypes :: c_int , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_PRIORITY_WARN 
 pub fn SDL_LogWarn ( category : ctypes :: c_int , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_PRIORITY_ERROR 
 pub fn SDL_LogError ( category : ctypes :: c_int , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with SDL_LOG_PRIORITY_CRITICAL 
 pub fn SDL_LogCritical ( category : ctypes :: c_int , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with the specified category and priority. 
 pub fn SDL_LogMessage ( category : ctypes :: c_int , priority : SDL_LogPriority , fmt : * const ctypes :: c_char , ... ) ; } extern "C" { 
 /// \brief Log a message with the specified category and priority. 
 pub fn SDL_LogMessageV ( category : ctypes :: c_int , priority : SDL_LogPriority , fmt : * const ctypes :: c_char , ap : * mut __va_list_tag ) ; } 
 /// \brief The prototype for the log output function 
 pub type SDL_LogOutputFunction = :: core :: option :: Option < unsafe extern "C" fn ( userdata : * mut ctypes :: c_void , category : ctypes :: c_int , priority : SDL_LogPriority , message : * const ctypes :: c_char ) > ; extern "C" { 
 /// \brief Get the current log output function. 
 pub fn SDL_LogGetOutputFunction ( callback : * mut SDL_LogOutputFunction , userdata : * mut * mut ctypes :: c_void ) ; } extern "C" { 
 /// \brief This function allows you to replace the default log output
/// function with one of your own. 
 pub fn SDL_LogSetOutputFunction ( callback : SDL_LogOutputFunction , userdata : * mut ctypes :: c_void ) ; } 
 /// < error dialog 
 pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_ERROR : SDL_MessageBoxFlags = 16 ; 
 /// < warning dialog 
 pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_WARNING : SDL_MessageBoxFlags = 32 ; 
 /// < informational dialog 
 pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_INFORMATION : SDL_MessageBoxFlags = 64 ; 
 /// \brief SDL_MessageBox flags. If supported will display warning icon, etc. 
 pub type SDL_MessageBoxFlags = u32 ; 
 /// < Marks the default button when return is hit 
 pub const SDL_MessageBoxButtonFlags_SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT : SDL_MessageBoxButtonFlags = 1 ; 
 /// < Marks the default button when escape is hit 
 pub const SDL_MessageBoxButtonFlags_SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT : SDL_MessageBoxButtonFlags = 2 ; 
 /// \brief Flags for SDL_MessageBoxButtonData. 
 pub type SDL_MessageBoxButtonFlags = u32 ; 
 /// \brief Individual button data. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MessageBoxButtonData { 
 /// < ::SDL_MessageBoxButtonFlags 
 pub flags : Uint32 , 
 /// < User defined button id (value returned via SDL_ShowMessageBox) 
 pub buttonid : ctypes :: c_int , 
 /// < The UTF-8 button text 
 pub text : * const ctypes :: c_char , } # [ test ] fn bindgen_test_layout_SDL_MessageBoxButtonData ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MessageBoxButtonData > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SDL_MessageBoxButtonData ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MessageBoxButtonData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_MessageBoxButtonData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxButtonData > ( ) ) ) . flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxButtonData ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxButtonData > ( ) ) ) . buttonid as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxButtonData ) , "::" , stringify ! ( buttonid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxButtonData > ( ) ) ) . text as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxButtonData ) , "::" , stringify ! ( text ) ) ) ; } 
 /// \brief RGB value used in a message box color scheme 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MessageBoxColor { pub r : Uint8 , pub g : Uint8 , pub b : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_MessageBoxColor ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MessageBoxColor > ( ) , 3usize , concat ! ( "Size of: " , stringify ! ( SDL_MessageBoxColor ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MessageBoxColor > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_MessageBoxColor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxColor > ( ) ) ) . r as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxColor ) , "::" , stringify ! ( r ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxColor > ( ) ) ) . g as * const _ as usize } , 1usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxColor ) , "::" , stringify ! ( g ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxColor > ( ) ) ) . b as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxColor ) , "::" , stringify ! ( b ) ) ) ; } pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BACKGROUND : SDL_MessageBoxColorType = 0 ; pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_TEXT : SDL_MessageBoxColorType = 1 ; pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_BORDER : SDL_MessageBoxColorType = 2 ; pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND : SDL_MessageBoxColorType = 3 ; pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED : SDL_MessageBoxColorType = 4 ; pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_MAX : SDL_MessageBoxColorType = 5 ; pub type SDL_MessageBoxColorType = u32 ; 
 /// \brief A set of colors to use for message box dialogs 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MessageBoxColorScheme { pub colors : [ SDL_MessageBoxColor ; 5usize ] , } # [ test ] fn bindgen_test_layout_SDL_MessageBoxColorScheme ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MessageBoxColorScheme > ( ) , 15usize , concat ! ( "Size of: " , stringify ! ( SDL_MessageBoxColorScheme ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MessageBoxColorScheme > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_MessageBoxColorScheme ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxColorScheme > ( ) ) ) . colors as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxColorScheme ) , "::" , stringify ! ( colors ) ) ) ; } 
 /// \brief MessageBox structure containing title, text, window, etc. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_MessageBoxData { 
 /// < ::SDL_MessageBoxFlags 
 pub flags : Uint32 , 
 /// < Parent window, can be NULL 
 pub window : * mut SDL_Window , 
 /// < UTF-8 title 
 pub title : * const ctypes :: c_char , 
 /// < UTF-8 message text 
 pub message : * const ctypes :: c_char , pub numbuttons : ctypes :: c_int , pub buttons : * const SDL_MessageBoxButtonData , 
 /// < ::SDL_MessageBoxColorScheme, can be NULL to use system settings 
 pub colorScheme : * const SDL_MessageBoxColorScheme , } # [ test ] fn bindgen_test_layout_SDL_MessageBoxData ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_MessageBoxData > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( SDL_MessageBoxData ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_MessageBoxData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_MessageBoxData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . window as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( window ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . title as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( title ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . message as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( message ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . numbuttons as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( numbuttons ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . buttons as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( buttons ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_MessageBoxData > ( ) ) ) . colorScheme as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( SDL_MessageBoxData ) , "::" , stringify ! ( colorScheme ) ) ) ; } extern "C" { 
 /// \brief Create a modal message box.
///
/// \param messageboxdata The SDL_MessageBoxData structure with title, text, etc.
/// \param buttonid The pointer to which user id of hit button should be copied.
///
/// \return -1 on error, otherwise 0 and buttonid contains user id of button
/// hit or -1 if dialog was closed.
///
/// \note This function should be called on the thread that created the parent
/// window, or on the main thread if the messagebox has no parent.  It will
/// block execution of that thread until the user clicks a button or
/// closes the messagebox. 
 pub fn SDL_ShowMessageBox ( messageboxdata : * const SDL_MessageBoxData , buttonid : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Create a simple modal message box
///
/// \param flags    ::SDL_MessageBoxFlags
/// \param title    UTF-8 title text
/// \param message  UTF-8 message text
/// \param window   The parent window, or NULL for no parent
///
/// \return 0 on success, -1 on error
///
/// \sa SDL_ShowMessageBox 
 pub fn SDL_ShowSimpleMessageBox ( flags : Uint32 , title : * const ctypes :: c_char , message : * const ctypes :: c_char , window : * mut SDL_Window ) -> ctypes :: c_int ; } 
 /// < cannot determine power status 
 pub const SDL_PowerState_SDL_POWERSTATE_UNKNOWN : SDL_PowerState = 0 ; 
 /// < Not plugged in, running on the battery 
 pub const SDL_PowerState_SDL_POWERSTATE_ON_BATTERY : SDL_PowerState = 1 ; 
 /// < Plugged in, no battery available 
 pub const SDL_PowerState_SDL_POWERSTATE_NO_BATTERY : SDL_PowerState = 2 ; 
 /// < Plugged in, charging battery 
 pub const SDL_PowerState_SDL_POWERSTATE_CHARGING : SDL_PowerState = 3 ; 
 /// < Plugged in, battery charged 
 pub const SDL_PowerState_SDL_POWERSTATE_CHARGED : SDL_PowerState = 4 ; 
 /// \brief The basic state for the system's power supply. 
 pub type SDL_PowerState = u32 ; extern "C" { 
 /// \brief Get the current power supply details.
///
/// \param secs Seconds of battery life left. You can pass a NULL here if
/// you don't care. Will return -1 if we can't determine a
/// value, or we're not running on a battery.
///
/// \param pct Percentage of battery life left, between 0 and 100. You can
/// pass a NULL here if you don't care. Will return -1 if we
/// can't determine a value, or we're not running on a battery.
///
/// \return The state of the battery (if any). 
 pub fn SDL_GetPowerInfo ( secs : * mut ctypes :: c_int , pct : * mut ctypes :: c_int ) -> SDL_PowerState ; } 
 /// < The renderer is a software fallback 
 pub const SDL_RendererFlags_SDL_RENDERER_SOFTWARE : SDL_RendererFlags = 1 ; 
 /// < The renderer uses hardware
/// acceleration 
 pub const SDL_RendererFlags_SDL_RENDERER_ACCELERATED : SDL_RendererFlags = 2 ; 
 /// < Present is synchronized
/// with the refresh rate 
 pub const SDL_RendererFlags_SDL_RENDERER_PRESENTVSYNC : SDL_RendererFlags = 4 ; 
 /// < The renderer supports
/// rendering to texture 
 pub const SDL_RendererFlags_SDL_RENDERER_TARGETTEXTURE : SDL_RendererFlags = 8 ; 
 /// \brief Flags used when creating a rendering context 
 pub type SDL_RendererFlags = u32 ; 
 /// \brief Information on the capabilities of a render driver or context. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_RendererInfo { 
 /// < The name of the renderer 
 pub name : * const ctypes :: c_char , 
 /// < Supported ::SDL_RendererFlags 
 pub flags : Uint32 , 
 /// < The number of available texture formats 
 pub num_texture_formats : Uint32 , 
 /// < The available texture formats 
 pub texture_formats : [ Uint32 ; 16usize ] , 
 /// < The maximum texture width 
 pub max_texture_width : ctypes :: c_int , 
 /// < The maximum texture height 
 pub max_texture_height : ctypes :: c_int , } # [ test ] fn bindgen_test_layout_SDL_RendererInfo ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_RendererInfo > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( SDL_RendererInfo ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_RendererInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SDL_RendererInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RendererInfo > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RendererInfo ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RendererInfo > ( ) ) ) . flags as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RendererInfo ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RendererInfo > ( ) ) ) . num_texture_formats as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RendererInfo ) , "::" , stringify ! ( num_texture_formats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RendererInfo > ( ) ) ) . texture_formats as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RendererInfo ) , "::" , stringify ! ( texture_formats ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RendererInfo > ( ) ) ) . max_texture_width as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RendererInfo ) , "::" , stringify ! ( max_texture_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_RendererInfo > ( ) ) ) . max_texture_height as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( SDL_RendererInfo ) , "::" , stringify ! ( max_texture_height ) ) ) ; } 
 /// < Changes rarely, not lockable 
 pub const SDL_TextureAccess_SDL_TEXTUREACCESS_STATIC : SDL_TextureAccess = 0 ; 
 /// < Changes frequently, lockable 
 pub const SDL_TextureAccess_SDL_TEXTUREACCESS_STREAMING : SDL_TextureAccess = 1 ; 
 /// < Texture can be used as a render target 
 pub const SDL_TextureAccess_SDL_TEXTUREACCESS_TARGET : SDL_TextureAccess = 2 ; 
 /// \brief The access pattern allowed for a texture. 
 pub type SDL_TextureAccess = u32 ; 
 /// < No modulation 
 pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_NONE : SDL_TextureModulate = 0 ; 
 /// < srcC = srcC * color 
 pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_COLOR : SDL_TextureModulate = 1 ; 
 /// < srcA = srcA * alpha 
 pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_ALPHA : SDL_TextureModulate = 2 ; 
 /// \brief The texture channel modulation used in SDL_RenderCopy(). 
 pub type SDL_TextureModulate = u32 ; 
 /// < Do not flip 
 pub const SDL_RendererFlip_SDL_FLIP_NONE : SDL_RendererFlip = 0 ; 
 /// < flip horizontally 
 pub const SDL_RendererFlip_SDL_FLIP_HORIZONTAL : SDL_RendererFlip = 1 ; 
 /// < flip vertically 
 pub const SDL_RendererFlip_SDL_FLIP_VERTICAL : SDL_RendererFlip = 2 ; 
 /// \brief Flip constants for SDL_RenderCopyEx 
 pub type SDL_RendererFlip = u32 ; 
 /// \brief A structure representing rendering state 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Renderer { _unused : [ u8 ; 0 ] , } 
 /// \brief An efficient driver-specific representation of pixel data 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_Texture { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// \brief Get the number of 2D rendering drivers available for the current
/// display.
///
/// A render driver is a set of code that handles rendering and texture
/// management on a particular display.  Normally there is only one, but
/// some drivers may have several available with different capabilities.
///
/// \sa SDL_GetRenderDriverInfo()
/// \sa SDL_CreateRenderer() 
 pub fn SDL_GetNumRenderDrivers ( ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get information about a specific 2D rendering driver for the current
/// display.
///
/// \param index The index of the driver to query information about.
/// \param info  A pointer to an SDL_RendererInfo struct to be filled with
/// information on the rendering driver.
///
/// \return 0 on success, -1 if the index was out of range.
///
/// \sa SDL_CreateRenderer() 
 pub fn SDL_GetRenderDriverInfo ( index : ctypes :: c_int , info : * mut SDL_RendererInfo ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Create a window and default renderer
///
/// \param width    The width of the window
/// \param height   The height of the window
/// \param window_flags The flags used to create the window
/// \param window   A pointer filled with the window, or NULL on error
/// \param renderer A pointer filled with the renderer, or NULL on error
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_CreateWindowAndRenderer ( width : ctypes :: c_int , height : ctypes :: c_int , window_flags : Uint32 , window : * mut * mut SDL_Window , renderer : * mut * mut SDL_Renderer ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Create a 2D rendering context for a window.
///
/// \param window The window where rendering is displayed.
/// \param index    The index of the rendering driver to initialize, or -1 to
/// initialize the first one supporting the requested flags.
/// \param flags    ::SDL_RendererFlags.
///
/// \return A valid rendering context or NULL if there was an error.
///
/// \sa SDL_CreateSoftwareRenderer()
/// \sa SDL_GetRendererInfo()
/// \sa SDL_DestroyRenderer() 
 pub fn SDL_CreateRenderer ( window : * mut SDL_Window , index : ctypes :: c_int , flags : Uint32 ) -> * mut SDL_Renderer ; } extern "C" { 
 /// \brief Create a 2D software rendering context for a surface.
///
/// \param surface The surface where rendering is done.
///
/// \return A valid rendering context or NULL if there was an error.
///
/// \sa SDL_CreateRenderer()
/// \sa SDL_DestroyRenderer() 
 pub fn SDL_CreateSoftwareRenderer ( surface : * mut SDL_Surface ) -> * mut SDL_Renderer ; } extern "C" { 
 /// \brief Get the renderer associated with a window. 
 pub fn SDL_GetRenderer ( window : * mut SDL_Window ) -> * mut SDL_Renderer ; } extern "C" { 
 /// \brief Get information about a rendering context. 
 pub fn SDL_GetRendererInfo ( renderer : * mut SDL_Renderer , info : * mut SDL_RendererInfo ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the output size in pixels of a rendering context. 
 pub fn SDL_GetRendererOutputSize ( renderer : * mut SDL_Renderer , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Create a texture for a rendering context.
///
/// \param renderer The renderer.
/// \param format The format of the texture.
/// \param access One of the enumerated values in ::SDL_TextureAccess.
/// \param w      The width of the texture in pixels.
/// \param h      The height of the texture in pixels.
///
/// \return The created texture is returned, or NULL if no rendering context was
/// active,  the format was unsupported, or the width or height were out
/// of range.
///
/// \note The contents of the texture are not defined at creation.
///
/// \sa SDL_QueryTexture()
/// \sa SDL_UpdateTexture()
/// \sa SDL_DestroyTexture() 
 pub fn SDL_CreateTexture ( renderer : * mut SDL_Renderer , format : Uint32 , access : ctypes :: c_int , w : ctypes :: c_int , h : ctypes :: c_int ) -> * mut SDL_Texture ; } extern "C" { 
 /// \brief Create a texture from an existing surface.
///
/// \param renderer The renderer.
/// \param surface The surface containing pixel data used to fill the texture.
///
/// \return The created texture is returned, or NULL on error.
///
/// \note The surface is not modified or freed by this function.
///
/// \sa SDL_QueryTexture()
/// \sa SDL_DestroyTexture() 
 pub fn SDL_CreateTextureFromSurface ( renderer : * mut SDL_Renderer , surface : * mut SDL_Surface ) -> * mut SDL_Texture ; } extern "C" { 
 /// \brief Query the attributes of a texture
///
/// \param texture A texture to be queried.
/// \param format  A pointer filled in with the raw format of the texture.  The
/// actual format may differ, but pixel transfers will use this
/// format.
/// \param access  A pointer filled in with the actual access to the texture.
/// \param w       A pointer filled in with the width of the texture in pixels.
/// \param h       A pointer filled in with the height of the texture in pixels.
///
/// \return 0 on success, or -1 if the texture is not valid. 
 pub fn SDL_QueryTexture ( texture : * mut SDL_Texture , format : * mut Uint32 , access : * mut ctypes :: c_int , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set an additional color value used in render copy operations.
///
/// \param texture The texture to update.
/// \param r       The red color value multiplied into copy operations.
/// \param g       The green color value multiplied into copy operations.
/// \param b       The blue color value multiplied into copy operations.
///
/// \return 0 on success, or -1 if the texture is not valid or color modulation
/// is not supported.
///
/// \sa SDL_GetTextureColorMod() 
 pub fn SDL_SetTextureColorMod ( texture : * mut SDL_Texture , r : Uint8 , g : Uint8 , b : Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the additional color value used in render copy operations.
///
/// \param texture The texture to query.
/// \param r         A pointer filled in with the current red color value.
/// \param g         A pointer filled in with the current green color value.
/// \param b         A pointer filled in with the current blue color value.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \sa SDL_SetTextureColorMod() 
 pub fn SDL_GetTextureColorMod ( texture : * mut SDL_Texture , r : * mut Uint8 , g : * mut Uint8 , b : * mut Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set an additional alpha value used in render copy operations.
///
/// \param texture The texture to update.
/// \param alpha     The alpha value multiplied into copy operations.
///
/// \return 0 on success, or -1 if the texture is not valid or alpha modulation
/// is not supported.
///
/// \sa SDL_GetTextureAlphaMod() 
 pub fn SDL_SetTextureAlphaMod ( texture : * mut SDL_Texture , alpha : Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the additional alpha value used in render copy operations.
///
/// \param texture The texture to query.
/// \param alpha     A pointer filled in with the current alpha value.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \sa SDL_SetTextureAlphaMod() 
 pub fn SDL_GetTextureAlphaMod ( texture : * mut SDL_Texture , alpha : * mut Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the blend mode used for texture copy operations.
///
/// \param texture The texture to update.
/// \param blendMode ::SDL_BlendMode to use for texture blending.
///
/// \return 0 on success, or -1 if the texture is not valid or the blend mode is
/// not supported.
///
/// \note If the blend mode is not supported, the closest supported mode is
/// chosen.
///
/// \sa SDL_GetTextureBlendMode() 
 pub fn SDL_SetTextureBlendMode ( texture : * mut SDL_Texture , blendMode : SDL_BlendMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the blend mode used for texture copy operations.
///
/// \param texture   The texture to query.
/// \param blendMode A pointer filled in with the current blend mode.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \sa SDL_SetTextureBlendMode() 
 pub fn SDL_GetTextureBlendMode ( texture : * mut SDL_Texture , blendMode : * mut SDL_BlendMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Update the given texture rectangle with new pixel data.
///
/// \param texture   The texture to update
/// \param rect      A pointer to the rectangle of pixels to update, or NULL to
/// update the entire texture.
/// \param pixels    The raw pixel data in the format of the texture.
/// \param pitch     The number of bytes in a row of pixel data, including padding between lines.
///
/// The pixel data must be in the format of the texture. The pixel format can be
/// queried with SDL_QueryTexture.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \note This is a fairly slow function. 
 pub fn SDL_UpdateTexture ( texture : * mut SDL_Texture , rect : * const SDL_Rect , pixels : * const ctypes :: c_void , pitch : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data.
///
/// \param texture   The texture to update
/// \param rect      A pointer to the rectangle of pixels to update, or NULL to
/// update the entire texture.
/// \param Yplane    The raw pixel data for the Y plane.
/// \param Ypitch    The number of bytes between rows of pixel data for the Y plane.
/// \param Uplane    The raw pixel data for the U plane.
/// \param Upitch    The number of bytes between rows of pixel data for the U plane.
/// \param Vplane    The raw pixel data for the V plane.
/// \param Vpitch    The number of bytes between rows of pixel data for the V plane.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \note You can use SDL_UpdateTexture() as long as your pixel data is
/// a contiguous block of Y and U/V planes in the proper order, but
/// this function is available if your pixel data is not contiguous. 
 pub fn SDL_UpdateYUVTexture ( texture : * mut SDL_Texture , rect : * const SDL_Rect , Yplane : * const Uint8 , Ypitch : ctypes :: c_int , Uplane : * const Uint8 , Upitch : ctypes :: c_int , Vplane : * const Uint8 , Vpitch : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Lock a portion of the texture for write-only pixel access.
///
/// \param texture   The texture to lock for access, which was created with
/// ::SDL_TEXTUREACCESS_STREAMING.
/// \param rect      A pointer to the rectangle to lock for access. If the rect
/// is NULL, the entire texture will be locked.
/// \param pixels    This is filled in with a pointer to the locked pixels,
/// appropriately offset by the locked area.
/// \param pitch     This is filled in with the pitch of the locked pixels.
///
/// \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
///
/// \sa SDL_UnlockTexture() 
 pub fn SDL_LockTexture ( texture : * mut SDL_Texture , rect : * const SDL_Rect , pixels : * mut * mut ctypes :: c_void , pitch : * mut ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Unlock a texture, uploading the changes to video memory, if needed.
///
/// \sa SDL_LockTexture() 
 pub fn SDL_UnlockTexture ( texture : * mut SDL_Texture ) ; } extern "C" { 
 /// \brief Determines whether a window supports the use of render targets
///
/// \param renderer The renderer that will be checked
///
/// \return SDL_TRUE if supported, SDL_FALSE if not. 
 pub fn SDL_RenderTargetSupported ( renderer : * mut SDL_Renderer ) -> SDL_bool ; } extern "C" { 
 /// \brief Set a texture as the current rendering target.
///
/// \param renderer The renderer.
/// \param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target
///
/// \return 0 on success, or -1 on error
///
/// \sa SDL_GetRenderTarget() 
 pub fn SDL_SetRenderTarget ( renderer : * mut SDL_Renderer , texture : * mut SDL_Texture ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the current render target or NULL for the default render target.
///
/// \return The current render target
///
/// \sa SDL_SetRenderTarget() 
 pub fn SDL_GetRenderTarget ( renderer : * mut SDL_Renderer ) -> * mut SDL_Texture ; } extern "C" { 
 /// \brief Set device independent resolution for rendering
///
/// \param renderer The renderer for which resolution should be set.
/// \param w      The width of the logical resolution
/// \param h      The height of the logical resolution
///
/// This function uses the viewport and scaling functionality to allow a fixed logical
/// resolution for rendering, regardless of the actual output resolution.  If the actual
/// output resolution doesn't have the same aspect ratio the output rendering will be
/// centered within the output display.
///
/// If the output display is a window, mouse events in the window will be filtered
/// and scaled so they seem to arrive within the logical resolution.
///
/// \note If this function results in scaling or subpixel drawing by the
/// rendering backend, it will be handled using the appropriate
/// quality hints.
///
/// \sa SDL_RenderGetLogicalSize()
/// \sa SDL_RenderSetScale()
/// \sa SDL_RenderSetViewport() 
 pub fn SDL_RenderSetLogicalSize ( renderer : * mut SDL_Renderer , w : ctypes :: c_int , h : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get device independent resolution for rendering
///
/// \param renderer The renderer from which resolution should be queried.
/// \param w      A pointer filled with the width of the logical resolution
/// \param h      A pointer filled with the height of the logical resolution
///
/// \sa SDL_RenderSetLogicalSize() 
 pub fn SDL_RenderGetLogicalSize ( renderer : * mut SDL_Renderer , w : * mut ctypes :: c_int , h : * mut ctypes :: c_int ) ; } extern "C" { 
 /// \brief Set whether to force integer scales for resolution-independent rendering
///
/// \param renderer The renderer for which integer scaling should be set.
/// \param enable   Enable or disable integer scaling
///
/// This function restricts the logical viewport to integer values - that is, when
/// a resolution is between two multiples of a logical size, the viewport size is
/// rounded down to the lower multiple.
///
/// \sa SDL_RenderSetLogicalSize() 
 pub fn SDL_RenderSetIntegerScale ( renderer : * mut SDL_Renderer , enable : SDL_bool ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get whether integer scales are forced for resolution-independent rendering
///
/// \param renderer The renderer from which integer scaling should be queried.
///
/// \sa SDL_RenderSetIntegerScale() 
 pub fn SDL_RenderGetIntegerScale ( renderer : * mut SDL_Renderer ) -> SDL_bool ; } extern "C" { 
 /// \brief Set the drawing area for rendering on the current target.
///
/// \param renderer The renderer for which the drawing area should be set.
/// \param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target.
///
/// The x,y of the viewport rect represents the origin for rendering.
///
/// \return 0 on success, or -1 on error
///
/// \note If the window associated with the renderer is resized, the viewport is automatically reset.
///
/// \sa SDL_RenderGetViewport()
/// \sa SDL_RenderSetLogicalSize() 
 pub fn SDL_RenderSetViewport ( renderer : * mut SDL_Renderer , rect : * const SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the drawing area for the current target.
///
/// \sa SDL_RenderSetViewport() 
 pub fn SDL_RenderGetViewport ( renderer : * mut SDL_Renderer , rect : * mut SDL_Rect ) ; } extern "C" { 
 /// \brief Set the clip rectangle for the current target.
///
/// \param renderer The renderer for which clip rectangle should be set.
/// \param rect   A pointer to the rectangle to set as the clip rectangle, or
/// NULL to disable clipping.
///
/// \return 0 on success, or -1 on error
///
/// \sa SDL_RenderGetClipRect() 
 pub fn SDL_RenderSetClipRect ( renderer : * mut SDL_Renderer , rect : * const SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the clip rectangle for the current target.
///
/// \param renderer The renderer from which clip rectangle should be queried.
/// \param rect   A pointer filled in with the current clip rectangle, or
/// an empty rectangle if clipping is disabled.
///
/// \sa SDL_RenderSetClipRect() 
 pub fn SDL_RenderGetClipRect ( renderer : * mut SDL_Renderer , rect : * mut SDL_Rect ) ; } extern "C" { 
 /// \brief Get whether clipping is enabled on the given renderer.
///
/// \param renderer The renderer from which clip state should be queried.
///
/// \sa SDL_RenderGetClipRect() 
 pub fn SDL_RenderIsClipEnabled ( renderer : * mut SDL_Renderer ) -> SDL_bool ; } extern "C" { 
 /// \brief Set the drawing scale for rendering on the current target.
///
/// \param renderer The renderer for which the drawing scale should be set.
/// \param scaleX The horizontal scaling factor
/// \param scaleY The vertical scaling factor
///
/// The drawing coordinates are scaled by the x/y scaling factors
/// before they are used by the renderer.  This allows resolution
/// independent drawing with a single coordinate system.
///
/// \note If this results in scaling or subpixel drawing by the
/// rendering backend, it will be handled using the appropriate
/// quality hints.  For best results use integer scaling factors.
///
/// \sa SDL_RenderGetScale()
/// \sa SDL_RenderSetLogicalSize() 
 pub fn SDL_RenderSetScale ( renderer : * mut SDL_Renderer , scaleX : f32 , scaleY : f32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the drawing scale for the current target.
///
/// \param renderer The renderer from which drawing scale should be queried.
/// \param scaleX A pointer filled in with the horizontal scaling factor
/// \param scaleY A pointer filled in with the vertical scaling factor
///
/// \sa SDL_RenderSetScale() 
 pub fn SDL_RenderGetScale ( renderer : * mut SDL_Renderer , scaleX : * mut f32 , scaleY : * mut f32 ) ; } extern "C" { 
 /// \brief Set the color used for drawing operations (Rect, Line and Clear).
///
/// \param renderer The renderer for which drawing color should be set.
/// \param r The red value used to draw on the rendering target.
/// \param g The green value used to draw on the rendering target.
/// \param b The blue value used to draw on the rendering target.
/// \param a The alpha value used to draw on the rendering target, usually
/// ::SDL_ALPHA_OPAQUE (255).
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_SetRenderDrawColor ( renderer : * mut SDL_Renderer , r : Uint8 , g : Uint8 , b : Uint8 , a : Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the color used for drawing operations (Rect, Line and Clear).
///
/// \param renderer The renderer from which drawing color should be queried.
/// \param r A pointer to the red value used to draw on the rendering target.
/// \param g A pointer to the green value used to draw on the rendering target.
/// \param b A pointer to the blue value used to draw on the rendering target.
/// \param a A pointer to the alpha value used to draw on the rendering target,
/// usually ::SDL_ALPHA_OPAQUE (255).
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_GetRenderDrawColor ( renderer : * mut SDL_Renderer , r : * mut Uint8 , g : * mut Uint8 , b : * mut Uint8 , a : * mut Uint8 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Set the blend mode used for drawing operations (Fill and Line).
///
/// \param renderer The renderer for which blend mode should be set.
/// \param blendMode ::SDL_BlendMode to use for blending.
///
/// \return 0 on success, or -1 on error
///
/// \note If the blend mode is not supported, the closest supported mode is
/// chosen.
///
/// \sa SDL_GetRenderDrawBlendMode() 
 pub fn SDL_SetRenderDrawBlendMode ( renderer : * mut SDL_Renderer , blendMode : SDL_BlendMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the blend mode used for drawing operations.
///
/// \param renderer The renderer from which blend mode should be queried.
/// \param blendMode A pointer filled in with the current blend mode.
///
/// \return 0 on success, or -1 on error
///
/// \sa SDL_SetRenderDrawBlendMode() 
 pub fn SDL_GetRenderDrawBlendMode ( renderer : * mut SDL_Renderer , blendMode : * mut SDL_BlendMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Clear the current rendering target with the drawing color
///
/// This function clears the entire rendering target, ignoring the viewport and
/// the clip rectangle.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderClear ( renderer : * mut SDL_Renderer ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Draw a point on the current rendering target.
///
/// \param renderer The renderer which should draw a point.
/// \param x The x coordinate of the point.
/// \param y The y coordinate of the point.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderDrawPoint ( renderer : * mut SDL_Renderer , x : ctypes :: c_int , y : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Draw multiple points on the current rendering target.
///
/// \param renderer The renderer which should draw multiple points.
/// \param points The points to draw
/// \param count The number of points to draw
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderDrawPoints ( renderer : * mut SDL_Renderer , points : * const SDL_Point , count : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Draw a line on the current rendering target.
///
/// \param renderer The renderer which should draw a line.
/// \param x1 The x coordinate of the start point.
/// \param y1 The y coordinate of the start point.
/// \param x2 The x coordinate of the end point.
/// \param y2 The y coordinate of the end point.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderDrawLine ( renderer : * mut SDL_Renderer , x1 : ctypes :: c_int , y1 : ctypes :: c_int , x2 : ctypes :: c_int , y2 : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Draw a series of connected lines on the current rendering target.
///
/// \param renderer The renderer which should draw multiple lines.
/// \param points The points along the lines
/// \param count The number of points, drawing count-1 lines
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderDrawLines ( renderer : * mut SDL_Renderer , points : * const SDL_Point , count : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Draw a rectangle on the current rendering target.
///
/// \param renderer The renderer which should draw a rectangle.
/// \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderDrawRect ( renderer : * mut SDL_Renderer , rect : * const SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Draw some number of rectangles on the current rendering target.
///
/// \param renderer The renderer which should draw multiple rectangles.
/// \param rects A pointer to an array of destination rectangles.
/// \param count The number of rectangles.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderDrawRects ( renderer : * mut SDL_Renderer , rects : * const SDL_Rect , count : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Fill a rectangle on the current rendering target with the drawing color.
///
/// \param renderer The renderer which should fill a rectangle.
/// \param rect A pointer to the destination rectangle, or NULL for the entire
/// rendering target.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderFillRect ( renderer : * mut SDL_Renderer , rect : * const SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Fill some number of rectangles on the current rendering target with the drawing color.
///
/// \param renderer The renderer which should fill multiple rectangles.
/// \param rects A pointer to an array of destination rectangles.
/// \param count The number of rectangles.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderFillRects ( renderer : * mut SDL_Renderer , rects : * const SDL_Rect , count : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Copy a portion of the texture to the current rendering target.
///
/// \param renderer The renderer which should copy parts of a texture.
/// \param texture The source texture.
/// \param srcrect   A pointer to the source rectangle, or NULL for the entire
/// texture.
/// \param dstrect   A pointer to the destination rectangle, or NULL for the
/// entire rendering target.
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderCopy ( renderer : * mut SDL_Renderer , texture : * mut SDL_Texture , srcrect : * const SDL_Rect , dstrect : * const SDL_Rect ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
///
/// \param renderer The renderer which should copy parts of a texture.
/// \param texture The source texture.
/// \param srcrect   A pointer to the source rectangle, or NULL for the entire
/// texture.
/// \param dstrect   A pointer to the destination rectangle, or NULL for the
/// entire rendering target.
/// \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction
/// \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).
/// \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
///
/// \return 0 on success, or -1 on error 
 pub fn SDL_RenderCopyEx ( renderer : * mut SDL_Renderer , texture : * mut SDL_Texture , srcrect : * const SDL_Rect , dstrect : * const SDL_Rect , angle : f64 , center : * const SDL_Point , flip : SDL_RendererFlip ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Read pixels from the current rendering target.
///
/// \param renderer The renderer from which pixels should be read.
/// \param rect   A pointer to the rectangle to read, or NULL for the entire
/// render target.
/// \param format The desired format of the pixel data, or 0 to use the format
/// of the rendering target
/// \param pixels A pointer to be filled in with the pixel data
/// \param pitch  The pitch of the pixels parameter.
///
/// \return 0 on success, or -1 if pixel reading is not supported.
///
/// \warning This is a very slow operation, and should not be used frequently. 
 pub fn SDL_RenderReadPixels ( renderer : * mut SDL_Renderer , rect : * const SDL_Rect , format : Uint32 , pixels : * mut ctypes :: c_void , pitch : ctypes :: c_int ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Update the screen with rendering performed. 
 pub fn SDL_RenderPresent ( renderer : * mut SDL_Renderer ) ; } extern "C" { 
 /// \brief Destroy the specified texture.
///
/// \sa SDL_CreateTexture()
/// \sa SDL_CreateTextureFromSurface() 
 pub fn SDL_DestroyTexture ( texture : * mut SDL_Texture ) ; } extern "C" { 
 /// \brief Destroy the rendering context for a window and free associated
/// textures.
///
/// \sa SDL_CreateRenderer() 
 pub fn SDL_DestroyRenderer ( renderer : * mut SDL_Renderer ) ; } extern "C" { 
 /// \brief Bind the texture to the current OpenGL/ES/ES2 context for use with
/// OpenGL instructions.
///
/// \param texture  The SDL texture to bind
/// \param texw     A pointer to a float that will be filled with the texture width
/// \param texh     A pointer to a float that will be filled with the texture height
///
/// \return 0 on success, or -1 if the operation is not supported 
 pub fn SDL_GL_BindTexture ( texture : * mut SDL_Texture , texw : * mut f32 , texh : * mut f32 ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Unbind a texture from the current OpenGL/ES/ES2 context.
///
/// \param texture  The SDL texture to unbind
///
/// \return 0 on success, or -1 if the operation is not supported 
 pub fn SDL_GL_UnbindTexture ( texture : * mut SDL_Texture ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the CAMetalLayer associated with the given Metal renderer
///
/// \param renderer The renderer to query
///
/// \return CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer
///
/// \sa SDL_RenderGetMetalCommandEncoder() 
 pub fn SDL_RenderGetMetalLayer ( renderer : * mut SDL_Renderer ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Get the Metal command encoder for the current frame
///
/// \param renderer The renderer to query
///
/// \return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer
///
/// \sa SDL_RenderGetMetalLayer() 
 pub fn SDL_RenderGetMetalCommandEncoder ( renderer : * mut SDL_Renderer ) -> * mut ctypes :: c_void ; } extern "C" { 
 /// \brief Create a window that can be shaped with the specified position, dimensions, and flags.
///
/// \param title The title of the window, in UTF-8 encoding.
/// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param w     The width of the window.
/// \param h     The height of the window.
/// \param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:
/// ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,
/// ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,
/// ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,
/// ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset.
///
/// \return The window created, or NULL if window creation failed.
///
/// \sa SDL_DestroyWindow() 
 pub fn SDL_CreateShapedWindow ( title : * const ctypes :: c_char , x : ctypes :: c_uint , y : ctypes :: c_uint , w : ctypes :: c_uint , h : ctypes :: c_uint , flags : Uint32 ) -> * mut SDL_Window ; } extern "C" { 
 /// \brief Return whether the given window is a shaped window.
///
/// \param window The window to query for being shaped.
///
/// \return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL.
///
/// \sa SDL_CreateShapedWindow 
 pub fn SDL_IsShapedWindow ( window : * const SDL_Window ) -> SDL_bool ; } 
 /// \brief The default mode, a binarized alpha cutoff of 1. 
 pub const WindowShapeMode_ShapeModeDefault : WindowShapeMode = 0 ; 
 /// \brief A binarized alpha cutoff with a given integer value. 
 pub const WindowShapeMode_ShapeModeBinarizeAlpha : WindowShapeMode = 1 ; 
 /// \brief A binarized alpha cutoff with a given integer value, but with the opposite comparison. 
 pub const WindowShapeMode_ShapeModeReverseBinarizeAlpha : WindowShapeMode = 2 ; 
 /// \brief A color key is applied. 
 pub const WindowShapeMode_ShapeModeColorKey : WindowShapeMode = 3 ; 
 /// \brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union. 
 pub type WindowShapeMode = u32 ; 
 /// \brief A union containing parameters for shaped windows. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union SDL_WindowShapeParams { 
 /// \brief A cutoff alpha value for binarization of the window shape's alpha channel. 
 pub binarizationCutoff : Uint8 , pub colorKey : SDL_Color , _bindgen_union_align : [ u8 ; 4usize ] , } # [ test ] fn bindgen_test_layout_SDL_WindowShapeParams ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_WindowShapeParams > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( SDL_WindowShapeParams ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_WindowShapeParams > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_WindowShapeParams ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowShapeParams > ( ) ) ) . binarizationCutoff as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowShapeParams ) , "::" , stringify ! ( binarizationCutoff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowShapeParams > ( ) ) ) . colorKey as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowShapeParams ) , "::" , stringify ! ( colorKey ) ) ) ; } 
 /// \brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct SDL_WindowShapeMode { 
 /// \brief The mode of these window-shape parameters. 
 pub mode : WindowShapeMode , 
 /// \brief Window-shape parameters. 
 pub parameters : SDL_WindowShapeParams , } # [ test ] fn bindgen_test_layout_SDL_WindowShapeMode ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_WindowShapeMode > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( SDL_WindowShapeMode ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_WindowShapeMode > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( SDL_WindowShapeMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowShapeMode > ( ) ) ) . mode as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowShapeMode ) , "::" , stringify ! ( mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_WindowShapeMode > ( ) ) ) . parameters as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( SDL_WindowShapeMode ) , "::" , stringify ! ( parameters ) ) ) ; } extern "C" { 
 /// \brief Set the shape and parameters of a shaped window.
///
/// \param window The shaped window whose parameters should be set.
/// \param shape A surface encoding the desired shape for the window.
/// \param shape_mode The parameters to set for the shaped window.
///
/// \return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW
/// if the SDL_Window given does not reference a valid shaped window.
///
/// \sa SDL_WindowShapeMode
/// \sa SDL_GetShapedWindowMode. 
 pub fn SDL_SetWindowShape ( window : * mut SDL_Window , shape : * mut SDL_Surface , shape_mode : * mut SDL_WindowShapeMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the shape parameters of a shaped window.
///
/// \param window The shaped window whose parameters should be retrieved.
/// \param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape.
///
/// \return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode
/// data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if
/// the SDL_Window given is a shapeable window currently lacking a shape.
///
/// \sa SDL_WindowShapeMode
/// \sa SDL_SetWindowShape 
 pub fn SDL_GetShapedWindowMode ( window : * mut SDL_Window , shape_mode : * mut SDL_WindowShapeMode ) -> ctypes :: c_int ; } extern "C" { 
 /// \brief Get the number of milliseconds since the SDL library initialization.
///
/// \note This value wraps if the program runs for more than ~49 days. 
 pub fn SDL_GetTicks ( ) -> Uint32 ; } extern "C" { 
 /// \brief Get the current value of the high resolution counter 
 pub fn SDL_GetPerformanceCounter ( ) -> Uint64 ; } extern "C" { 
 /// \brief Get the count per second of the high resolution counter 
 pub fn SDL_GetPerformanceFrequency ( ) -> Uint64 ; } extern "C" { 
 /// \brief Wait a specified number of milliseconds before returning. 
 pub fn SDL_Delay ( ms : Uint32 ) ; } 
 /// Function prototype for the timer callback function.
///
/// The callback function is passed the current timer interval and returns
/// the next timer interval.  If the returned value is the same as the one
/// passed in, the periodic alarm continues, otherwise a new alarm is
/// scheduled.  If the callback returns 0, the periodic alarm is cancelled. 
 pub type SDL_TimerCallback = :: core :: option :: Option < unsafe extern "C" fn ( interval : Uint32 , param : * mut ctypes :: c_void ) -> Uint32 > ; 
 /// Definition of the timer ID type. 
 pub type SDL_TimerID = ctypes :: c_int ; extern "C" { 
 /// \brief Add a new timer to the pool of timers already running.
///
/// \return A timer ID, or 0 when an error occurs. 
 pub fn SDL_AddTimer ( interval : Uint32 , callback : SDL_TimerCallback , param : * mut ctypes :: c_void ) -> SDL_TimerID ; } extern "C" { 
 /// \brief Remove a timer knowing its ID.
///
/// \return A boolean value indicating success or failure.
///
/// \warning It is not safe to remove a timer multiple times. 
 pub fn SDL_RemoveTimer ( id : SDL_TimerID ) -> SDL_bool ; } 
 /// \brief Information the version of SDL in use.
///
/// Represents the library's version as three levels: major revision
/// (increments with massive changes, additions, and enhancements),
/// minor revision (increments with backwards-compatible changes to the
/// major revision), and patchlevel (increments with fixes to the minor
/// revision).
///
/// \sa SDL_VERSION
/// \sa SDL_GetVersion 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_version { 
 /// < major version 
 pub major : Uint8 , 
 /// < minor version 
 pub minor : Uint8 , 
 /// < update version 
 pub patch : Uint8 , } # [ test ] fn bindgen_test_layout_SDL_version ( ) { assert_eq ! ( :: core :: mem :: size_of :: < SDL_version > ( ) , 3usize , concat ! ( "Size of: " , stringify ! ( SDL_version ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < SDL_version > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( SDL_version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_version > ( ) ) ) . major as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SDL_version ) , "::" , stringify ! ( major ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_version > ( ) ) ) . minor as * const _ as usize } , 1usize , concat ! ( "Offset of field: " , stringify ! ( SDL_version ) , "::" , stringify ! ( minor ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < SDL_version > ( ) ) ) . patch as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( SDL_version ) , "::" , stringify ! ( patch ) ) ) ; } extern "C" { 
 /// \brief Get the version of SDL that is linked against your program.
///
/// If you are linking to SDL dynamically, then it is possible that the
/// current version will be different than the version you compiled against.
/// This function returns the current version, while SDL_VERSION() is a
/// macro that tells you what version you compiled with.
///
/// \code
/// SDL_version compiled;
/// SDL_version linked;
///
/// SDL_VERSION(&compiled);
/// SDL_GetVersion(&linked);
/// printf("We compiled against SDL version %d.%d.%d ...\n",
/// compiled.major, compiled.minor, compiled.patch);
/// printf("But we linked against SDL version %d.%d.%d.\n",
/// linked.major, linked.minor, linked.patch);
/// \endcode
///
/// This function may be called safely at any time, even before SDL_Init().
///
/// \sa SDL_VERSION 
 pub fn SDL_GetVersion ( ver : * mut SDL_version ) ; } extern "C" { 
 /// \brief Get the code revision of SDL that is linked against your program.
///
/// Returns an arbitrary string (a hash value) uniquely identifying the
/// exact revision of the SDL library in use, and is only useful in comparing
/// against other revisions. It is NOT an incrementing number. 
 pub fn SDL_GetRevision ( ) -> * const ctypes :: c_char ; } extern "C" { 
 /// \brief Get the revision number of SDL that is linked against your program.
///
/// Returns a number uniquely identifying the exact revision of the SDL
/// library in use. It is an incrementing number based on commits to
/// hg.libsdl.org. 
 pub fn SDL_GetRevisionNumber ( ) -> ctypes :: c_int ; } extern "C" { 
 /// This function initializes  the subsystems specified by \c flags 
 pub fn SDL_Init ( flags : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// This function initializes specific SDL subsystems
///
/// Subsystem initialization is ref-counted, you must call
/// SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly
/// shutdown a subsystem manually (or call SDL_Quit() to force shutdown).
/// If a subsystem is already loaded then this call will
/// increase the ref-count and return. 
 pub fn SDL_InitSubSystem ( flags : Uint32 ) -> ctypes :: c_int ; } extern "C" { 
 /// This function cleans up specific SDL subsystems 
 pub fn SDL_QuitSubSystem ( flags : Uint32 ) ; } extern "C" { 
 /// This function returns a mask of the specified subsystems which have
/// previously been initialized.
///
/// If \c flags is 0, it returns a mask of all initialized subsystems. 
 pub fn SDL_WasInit ( flags : Uint32 ) -> Uint32 ; } extern "C" { 
 /// This function cleans up all initialized subsystems. You should
/// call it upon all exit conditions. 
 pub fn SDL_Quit ( ) ; } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : ctypes :: c_uint , pub fp_offset : ctypes :: c_uint , pub overflow_arg_area : * mut ctypes :: c_void , pub reg_save_area : * mut ctypes :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: core :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; } 
 /// < Private 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SDL_BlitMap { pub _address : u8 , }